//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   base
*         math big numbers
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”            2020‒10‒24 M
*******************************************************************************/
struct E_math_Z_bignum
{ N *digits;
  N digits_n;
  S exponent;
};
//==============================================================================
struct E_math_Z_bignum *
E_math_Q_bignum_M( void
){  struct E_math_Z_bignum *M_(num);
    if( !num )
        return 0;
    Mt_( num->digits, 1 );
    if( !num->digits )
    {   W(num);
        return 0;
    }
    num->digits[0] = 0;
    num->digits_n = 1;
    num->exponent = 0;
    return num;
}
struct E_math_Z_bignum *
E_math_Q_bignum_M_copy( struct E_math_Z_bignum *num_0
){  struct E_math_Z_bignum *M_(num);
    if( !num )
        return 0;
    Mt_( num->digits, num_0->digits_n );
    if( !num->digits )
    {   W(num);
        return 0;
    }
    E_mem_Q_blk_I_copy( &num->digits[0], &num_0->digits[0], num_0->digits_n * sizeof( num->digits[0] ));
    num->digits_n = num_0->digits_n;
    num->exponent = num_0->exponent;
    return num;
}
void
E_math_Q_bignum_M_move( struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  W( num_0->digits );
    E_math_Q_bignum_M_move_( num_0, num_1 );
}
void
E_math_Q_bignum_M_move_( struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  num_0->digits = num_1->digits;
    num_0->digits_n = num_1->digits_n;
    num_0->exponent = num_1->exponent;
}
void
E_math_Q_bignum_W( struct E_math_Z_bignum *num
){  W( num->digits );
    W(num);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
S
E_math_Q_bignum_I_compare(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  if(( !E_math_Q_bignum_R_sign( num_0 ) && !E_math_Q_bignum_R_sign( num_1 ))
    || ( E_math_Q_bignum_R_sign( num_0 ) && E_math_Q_bignum_R_sign( num_1 ))
    )
    {   struct E_math_Z_bignum *num_0_ = E_math_Q_bignum_M_copy( num_0 );
        if( !num_0_ )
            return ~0;
        if( !~E_math_Q_bignum_I_subtract( num_0_, num_1 ))
        {   E_math_Q_bignum_W( num_0_ );
            return ~0;
        }
        if( num_0_->digits_n == 1
        && num_0_->digits[0] == 0
        )
        {   E_math_Q_bignum_W( num_0_ );
            return 0;
        }
        if( !E_math_Q_bignum_R_sign( num_0_ ))
        {   E_math_Q_bignum_W( num_0_ );
            return 2;
        }
        E_math_Q_bignum_W( num_0_ );
        return -2;
    }
    if( !E_math_Q_bignum_R_sign( num_0 ))
        return 2;
    return -2;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
N
E_math_Q_bignum_I_add_subtract_begin(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  if( num_0->exponent != num_1->exponent )
    {   if( num_0->exponent > num_1->exponent )
        {   if( !E_mem_Q_blk_I_prepend( &num_0->digits, num_0->exponent - num_1->exponent ))
                return ~0;
            for_n( i, num_0->exponent - num_1->exponent )
                num_0->digits[i] = 0;
            num_0->digits_n += num_0->exponent - num_1->exponent;
            num_0->exponent = num_1->exponent;
        }else
        {   if( !E_mem_Q_blk_I_prepend( &num_1->digits, num_1->exponent - num_0->exponent ))
                return ~0;
            for_n( i, num_1->exponent - num_0->exponent )
                num_1->digits[i] = 0;
            num_1->digits_n += num_1->exponent - num_0->exponent;
            num_1->exponent = num_0->exponent;
        }
    }
    if( num_1->digits_n > num_0->digits_n )
    {   if( !E_mem_Q_blk_I_append( &num_0->digits, num_1->digits_n - num_0->digits_n ))
            return ~0;
        for_n( i, num_1->digits_n - num_0->digits_n )
            num_0->digits[ num_0->digits_n + i ] = 0;
        num_0->digits_n = num_1->digits_n;
    }
    return 0;
}
_internal
N
E_math_Q_bignum_I_add_subtract_end(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  N n = 0;
    for_n_rev( i, num_0->digits_n - 1 )
    {   if( num_0->digits[ i + 1 ] != 0
        || ( (S)num_0->digits[i] < 0 )
        )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_0->digits, num_0->digits_n - n, n ))
            return ~0;
        num_0->digits_n -= n;
    }
    n = 0;
    for_n_( i, num_0->digits_n - 1 )
    {   if( num_0->digits[i] != 0 )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_0->digits, 0, n ))
            return ~0;
        num_0->digits_n -= n;
        num_0->exponent += n;
    }
    return 0;
}
_internal
N
E_math_Q_bignum_I_multiply_sn_end( struct E_math_Z_bignum *num
){  N n = 0;
    for_n( i, num->digits_n - 1 )
    {   if( num->digits[i] != 0 )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num->digits, 0, n ))
            return ~0;
        num->digits_n -= n;
        num->exponent += n;
    }
    return 0;
}
//------------------------------------------------------------------------------
N
E_math_Q_bignum_I_multiply_2( struct E_math_Z_bignum *num
){  B sign = E_math_Q_bignum_R_sign(num);
    N over = 0;
    for_n( i, num->digits_n )
        __asm__ (
        #if defined( __i386__ )
        "\n" "mov       %0,%%ebx"
        "\n" "shl       %1"
        "\n" "setc      %%al"
        "\n" "or        %%ebx,%1"
        #elif defined( __x86_64__ )
        "\n" "mov       %0,%%rbx"
        "\n" "shl       %1"
        "\n" "setc      %%al"
        "\n" "or        %%rbx,%1"
        #else
#error not implemented
        #endif
        : "+a" (over)
        , "+rm" ( num->digits[i] )
        :
        : "cc"
        #if defined( __i386__ )
        , "ebx"
        #elif defined( __x86_64__ )
        , "rbx"
        #endif
        );
    if(over)
    {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
        if( !p )
            return ~0;
        num->digits_n++;
        *p = sign ? ~0 : 1;
    }else if( !sign
    && E_math_Q_bignum_R_sign(num)
    )
    {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
        if( !p )
            return ~0;
        num->digits_n++;
        *p = 0;
    }
    if( !~E_math_Q_bignum_I_multiply_sn_end(num) )
        return ~0;
    return 0;
}
_internal
N
E_math_Q_bignum_I_multiply_s(
  struct E_math_Z_bignum *num
, S n
){  B sign = ( E_math_Q_bignum_R_sign(num) && n >= 0 ) || ( !E_math_Q_bignum_R_sign(num) && n < 0 );
    N n_;
    N add_one;
    if( n < 0 )
    {   n_ = n & ( (N)~0 >> 1 ) ? -n : (N)~0 >> 1;
        add_one = n & ( (N)~0 >> 1 ) ? 0 : n_;
    }else
    {   n_ = n;
        add_one = 0;
    }
    N over = 0;
    for_n( i, num->digits_n - 1 )
        __asm__ (
        #if defined( __i386__ )
        "\n" "mov       %0,%%ebx"
        "\n" "mull      %2"
        "\n" "add       %%ebx,%1"
        "\n" "adcl      $0,%0"
        "\n" "add       %3,%1"
        "\n" "adcl      $0,%0"
        #elif defined( __x86_64__ )
        "\n" "mov       %0,%%rbx"
        "\n" "mulq      %2"
        "\n" "add       %%rbx,%1"
        "\n" "adcq      $0,%0"
        "\n" "add       %3,%1"
        "\n" "adcq      $0,%0"
        #else
#error not implemented
        #endif
        : "+d" (over)
        , "+a" ( num->digits[i] )
        : "rm" ( n_ )
        , "rm" ( add_one )
        : "cc"
        #if defined( __i386__ )
        , "ebx"
        #elif defined( __x86_64__ )
        , "rbx"
        #endif
        );
    __asm__ (
    #if defined( __i386__ )
    "\n" "mov       %0,%%ebx"
    "\n" "imull     %2"
    "\n" "add       %%ebx,%1"
    "\n" "adcl      $0,%0"
    #elif defined( __x86_64__ )
    "\n" "mov       %0,%%rbx"
    "\n" "imulq     %2"
    "\n" "add       %%rbx,%1"
    "\n" "adcq      $0,%0"
    #else
#error not implemented
    #endif
    : "+d" (over)
    , "+a" ( num->digits[ num->digits_n - 1 ] )
    : "rm" (n)
    : "cc"
    #if defined( __i386__ )
    , "ebx"
    #elif defined( __x86_64__ )
    , "rbx"
    #endif
    );
    if(over)
    {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
        if( !p )
            return ~0;
        num->digits_n++;
        *p = over;
    }
    if( !sign
    && E_math_Q_bignum_R_sign(num)
    )
    {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
        if( !p )
            return ~0;
        num->digits_n++;
        *p = 0;
    }
    if( !~E_math_Q_bignum_I_multiply_sn_end(num) )
        return ~0;
    return 0;
}
_internal
N
E_math_Q_bignum_I_multiply_n(
  struct E_math_Z_bignum *num
, N n
){  N over = 0;
    for_n( i, num->digits_n - 1 )
        __asm__ (
        #if defined( __i386__ )
        "\n" "mov       %0,%%ebx"
        "\n" "mull      %2"
        "\n" "add       %%ebx,%1"
        "\n" "adcl      $0,%0"
        #elif defined( __x86_64__ )
        "\n" "mov       %0,%%rbx"
        "\n" "mulq      %2"
        "\n" "add       %%rbx,%1"
        "\n" "adcq      $0,%0"
        #else
#error not implemented
        #endif
        : "+d" (over)
        , "+a" ( num->digits[i] )
        : "rm" (n)
        : "cc"
        #if defined( __i386__ )
        , "ebx"
        #elif defined( __x86_64__ )
        , "rbx"
        #endif
        );
    if( E_math_Q_bignum_R_sign(num) )
    {   N n_ = (N)~0 >> 1;
        n &= n_;
        N carry = 0;
        __asm__ (
        #if defined( __i386__ )
        "\n" "mov       %1,%%ebx"
        "\n" "mov       %2,%%ecx"
        "\n" "imull     %3"
        "\n" "mov       %2,%%edi"
        "\n" "mov       %1,%%esi"
        "\n" "mov       %%ecx,%2"
        "\n" "imull     %4"
        "\n" "add       %4,%2"
        "\n" "adcl      %%esi,%1"
        "\n" "adcl      $0,%0"
        "\n" "add       %%edi,%2"
        "\n" "adcl      $0,%1"
        "\n" "adcl      $0,%0"
        "\n" "add       %%ebx,%2"
        "\n" "adcl      $0,%1"
        "\n" "adcl      $0,%0"
        : "+m" (carry)
        , "+d" (over)
        , "+a" ( num->digits[ num->digits_n - 1 ] )
        : "m" (n)
        , "m" ( n_ )
        : "cc"
        , "ebx", "ecx", "esi", "edi"
        #elif defined( __x86_64__ )
        "\n" "mov       %1,%%rbx"
        "\n" "mov       %2,%%rcx"
        "\n" "imulq     %3"
        "\n" "mov       %2,%%rdi"
        "\n" "mov       %1,%%rsi"
        "\n" "mov       %%rcx,%2"
        "\n" "imulq     %4"
        "\n" "add       %4,%2"
        "\n" "adcq      %%rsi,%1"
        "\n" "adcq      $0,%0"
        "\n" "add       %%rdi,%2"
        "\n" "adcq      $0,%1"
        "\n" "adcq      $0,%0"
        "\n" "add       %%rbx,%2"
        "\n" "adcq      $0,%1"
        "\n" "adcq      $0,%0"
        : "+r" (carry)
        , "+d" (over)
        , "+a" ( num->digits[ num->digits_n - 1 ] )
        : "rm" (n)
        , "rm" ( n_ )
        : "cc"
        , "rbx", "rcx", "rsi", "rdi"
        #else
#error not implemented
        #endif
        );
        if(over)
        {   n = carry ? 2 : 1;
            N *p = E_mem_Q_blk_I_append( &num->digits, n );
            if( !p )
                return ~0;
            num->digits_n += n;
            p[0] = over;
            if(carry)
                p[1] = -carry;
        }
    }else
    {   __asm__ (
        #if defined( __i386__ )
        "\n" "mov       %0,%%ebx"
        "\n" "mull      %2"
        "\n" "add       %%ebx,%1"
        "\n" "adcl      $0,%0"
        #elif defined( __x86_64__ )
        "\n" "mov       %0,%%rbx"
        "\n" "mulq      %2"
        "\n" "add       %%rbx,%1"
        "\n" "adcq      $0,%0"
        #else
#error not implemented
        #endif
        : "+d" (over)
        , "+a" ( num->digits[ num->digits_n - 1 ] )
        : "rm" (n)
        : "cc"
        #if defined( __i386__ )
        , "ebx"
        #elif defined( __x86_64__ )
        , "rbx"
        #endif
        );
        if(over)
        {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
            if( !p )
                return ~0;
            num->digits_n++;
            *p = over;
        }
        if( E_math_Q_bignum_R_sign(num) )
        {   N *p = E_mem_Q_blk_I_append( &num->digits, 1 );
            if( !p )
                return ~0;
            num->digits_n++;
            *p = 0;
        }
    }
    if( !~E_math_Q_bignum_I_multiply_sn_end(num) )
        return ~0;
    return 0;
}
//------------------------------------------------------------------------------
N
E_math_Q_bignum_I_negate( struct E_math_Z_bignum *num
){  struct E_math_Z_bignum *num_ = E_math_Q_bignum_M();
    if( !num_ )
        return ~0;
    if( !~E_math_Q_bignum_I_subtract( num_, num ))
    {   E_math_Q_bignum_W( num_ );
        return ~0;
    }
    E_math_Q_bignum_M_move( num, num_ );
    W( num_ );
    return 0;
}
N
E_math_Q_bignum_I_abs( struct E_math_Z_bignum *num
){  if( !E_math_Q_bignum_R_sign(num) )
        return 0;
    if( !~E_math_Q_bignum_I_negate(num) )
        return ~0;
    return 0;
}
//------------------------------------------------------------------------------
N
E_math_Q_bignum_I_add(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  B sign = E_math_Q_bignum_R_sign( num_0 );
    if( !~E_math_Q_bignum_I_add_subtract_begin( num_0, num_1 ))
        return ~0;
    __asm__ goto (
    #if defined( __i386__ )
    "\n" "mov       (%1),%%eax"
    "\n" "add       %%eax,(%0)"
    "\n" "seto      %%al"
    "\n 1:decl      %2"
    "\n" "jz        3f"
    "\n" "decl      %3"
    "\n" "jz        2f"
    "\n" "lea       (%0,%4),%0"
    "\n" "lea       (%1,%4),%1"
    "\n" "mov       (%1),%%eax"
    "\n" "adc       %%eax,(%0)"
    "\n" "seto      %%al"
    "\n" "jmp       1b"
    "\n 2:jnc       %l[Next]"
    "\n" "lea       (%0,%4),%0"
    "\n" "adcl      $0,(%0)"
    "\n" "seto      %%al"
    "\n" "decl      %2"
    "\n" "jnz       2b"
    "\n 3:test      %%al,%%al"
    "\n" "jz        %l[Next]"
    #elif defined( __x86_64__ )
    "\n" "mov       (%1),%%rax"
    "\n" "add       %%rax,(%0)"
    "\n" "seto      %%al"
    "\n 1:decq      %2"
    "\n" "jz        3f"
    "\n" "decq      %3"
    "\n" "jz        2f"
    "\n" "lea       (%0,%4),%0"
    "\n" "lea       (%1,%4),%1"
    "\n" "mov       (%1),%%rax"
    "\n" "adc       %%rax,(%0)"
    "\n" "seto      %%al"
    "\n" "jmp       1b"
    "\n 2:jnc       %l[Next]"
    "\n" "lea       (%0,%4),%0"
    "\n" "adcq      $0,(%0)"
    "\n" "seto      %%al"
    "\n" "decq      %2"
    "\n" "jnz       2b"
    "\n 3:test      %%al,%%al"
    "\n" "jz        %l[Next]"
    #else
#error not implemented
    #endif
    :
    : "r" ( num_0->digits )
    , "r" ( num_1->digits )
    , "rm" ( num_0->digits_n )
    , "rm" ( num_1->digits_n )
    , "r" ( sizeof(N) )
    : "cc"
    #if defined( __i386__ )
    , "eax"
    #elif defined( __x86_64__ )
    , "rax"
    #endif
    : Next
    );
    N *p = E_mem_Q_blk_I_append( &num_0->digits, 1 );
    if( !p )
        return ~0;
    *p = sign ? ~0 : 1;
    num_0->digits_n++;
Next:
    if( !~E_math_Q_bignum_I_add_subtract_end( num_0, num_1 ))
        return ~0;
    return 0;
}
N
E_math_Q_bignum_I_subtract(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  B sign = E_math_Q_bignum_R_sign( num_0 );
    if( !~E_math_Q_bignum_I_add_subtract_begin( num_0, num_1 ))
        return ~0;
    __asm__ goto (
    #if defined( __i386__ )
    "\n" "mov       (%1),%%eax"
    "\n" "sub       %%eax,(%0)"
    "\n 1:decl      %3"
    "\n" "jz        3f"
    "\n" "decl      %2"
    "\n" "jz        2f"
    "\n" "lea       (%0,%4),%0"
    "\n" "lea       (%1,%4),%1"
    "\n" "mov       (%1),%%eax"
    "\n" "sbb       %%eax,(%0)"
    "\n" "jmp       1b"
    "\n 2:lea       (%0,%4),%0"
    "\n" "sbbl      $0,(%0)"
    "\n" "jnc       %l[Next]"
    "\n" "decl      %3"
    "\n" "jnz       2b"
    "\n 3:jnc       %l[Next]"
    #elif defined( __x86_64__ )
    "\n" "mov       (%1),%%rax"
    "\n" "sub       %%rax,(%0)"
    "\n 1:decq      %3"
    "\n" "jz        3f"
    "\n" "decq      %2"
    "\n" "jz        2f"
    "\n" "lea       (%0,%4),%0"
    "\n" "lea       (%1,%4),%1"
    "\n" "mov       (%1),%%rax"
    "\n" "sbb       %%rax,(%0)"
    "\n" "jmp       1b"
    "\n 2:lea       (%0,%4),%0"
    "\n" "sbbq      $0,(%0)"
    "\n" "jnc       %l[Next]"
    "\n" "decq      %3"
    "\n" "jnz       2b"
    "\n 3:jnc       %l[Next]"
    #else
#error not implemented
    #endif
    :
    : "r" ( num_0->digits )
    , "r" ( num_1->digits )
    , "rm" ( num_1->digits_n )
    , "rm" ( num_0->digits_n )
    , "r" ( sizeof(N) )
    : "cc"
    #if defined( __i386__ )
    , "eax"
    #elif defined( __x86_64__ )
    , "rax"
    #endif
    : Next
    );
    if( sign
    && !E_math_Q_bignum_R_sign( num_0 )
    )
    {   N *p = E_mem_Q_blk_I_append( &num_0->digits, 1 );
        if( !p )
            return ~0;
        *p = ~0;
        num_0->digits_n++;
    }
Next:;
    N n = 0;
    for_n_rev( i, num_0->digits_n - 1 )
    {   if( num_0->digits[ i + 1 ] != ~0
        || ( (S)num_0->digits[i] >= 0 )
        )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_0->digits, num_0->digits_n - n, n ))
            return ~0;
        num_0->digits_n -= n;
    }
    if( !~E_math_Q_bignum_I_add_subtract_end( num_0, num_1 ))
        return ~0;
    return 0;
}
N
E_math_Q_bignum_I_multiply(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
){  struct E_math_Z_bignum *num_;
    if( num_1->digits_n > 1 )
    {   num_ = E_math_Q_bignum_M_copy( num_0 );
        num_->exponent = 0;
        if( !~E_math_Q_bignum_I_multiply_n( num_, num_1->digits[0] ))
        {   E_math_Q_bignum_W( num_ );
            return ~0;
        }
        for_n( i, num_1->digits_n - 2 )
        {   struct E_math_Z_bignum *num = E_math_Q_bignum_M_copy( num_0 );
            if( !num )
            {   E_math_Q_bignum_W( num_ );
                return ~0;
            }
            num->exponent = 0;
            if( !~E_math_Q_bignum_I_multiply_n( num, num_1->digits[ i + 1 ] ))
            {   E_math_Q_bignum_W(num);
                E_math_Q_bignum_W( num_ );
                return ~0;
            }
            if( !E_mem_Q_blk_I_prepend( &num->digits, i + 1 ))
            {   E_math_Q_bignum_W(num);
                E_math_Q_bignum_W( num_ );
                return ~0;
            }
            for_n( j, i + 1 )
                num->digits[j] = 0;
            if( !~E_math_Q_bignum_I_add( num_, num ))
            {   E_math_Q_bignum_W(num);
                E_math_Q_bignum_W( num_ );
                return ~0;
            }
            E_math_Q_bignum_W(num);
        }
    }else
        num_ = E_math_Q_bignum_M();
    struct E_math_Z_bignum *num = E_math_Q_bignum_M_copy( num_0 );
    if( !num )
    {   E_math_Q_bignum_W( num_ );
        return ~0;
    }
    num->exponent = 0;
    if( !~E_math_Q_bignum_I_multiply_s( num, (S)num_1->digits[ num_1->digits_n - 1 ] ))
    {   E_math_Q_bignum_W(num);
        E_math_Q_bignum_W( num_ );
        return ~0;
    }
    if( num_1->digits_n - 1 )
    {   if( !E_mem_Q_blk_I_prepend( &num->digits, num_1->digits_n - 1 ))
        {   E_math_Q_bignum_W(num);
            E_math_Q_bignum_W( num_ );
            return ~0;
        }
        num->digits_n += num_1->digits_n - 1;
        for_n( j, num_1->digits_n - 1 )
            num->digits[j] = 0;
    }
    if( !~E_math_Q_bignum_I_add( num_, num ))
    {   E_math_Q_bignum_W(num);
        E_math_Q_bignum_W( num_ );
        return ~0;
    }
    E_math_Q_bignum_W(num);
    num_->exponent += num_0->exponent + num_1->exponent;
    E_math_Q_bignum_M_move( num_0, num_ );
    W( num_ );
    N n = 0;
    for_n( i, num_0->digits_n - 1 )
    {   if( num_0->digits[i] != 0 )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_0->digits, 0, n ))
            return ~0;
        num_0->digits_n -= n;
        num_0->exponent += n;
    }
    return 0;
}
// Parametry tej procedury muszą być różnymi obiektami.
N
E_math_Q_bignum_I_divide_modulo_min_prec(
  struct E_math_Z_bignum *num_0
, struct E_math_Z_bignum *num_1
, N min_prec
){  J_assert( num_1->exponent || num_1->digits[0] ); // != 0
    num_0->exponent -= num_1->exponent;
    if( num_0->exponent > 0 )
    {   if( !E_mem_Q_blk_I_prepend( &num_0->digits, num_0->exponent ))
            return ~0;
        num_0->digits_n += num_0->exponent;
        for_n( i, num_0->exponent )
            num_0->digits[i] = 0;
        num_0->exponent = 0;
    }
    if( min_prec > -num_0->exponent )
    {   if( !E_mem_Q_blk_I_prepend( &num_0->digits, min_prec - -num_0->exponent ))
            return ~0;
        num_0->digits_n += min_prec - -num_0->exponent;
        for_n( i, min_prec - -num_0->exponent )
            num_0->digits[i] = 0;
        num_0->exponent -= min_prec - -num_0->exponent;
    }
    B sign = ( E_math_Q_bignum_R_sign( num_0 ) && !E_math_Q_bignum_R_sign( num_1 )) || ( !E_math_Q_bignum_R_sign( num_0 ) && E_math_Q_bignum_R_sign( num_1 ));
    if( !~E_math_Q_bignum_I_abs( num_0 )
    || !~E_math_Q_bignum_I_abs( num_1 )
    )
        return ~0;
    if( !num_1->digits[ num_1->digits_n - 1 ] )
    {   if( !E_mem_Q_blk_I_remove( &num_1->digits, num_1->digits_n - 1, 1 ))
            return ~0;
        num_1->digits_n--;
    }
    if( num_0->digits_n < num_1->digits_n )
    {   struct E_math_Z_bignum *num_div = E_math_Q_bignum_M();
        if( !num_div )
            return ~0;
        E_math_Q_bignum_M_move( num_1, num_0 );
        E_math_Q_bignum_M_move_( num_0, num_div );
        W( num_div );
        N n = 0;
        for_n( i, num_0->digits_n - 1 )
        {   if( num_0->digits[i] != 0 )
                break;
            n++;
        }
        if(n)
        {   if( !E_mem_Q_blk_I_remove( &num_0->digits, 0, n ))
                return ~0;
            num_0->digits_n -= n;
            num_0->exponent += n;
        }
                return 0;
        if(sign)
            if( !~E_math_Q_bignum_I_negate( num_0 ))
                return ~0;
    }
    struct E_math_Z_bignum *M_( num_div );
    if( !num_div )
        return ~0;
    Mt_( num_div->digits, 0 );
    if( !num_div->digits )
    {   W( num_div );
        return ~0;
    }
    num_div->digits_n = 0;
    struct E_math_Z_bignum *M_( num_mod );
    if( !num_mod )
    {   E_math_Q_bignum_W( num_div );
        return ~0;
    }
    Mt_( num_mod->digits, 0 );
    if( !num_mod->digits )
    {   W( num_mod );
        E_math_Q_bignum_W( num_div );
        return ~0;
    }
    num_mod->digits_n = 0;
    //G_(); Gh( num_0->exponent );
    //for_n( j, num_0->digits_n )
    //{   G_(); Gd(j); Gh( num_0->digits[j] );
    //}
    //G_(); Gh( num_1->exponent );
    //for_n_( j, num_1->digits_n )
    //{   G_(); Gd(j); Gh( num_1->digits[j] );
    //}
    N e_0 = num_0->digits_n - 1;
    N e_1 = num_1->digits_n - 1;
    N e_div = 0;
    N k_0 = E_asm_I_bsr( num_0->digits[ e_0 ] ) + 1;
    N n_0 = 0;
    O{  N n_1 = num_1->digits[ e_1 ];
        N k = E_asm_I_bsr( n_0 ) + 1;
        //G_(); Gd(k); Gd( k_0 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
        J_assert( k_0 <= sizeof(N) * 8 );
        if( e_1 == num_1->digits_n - 1 )
        {   N k_1 = E_asm_I_bsr( n_1 );
            //G_(); Gd( k_1 );
            if( k_0 + k < k_1 + 1 )
            {   n_0 <<= k_0;
                n_0 |= num_0->digits[ e_0 ] & ( (N)~0 >> ( sizeof(N) * 8 - k_0 ));
                //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                if( !n_0 )
                {   if( !e_0 )
                    {   if( !num_mod->digits_n )
                        {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_mod->digits_n = 1;
                            num_mod->digits[0] = 0;
                        }
                        break;
                    }
                    e_0--;
                    if( !e_div )
                    {   if( num_div->digits_n )
                        {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_div->digits_n++;
                            num_div->digits[0] = 0;
                        }
                    }else
                        e_div--;
                    while( !num_0->digits[ e_0 ] )
                    {   num_0->digits[ e_0 ] = 0;
                        if( num_mod->digits_n )
                        {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_mod->digits_n++;
                            num_mod->digits[0] = 0;
                        }
                        if( !e_0 )
                        {   if( !num_mod->digits_n )
                            {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_mod->digits_n = 1;
                                num_mod->digits[0] = 0;
                            }
                            goto End;
                        }
                        e_0--;
                        if( !e_div )
                        {   if( num_div->digits_n )
                            {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_div->digits_n++;
                                num_div->digits[0] = 0;
                            }
                        }else
                            e_div--;
                    }
                    k = E_asm_I_bsr( num_0->digits[ e_0 ] ) + 1;
                    N j = k_1 + 1;
                    N l;
                    //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                    if( j > k )
                    {   n_0 = num_0->digits[ e_0 ];
                        num_0->digits[ e_0 ] = 0;
                        if( !e_0 )
                        {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_mod->digits_n++;
                            num_mod->digits[0] = n_0;
                            break;
                        }
                        e_0--;
                        if( !e_div )
                        {   if( num_div->digits_n )
                            {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_div->digits_n++;
                                num_div->digits[0] = 0;
                            }
                        }else
                            e_div--;
                        l = j - 1;
                        j -= k;
                        k_0 = sizeof(N) * 8 - j;
                        n_0 <<= j;
                        n_0 |= num_0->digits[ e_0 ] >> k_0;
                    }else
                    {   l = j - 1;
                        k_0 = k - j;
                        n_0 = num_0->digits[ e_0 ] >> k_0;
                    }
                    //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                    if( n_0 < n_1 )
                    {   while( l++ != sizeof(N) * 8 )
                        {   k_0--;
                            n_0 <<= 1;
                            n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                            if( n_0 >= n_1 )
                                break;
                        }
                        if( !~k_0 )
                            k_0 = 0;
                    }
                }else
                    if( n_0 < n_1 )
                    {   if( !e_0 )
                        {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_mod->digits_n++;
                            num_mod->digits[0] = n_0;
                            break;
                        }
                        e_0--;
                        if( !e_div )
                        {   if( num_div->digits_n )
                            {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_div->digits_n++;
                                num_div->digits[0] = 0;
                            }
                        }else
                            e_div--;
                        N j = k_0 - 1;
                        k_0 = sizeof(N) * 8;
                        //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                        while( j++ != sizeof(N) * 8 )
                        {   k_0--;
                            n_0 <<= 1;
                            n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                            if( n_0 >= n_1 )
                                break;
                        }
                        if( !~k_0 )
                            k_0 = 0;
                    }
            }else
            {   if( k_1 + 1 > k )
                {   N j = k_1 + 1 - k;
                    k_0 -= j;
                    if( j != sizeof(N) * 8 )
                    {   n_0 <<= j;
                        n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & ( (N)~0 >> ( sizeof(N) * 8 - j ));
                    }else
                        n_0 = num_0->digits[ e_0 ];
                    //G_(); Gd(j); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                    if( !n_0 )
                    {   while( k_0-- )
                        {   n_0 <<= 1;
                            n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                            if( n_0 >= n_1 )
                                break;
                        }
                        //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                        if( !n_0 )
                        {   if( !e_0 )
                            {   if( !num_mod->digits_n )
                                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_mod->digits_n = 1;
                                    num_mod->digits[0] = 0;
                                }
                                break;
                            }
                            e_0--;
                            if( !e_div )
                            {   if( num_div->digits_n )
                                {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_div->digits_n++;
                                    num_div->digits[0] = 0;
                                }
                            }else
                                e_div--;
                            while( !num_0->digits[ e_0 ] )
                            {   num_0->digits[ e_0 ] = 0;
                                if( num_mod->digits_n )
                                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_mod->digits_n++;
                                    num_mod->digits[0] = 0;
                                }
                                if( !e_0 )
                                {   if( !num_mod->digits_n )
                                    {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                        {   E_math_Q_bignum_W( num_mod );
                                            E_math_Q_bignum_W( num_div );
                                            return ~0;
                                        }
                                        num_mod->digits_n = 1;
                                        num_mod->digits[0] = 0;
                                    }
                                    goto End;
                                }
                                e_0--;
                                if( !e_div )
                                {   if( num_div->digits_n )
                                    {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                        {   E_math_Q_bignum_W( num_mod );
                                            E_math_Q_bignum_W( num_div );
                                            return ~0;
                                        }
                                        num_div->digits_n++;
                                        num_div->digits[0] = 0;
                                    }
                                }else
                                    e_div--;
                            }
                            k_0 = E_asm_I_bsr( num_0->digits[ e_0 ] ) + 1;
                            N j = k_1 + 1;
                            k = k_0;
                            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                            if( j > k )
                            {   n_0 = num_0->digits[ e_0 ];
                                if( !e_0 )
                                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_mod->digits_n++;
                                    num_mod->digits[0] = n_0;
                                    break;
                                }
                                e_0--;
                                if( !e_div )
                                {   if( num_div->digits_n )
                                    {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                        {   E_math_Q_bignum_W( num_mod );
                                            E_math_Q_bignum_W( num_div );
                                            return ~0;
                                        }
                                        num_div->digits_n++;
                                        num_div->digits[0] = 0;
                                    }
                                }else
                                    e_div--;
                                j -= k;
                                k_0 = sizeof(N) * 8 - j;
                                n_0 <<= j;
                                n_0 |= num_0->digits[ e_0 ] >> k_0;
                            }else
                            {   k_0 -= j;
                                n_0 = num_0->digits[ e_0 ] >> k_0;
                            }
                            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                            if( n_0 < n_1 )
                            {   if( k_0-- )
                                {   n_0 <<= 1;
                                    n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                                }
                                if( !~k_0 )
                                {   if( !e_0 )
                                    {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                        {   E_math_Q_bignum_W( num_mod );
                                            E_math_Q_bignum_W( num_div );
                                            return ~0;
                                        }
                                        num_mod->digits_n++;
                                        num_mod->digits[0] = n_0;
                                        break;
                                    }
                                    e_0--;
                                    if( !e_div )
                                    {   if( num_div->digits_n )
                                        {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                            {   E_math_Q_bignum_W( num_mod );
                                                E_math_Q_bignum_W( num_div );
                                                return ~0;
                                            }
                                            num_div->digits_n++;
                                            num_div->digits[0] = 0;
                                        }
                                    }else
                                        e_div--;
                                    k_0 = sizeof(N) * 8 - 1;
                                    n_0 <<= 1;
                                    n_0 |= num_0->digits[ e_0 ] >> k_0;
                                }
                            }
                        }else if( !~k_0 )
                        {   if( !e_0 )
                            {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_mod->digits_n++;
                                num_mod->digits[0] = n_0;
                                break;
                            }
                            e_0--;
                            if( !e_div )
                            {   if( num_div->digits_n )
                                {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_div->digits_n++;
                                    num_div->digits[0] = 0;
                                }
                            }else
                                e_div--;
                            k = E_asm_I_bsr( n_0 ) + 1;
                            N j = k_1 + 1 - k;
                            k_0 = sizeof(N) * 8 - j;
                            if(j)
                            {   n_0 <<= j;
                                n_0 |= num_0->digits[ e_0 ] >> k_0;
                            }
                            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                            if( n_0 < n_1 )
                            {   k_0--;
                                n_0 <<= 1;
                                n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                            }
                        }
                    }else
                        if( n_0 < n_1 )
                        {   while( k_0-- )
                            {   n_0 <<= 1;
                                n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                                if( n_0 >= n_1 )
                                    break;
                            }
                            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                            if( !~k_0 )
                            {   if( !e_0 )
                                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                                    {   E_math_Q_bignum_W( num_mod );
                                        E_math_Q_bignum_W( num_div );
                                        return ~0;
                                    }
                                    num_mod->digits_n++;
                                    num_mod->digits[0] = n_0;
                                    break;
                                }
                                e_0--;
                                if( !e_div )
                                {   if( num_div->digits_n )
                                    {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                        {   E_math_Q_bignum_W( num_mod );
                                            E_math_Q_bignum_W( num_div );
                                            return ~0;
                                        }
                                        num_div->digits_n++;
                                        num_div->digits[0] = 0;
                                    }
                                }else
                                    e_div--;
                                k = E_asm_I_bsr( n_0 ) + 1;
                                N j = k_1 + 1 - k;
                                k_0 = sizeof(N) * 8 - j;
                                //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                                while( k_0-- )
                                {   n_0 <<= 1;
                                    n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                                    if( n_0 >= n_1 )
                                        break;
                                }
                            }
                        }
                }else //if( n_0 < n_1 ) // Oczywistość z integralności algorytmu.
                {   if( k_0-- )
                    {   n_0 <<= 1;
                        n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                    }
                    //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                    if( !~k_0 )
                    {   if( !e_0 )
                        {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                            {   E_math_Q_bignum_W( num_mod );
                                E_math_Q_bignum_W( num_div );
                                return ~0;
                            }
                            num_mod->digits_n++;
                            num_mod->digits[0] = n_0;
                            break;
                        }
                        e_0--;
                        if( !e_div )
                        {   if( num_div->digits_n )
                            {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                                {   E_math_Q_bignum_W( num_mod );
                                    E_math_Q_bignum_W( num_div );
                                    return ~0;
                                }
                                num_div->digits_n++;
                                num_div->digits[0] = 0;
                            }
                        }else
                            e_div--;
                        k_0 = sizeof(N) * 8 - 1;
                        //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                        n_0 <<= 1;
                        n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                    }
                }
            }
            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
            n_0 -= n_1;
            //G_(); Gd(k); Gd( k_0 ); Gd( k_1 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
            if( !e_1 )
            {   if( !num_div->digits_n )
                {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                    {   E_math_Q_bignum_W( num_mod );
                        E_math_Q_bignum_W( num_div );
                        return ~0;
                    }
                    num_div->digits_n = 1;
                    num_div->digits[0] = 0;
                }
                num_div->digits[0] |= (N)1 << k_0;
            }
        }else
        {   if( num_mod->digits_n
            || n_0
            )
            {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                {   E_math_Q_bignum_W( num_mod );
                    E_math_Q_bignum_W( num_div );
                    return ~0;
                }
                num_mod->digits_n++;
                num_mod->digits[0] = n_0;
            }
            N n_0_ = n_0;
            n_0 = num_0->digits[ e_0 ];
            N j = sizeof(N) * 8 - k_0;
            //G_(); Gd(j); Gd(k); Gd( k_0 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
            if(j)
            {   if( !e_0 )
                {   if( !e_1 )
                    {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                        {   E_math_Q_bignum_W( num_mod );
                            E_math_Q_bignum_W( num_div );
                            return ~0;
                        }
                        num_mod->digits_n++;
                        num_mod->digits[0] = n_0;
                    }
                    break;
                }
                e_0--;
                if( !e_div )
                {   if( num_div->digits_n )
                    {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                        {   E_math_Q_bignum_W( num_mod );
                            E_math_Q_bignum_W( num_div );
                            return ~0;
                        }
                        num_div->digits_n++;
                        num_div->digits[0] = 0;
                    }
                }else
                    e_div--;
                n_0 <<= j;
                n_0 |= ( num_0->digits[ e_0 ] >> k_0 ) & ( (N)~0 >> ( sizeof(N) * 8 - j ));
                //G_(); Gd(j); Gd(k); Gd( k_0 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
                if( n_0 < n_1 )
                {   if( !num_mod->digits_n )
                    {   if( k_0 )
                        {   k_0--;
                            e_0++;
                            if( num_div->digits_n )
                                e_div++;
                        }else
                            k_0 = sizeof(N) * 8 - 1;
                        n_0_ = num_1->digits[ e_1 + 1 ];
                        n_0_ <<= 1;
                        n_0_ |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                        n_0_ -= num_1->digits[ e_1 + 1 ] + 1;
                        n_0 = n_0_;
                        //G_(); Gh( n_0 ); Gd( k_0 );
                        goto After_shift_one;
                    }
                    N e = 0;
                    do
                    {   n_0_ = num_mod->digits[e];
                        num_mod->digits[e]--;
                        e++;
                    }while( !n_0_ );
                }
            }else
            {   if( n_0 < n_1 )
                {   if( !num_mod->digits_n )
                    {   k_0--;
                        n_0_ = num_1->digits[ e_1 + 1 ];
                        n_0_ <<= 1;
                        n_0_ |= ( num_0->digits[ e_0 ] >> k_0 ) & 1;
                        n_0_ -= num_1->digits[ e_1 + 1 ] + 1;
                        n_0 = n_0_;
                        //G_(); Gh( n_0 ); Gd( k_0 );
                        goto After_shift_one;
                    }
                    N e = 0;
                    do
                    {   n_0_ = num_mod->digits[e];
                        num_mod->digits[e]--;
                        e++;
                    }while( !n_0_ );
                }
                k_0 = 0;
            }
            //G_(); Gd(k); Gd( k_0 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
            n_0 -= n_1;
            //G_(); Gd(k); Gd( k_0 ); Gh( n_0 ); Gh( n_1 ); Gh( num_0->digits[ e_0 ] );
            if( !e_1 )
            {   if( !num_div->digits_n )
                {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                    {   E_math_Q_bignum_W( num_mod );
                        E_math_Q_bignum_W( num_div );
                        return ~0;
                    }
                    num_div->digits_n = 1;
                    num_div->digits[0] = 0;
                }
                J_assert( e_div < num_div->digits_n );
                num_div->digits[ e_div ] |= (N)1 << k_0;
                //G_(); Gd( e_div ); Gh( num_div->digits[ e_div ] );
                if((( num_mod->digits_n ? num_mod->digits_n - 1 : 0 ) + 1 + e_0 ) * sizeof(N) * 8 + ( num_mod->digits_n ? E_asm_I_bsr( num_mod->digits[ num_mod->digits_n - 1 ] ) + 1 : 0 ) + k_0
                >= ( num_1->digits_n - 1 ) * sizeof(N) * 8 + E_asm_I_bsr( num_1->digits[ num_1->digits_n - 1 ] ) + 1
                )
                {   num_0->digits[ e_0 ] &= (N)~0 >> ( sizeof(N) * 8 - k_0 );
                    num_0->digits[ e_0 ] |= n_0 << k_0;
                    n_0 >>= sizeof(N) * 8 - k_0;
                    if( num_mod->digits_n )
                    {   for_n( i, num_mod->digits_n - 1 )
                        {   e_0++;
                            if( num_div->digits_n )
                                e_div++;
                            num_0->digits[ e_0 ] = ( num_mod->digits[i] << k_0 ) | n_0;
                            n_0 = num_mod->digits[i] >> ( sizeof(N) * 8 - k_0 );
                        }
                        e_0++;
                        if( num_div->digits_n )
                            e_div++;
                        k = E_asm_I_bsr( num_mod->digits[ num_mod->digits_n - 1 ] ) + 1;
                        num_0->digits[ e_0 ] = ( num_mod->digits[ num_mod->digits_n - 1 ] << k_0 ) | n_0;
                        n_0 = num_mod->digits[  num_mod->digits_n - 1 ] >> ( sizeof(N) * 8 - k_0 );
                        if( !E_mem_Q_blk_I_remove( &num_mod->digits, 0, num_mod->digits_n ))
                        {   E_math_Q_bignum_W( num_mod );
                            E_math_Q_bignum_W( num_div );
                            return ~0;
                        }
                        num_mod->digits_n = 0;
                        k_0 += k;
                        if( k_0 > sizeof(N) * 8 )
                        {   k_0 -= sizeof(N) * 8;
                            e_0++;
                            if( num_div->digits_n )
                                e_div++;
                            num_0->digits[ e_0 ] = n_0;
                        }
                    }else
                    {   e_0++;
                        if( num_div->digits_n )
                            e_div++;
                        num_0->digits[ e_0 ] = n_0;
                        k_0 = E_asm_I_bsr( num_0->digits[ e_0 ] ) + 1;
                    }
                    n_0 = 0;
                }
            }
        }
        //G_(); Gd( e_1 ); Gd( e_0 ); Gd( e_div ); Gd( num_div->digits_n );
        if( e_1 )
            e_1--;
        else
        {   if( num_1->digits_n != 1
            && ( 1 + e_0 ) * sizeof(N) * 8 + k_0
              < ( num_1->digits_n - 1 ) * sizeof(N) * 8 + E_asm_I_bsr( num_1->digits[ num_1->digits_n - 1 ] ) + 1
            )
            {   N j = sizeof(N) * 8 - k_0;
                N n_0_;
                if( j != sizeof(N) * 8 )
                    n_0_ = num_0->digits[ e_0 ] & ( (N)~0 >> j );
                else
                    n_0_ = 0;
                if( k_0 != sizeof(N) * 8 )
                {   n_0_ |= n_0 << k_0;
                    if( j != sizeof(N) * 8 )
                        n_0 >>= j;
                    else
                        n_0 = 0;
                }
                if( n_0 ) // Czy zostało coś z nadmiaru słowa reszty z dzielenia?
                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                    {   E_math_Q_bignum_W( num_mod );
                        E_math_Q_bignum_W( num_div );
                        return ~0;
                    }
                    num_mod->digits_n++;
                    num_mod->digits[0] = n_0;
                }
                if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                {   E_math_Q_bignum_W( num_mod );
                    E_math_Q_bignum_W( num_div );
                    return ~0;
                }
                num_mod->digits_n++;
                num_mod->digits[0] = n_0_;
                if( e_0 )
                {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, e_0 ))
                    {   E_math_Q_bignum_W( num_mod );
                        E_math_Q_bignum_W( num_div );
                        return ~0;
                    }
                    num_mod->digits_n += e_0;
                    for_n( i, e_0 )
                        num_mod->digits[0] = num_0->digits[i];
                }
                break;
            }
            e_1 = num_1->digits_n - 1;
        }
After_shift_one:
        if( !k_0 )
        {   if( !e_0 )
            {   if( !E_mem_Q_blk_I_prepend( &num_mod->digits, 1 ))
                {   E_math_Q_bignum_W( num_mod );
                    E_math_Q_bignum_W( num_div );
                    return ~0;
                }
                num_mod->digits_n++;
                num_mod->digits[0] = n_0;
                break;
            }
            e_0--;
            if( !e_div )
            {   if( num_div->digits_n )
                {   if( !E_mem_Q_blk_I_prepend( &num_div->digits, 1 ))
                    {   E_math_Q_bignum_W( num_mod );
                        E_math_Q_bignum_W( num_div );
                        return ~0;
                    }
                    num_div->digits_n++;
                    num_div->digits[0] = 0;
                }
            }else
                e_div--;
            k_0 = sizeof(N) * 8;
        }
    }
End:num_div->exponent = num_0->exponent + e_0;
    num_mod->exponent = num_0->exponent;
    E_math_Q_bignum_M_move( num_0, num_div );
    W( num_div );
    E_math_Q_bignum_M_move( num_1, num_mod );
    W( num_mod );
    if( !num_0->digits_n )
    {   if( !E_mem_Q_blk_I_prepend( &num_0->digits, 1 ))
            return ~0;
        num_0->digits_n = 1;
        num_0->digits[0] = 0;
    }else if( (S)num_0->digits[ num_0->digits_n - 1 ] < 0 )
    {   if( !E_mem_Q_blk_I_append( &num_0->digits, 1 ))
            return ~0;
        num_0->digits[ num_0->digits_n ] = 0;
        num_0->digits_n++;
    }
    N n = 0;
    for_n( i, num_0->digits_n - 1 )
    {   if( num_0->digits[i] != 0 )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_0->digits, 0, n ))
            return ~0;
        num_0->digits_n -= n;
        num_0->exponent += n;
    }
    n = 0;
    for_n_( i, num_1->digits_n - 1 )
    {   if( num_1->digits[i] != 0 )
            break;
        n++;
    }
    if(n)
    {   if( !E_mem_Q_blk_I_remove( &num_1->digits, 0, n ))
            return ~0;
        num_1->digits_n -= n;
        num_1->exponent += n;
    }
    if( (S)num_1->digits[ num_1->digits_n - 1 ] < 0 )
    {   if( !E_mem_Q_blk_I_append( &num_1->digits, 1 ))
            return ~0;
        num_1->digits[ num_1->digits_n ] = 0;
        num_1->digits_n++;
    }else if( num_1->digits_n > 1
    && !num_1->digits[ num_1->digits_n - 1 ]
    && (S)num_1->digits[ num_1->digits_n - 2 ] >= 0
    )
    {   if( !E_mem_Q_blk_I_remove( &num_1->digits, num_1->digits_n - 1, 1 ))
            return ~0;
        num_1->digits_n--;
    }
    //G_(); Gh( num_0->exponent );
    //for_n_( j, num_0->digits_n )
    //{   G_(); Gd(j); Gh( num_0->digits[j] );
    //}
    //G_(); Gh( num_1->exponent );
    //for_n_( j, num_1->digits_n )
    //{   G_(); Gd(j); Gh( num_1->digits[j] );
    //}
    if(sign)
        if( !~E_math_Q_bignum_I_negate( num_0 ))
            return ~0;
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Pc
E_math_Q_bignum_I_print( struct E_math_Z_bignum *num
){  Pc Mt_( s, 0 );
    if( !s )
        return 0;
    struct E_math_Z_bignum *num_div;
    N n_1;
    if( -num->exponent >= (S)num->digits_n )
    {   if( !E_mem_Q_blk_I_prepend( &s, 1 ))
        {   W(s);
            return 0;
        }
        *s = '0';
        n_1 = 1;
    }else
    {   n_1 = 0;
        num_div = E_math_Q_bignum_M_copy(num);
        if( !num_div )
        {   W(s);
            return 0;
        }
        if( !~E_math_Q_bignum_I_abs( num_div ))
        {   E_math_Q_bignum_W( num_div );
            W(s);
            return 0;
        }
        if( -num->exponent > 0 )
        {   if( !E_mem_Q_blk_I_remove( &num_div->digits, 0, -num->exponent ))
            {   E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            num_div->digits_n -= -num->exponent;
            num_div->exponent = 0;
        }
        do
        {   struct E_math_Z_bignum *num_mod = E_math_Q_bignum_M();
            if( !num_mod )
            {   E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            num_mod->digits[0] = 10;
            if( !~E_math_Q_bignum_I_divide_modulo( num_div, num_mod ))
            {   E_math_Q_bignum_W( num_mod );
                E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            if( !E_mem_Q_blk_I_prepend( &s, 1 ))
            {   E_math_Q_bignum_W( num_mod );
                E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            *s = '0' + num_mod->digits[0];
            n_1++;
            E_math_Q_bignum_W( num_mod );
        }while( !( num_div->digits_n == 1
        && !num_div->digits[0]
        ));
        E_math_Q_bignum_W( num_div );
    }
    N n_2;
    if( -num->exponent > 0 )
    {   Pc p = E_mem_Q_blk_I_append( &s, 1 );
        if( !p )
        {   W(s);
            return 0;
        }
        *p = '.';
        n_2 = 1;
        num_div = E_math_Q_bignum_M_copy(num);
        if( !num_div )
        {   W(s);
            return 0;
        }
        if( !~E_math_Q_bignum_I_abs( num_div ))
        {   E_math_Q_bignum_W( num_div );
            W(s);
            return 0;
        }
        S i = (S)num_div->digits_n - -num->exponent;
        if( i > 0 )
        {   if( (S)num_div->digits[ -num->exponent + i - 2 ] < 0 )
                i--;
            if(i)
            {   if( !E_mem_Q_blk_I_remove( &num_div->digits, -num->exponent, i ))
                {   E_math_Q_bignum_W( num_div );
                    W(s);
                    return 0;
                }
                num_div->digits_n -= i;
            }
        }
        N start_zero_n = 0;
        O{  if( !~E_math_Q_bignum_I_multiply_n( num_div, 10 ))
            {   E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            if( num_div->digits_n > -num_div->exponent
            && num_div->digits[ num_div->digits_n - 1 ]
            )
                break;
            start_zero_n++;
        }
        if( start_zero_n )
        {   Pc p = E_mem_Q_blk_I_append( &s, start_zero_n );
            if( !p )
            {   W(s);
                return 0;
            }
            for_n_( i, start_zero_n )
                p[i] = '0';
            n_2 += start_zero_n;
        }
        O{  Pc p = E_mem_Q_blk_I_append( &s, 1 );
            if( !p )
            {   E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            *p = '0' + ( num_div->digits_n > -num_div->exponent ? num_div->digits[ num_div->digits_n - 1 ] : 0 );
            n_2++;
            if( num_div->digits_n > -num_div->exponent )
                if( num_div->digits_n > 1 )
                    if( (S)num_div->digits[ num_div->digits_n - 2 ] >= 0 )
                    {   if( !E_mem_Q_blk_I_remove( &num_div->digits, num_div->digits_n - 1, 1 ))
                        {   W(s);
                            return 0;
                        }
                        num_div->digits_n--;
                    }else
                        num_div->digits[ num_div->digits_n - 1 ] = 0;
                else
                    num_div->digits[ num_div->digits_n - 1 ] = 0;
            if( !~E_math_Q_bignum_I_multiply_n( num_div, 10 ))
            {   E_math_Q_bignum_W( num_div );
                W(s);
                return 0;
            }
            if( num_div->digits_n == 1
            && !num_div->exponent
            && !num_div->digits[0]
            )
                break;
        }
        E_math_Q_bignum_W( num_div );
    }else
        n_2 = 0;
    N n = n_1 + n_2;
    B dot_removed = no;
    if( -num->exponent > 0 )
    {   for_n_rev( i, n_2 - 1 )
        {   if( s[ n_1 + 1 + i ] != '0' )
                break;
        }
        if( i != n_2 - 2 )
        {   if( i == -1 )
            {   i--;
                dot_removed = yes;
            }
            i++;
            if( !E_mem_Q_blk_I_remove( &s, n_1 + 1 + i, n - ( n_1 + 1 + i )))
            {   W(s);
                return 0;
            }
            n -= n - ( n_1 + 1 + i );
        }
    }
    if( !( -num->exponent > 0 )
    || dot_removed
    )
    {   for_n_rev( i, n - 1 )
        {   if( s[ i + 1 ] != '0' )
                break;
        }
        if( i != n - 2 )
        {   i += 2;
            if( !E_mem_Q_blk_I_remove( &s, i, n - i ))
            {   W(s);
                return 0;
            }
            N exponent = n - i;
            n = i;
            Pc p = E_mem_Q_blk_I_append( &s, 1 );
            if( !p )
            {   W(s);
                return 0;
            }
            *p = 'e';
            n++;
            O{  p = E_mem_Q_blk_I_insert( &s, n, 1 );
                if( !p )
                {   W(s);
                    return 0;
                }
                *p = '0' + exponent % 10;
                exponent /= 10;
                if( !exponent )
                    break;
            }
        }
    }
    if( E_math_Q_bignum_R_sign(num) )
    {   if( !E_mem_Q_blk_I_prepend( &s, 1 ))
        {   W(s);
            return 0;
        }
        *s = '-';
    }
    Pc p = E_mem_Q_blk_I_append( &s, 1 );
    if( !p )
    {   W(s);
        return 0;
    }
    *p = '\0';
    return s;
}
struct E_math_Z_bignum *
E_math_Q_bignum_I_scan( Pc s
){  B sign = no;
    if( *s == '-' )
    {   sign = yes;
        s++;
    }
    if( !*s )
        return 0;
    B has_dot = no, has_e = no;
    S exponent_1 = 0, exponent_2 = 0;
    B exponent_2_sign = no;
    struct E_math_Z_bignum *num = E_math_Q_bignum_M();
    if( !num )
        return 0;
    struct E_math_Z_bignum *digit = E_math_Q_bignum_M();
    if( !num )
    {   E_math_Q_bignum_W(num);
        return 0;
    }
    do
    {   if( *s >= '0' && *s <= '9' )
        {   if( has_e )
            {   exponent_2 *= 10;
                exponent_2 += *s - '0';
            }else
            {   if( !~E_math_Q_bignum_I_multiply_n( num, 10 ))
                {   E_math_Q_bignum_W(digit);
                    E_math_Q_bignum_W(num);
                    return 0;
                }
                digit->digits[0] = *s - '0';
                if( !~E_math_Q_bignum_I_add( num, digit ))
                {   E_math_Q_bignum_W(digit);
                    E_math_Q_bignum_W(num);
                    return 0;
                }
                if( has_dot )
                    exponent_1--;
            }
        }else if( *s == '.' )
        {   if( has_dot || has_e )
            {   E_math_Q_bignum_W(digit);
                E_math_Q_bignum_W(num);
                return 0;
            }
            has_dot = yes;
        }else if( *s == 'e' )
        {   if( has_e )
            {   E_math_Q_bignum_W(digit);
                E_math_Q_bignum_W(num);
                return 0;
            }
            has_e = yes;
            if( *++s )
                if( *s == '-' )
                    exponent_2_sign = yes;
                else
                    s--;
            else
            {   E_math_Q_bignum_W(digit);
                E_math_Q_bignum_W(num);
                return 0;
            }
        }else
        {   E_math_Q_bignum_W(digit);
            E_math_Q_bignum_W(num);
            return 0;
        }
    }while( *++s );
    E_math_Q_bignum_W(digit);
    if( exponent_2_sign )
        exponent_2 = -exponent_2;
    S exponent = exponent_1 + exponent_2;
    if( exponent > 0 )
    {   struct E_math_Z_bignum *num_mod = E_math_Q_bignum_M();
        if( !num_mod )
        {   E_math_Q_bignum_W(num);
            return 0;
        }
        num_mod->digits[0] = 10;
        if( !~E_math_Q_bignum_I_power_n( num_mod, exponent ))
        {   E_math_Q_bignum_W(num);
            return 0;
        }
        if( !~E_math_Q_bignum_I_multiply( num, num_mod ))
        {   E_math_Q_bignum_W( num_mod );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_mod );
    }else if( exponent < 0 )
    {   N min_precision = ( -exponent + ( sizeof(N) * 5 / 4 )) / ( sizeof(N) * 5 / 2 ) + 1;
        struct E_math_Z_bignum *num_mod = E_math_Q_bignum_M();
        if( !num_mod )
        {   E_math_Q_bignum_W(num);
            return 0;
        }
        num_mod->digits[0] = 10;
        if( !~E_math_Q_bignum_I_power_n( num_mod, -exponent ))
        {   E_math_Q_bignum_W( num_mod );
            E_math_Q_bignum_W(num);
            return 0;
        }
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num, num_mod, min_precision ))
        {   E_math_Q_bignum_W( num_mod );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_mod );
    }
    if(sign)
        if( !~E_math_Q_bignum_I_negate(num) )
        {   E_math_Q_bignum_W(num);
            return 0;
        }
    return num;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_math_Q_bignum_I_power_n( struct E_math_Z_bignum *num
, N n
){  struct E_math_Z_bignum *num_ = E_math_Q_bignum_M_copy(num);
    if( !num_ )
        return ~0;
    num_->digits[0] = 1;
    while(n)
    {   if( n & 1 )
            if( !~E_math_Q_bignum_I_multiply( num_, num ))
            {   E_math_Q_bignum_W( num_ );
                return ~0;
            }
        if( !~E_math_Q_bignum_I_multiply( num, num ))
        {   E_math_Q_bignum_W( num_ );
            return ~0;
        }
        n >>= 1;
    }
    E_math_Q_bignum_M_move( num, num_ );
    W( num_ );
    return 0;
}
// Silnia.
N
E_math_Q_bignum_I_factorial( struct E_math_Z_bignum *num
)
{   J_assert( num->exponent >= 0 ); // liczba całkowita
    J_assert( !E_math_Q_bignum_R_sign(num) ); // liczba nieujemna
    J_assert( num->exponent || num->digits[0] ); // != 0
    struct E_math_Z_bignum *num_ = E_math_Q_bignum_M_copy(num);
    if( !num_ )
        return ~0;
    struct E_math_Z_bignum *num_one = E_math_Q_bignum_M();
    if( !num_one )
    {   E_math_Q_bignum_W( num_ );
        return ~0;
    }
    num_one->digits[0] = 1;
    while( num->exponent
    || num->digits_n != 1
    || num->digits[0] > 2
    )
    {   if( !~E_math_Q_bignum_I_subtract( num, num_one ))
        {   E_math_Q_bignum_W( num_one );
            E_math_Q_bignum_W( num_ );
            return ~0;
        }
        if( !~E_math_Q_bignum_I_multiply( num_, num ))
        {   E_math_Q_bignum_W( num_one );
            E_math_Q_bignum_W( num_ );
            return ~0;
        }
    }
    E_math_Q_bignum_W( num_one );
    E_math_Q_bignum_M_move( num, num_ );
    W( num_ );
    return 0;
}
struct E_math_Z_bignum *
E_math_Q_bignum_I_factorial_n( N n
){  struct E_math_Z_bignum *num = E_math_Q_bignum_M();
    if( !num )
        return 0;
    num->digits[0] = n;
    if( (S)n < 0 )
    {   if( !E_mem_Q_blk_I_append( &num->digits, 1 ))
        {   E_math_Q_bignum_W(num);
            return 0;
        }
        num->digits_n = 2;
        num->digits[1] = 0;
    }
    if( !~E_math_Q_bignum_I_factorial(num) )
    {   E_math_Q_bignum_W(num);
        return 0;
    }
    return num;
}
struct E_math_Z_bignum *
E_math_Q_bignum_I_pi( N digits_h
, N prec
){  J_assert( digits_h <= ( (N)~0 - 6 ) / 8 );
    struct E_math_Z_bignum *num = E_math_Q_bignum_M();
    if( !num )
        return 0;
    for_n( k, digits_h )
    {   struct E_math_Z_bignum *num_0 = E_math_Q_bignum_M();
        if( !num_0 )
        {   E_math_Q_bignum_W(num);
            return 0;
        }
        num_0->digits[0] = 4;
        struct E_math_Z_bignum *num_1 = E_math_Q_bignum_M();
        if( !num_1 )
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_1->digits[0] = 8 * k + 1;
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num_0, num_1, prec ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_1 );
        struct E_math_Z_bignum *num_ = num_0;
        num_0 = E_math_Q_bignum_M();
        if( !num_0 )
        {   E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_0->digits[0] = 2;
        num_1 = E_math_Q_bignum_M();
        if( !num_1 )
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_1->digits[0] = 8 * k + 4;
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num_0, num_1, prec ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_1 );
        if( !~E_math_Q_bignum_I_subtract( num_, num_0 ))
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_0 );
        num_0 = E_math_Q_bignum_M();
        if( !num_0 )
        {   E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_0->digits[0] = 1;
        num_1 = E_math_Q_bignum_M();
        if( !num_1 )
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_1->digits[0] = 8 * k + 5;
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num_0, num_1, prec ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_1 );
        if( !~E_math_Q_bignum_I_subtract( num_, num_0 ))
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_0 );
        num_0 = E_math_Q_bignum_M();
        if( !num_0 )
        {   E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_0->digits[0] = 1;
        num_1 = E_math_Q_bignum_M();
        if( !num_1 )
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        num_1->digits[0] = 8 * k + 6;
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num_0, num_1, prec ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_1 );
        if( !~E_math_Q_bignum_I_subtract( num_, num_0 ))
        {   E_math_Q_bignum_W( num_0 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_0 );
        num_1 = E_math_Q_bignum_M();
        num_1->digits[0] = 16;
        if( !~E_math_Q_bignum_I_power_n( num_1, k ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        if( !~E_math_Q_bignum_I_divide_modulo_min_prec( num_, num_1, prec ))
        {   E_math_Q_bignum_W( num_1 );
            E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_1 );
        if( !~E_math_Q_bignum_I_add( num, num_ ))
        {   E_math_Q_bignum_W( num_ );
            E_math_Q_bignum_W(num);
            return 0;
        }
        E_math_Q_bignum_W( num_ );
    }
    return num;
}
/******************************************************************************/
