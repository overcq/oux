/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   base
*         storage memory
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”              2016‒2‒5 U
*******************************************************************************/
//obsługę plików zrobić jako obiekt pamięci implementujący niegdyś wymyślone pojęcie dostępu do bloków pamięci masowej bez obecności tzw. “wymiatania na dysk”. teraz byłby to raczej obiekt pamięci operacyjnej do umieszczania w nim danych zachowywanych w postaci integralnej pomiędzy ‘wywaleniami’ programu. czyli bazować na automatycznych mechanizmach systemu operacyjnego zapisujących zawartość pamięci do wcześniej gwarantowanego miejsca na dysku— dopiero w momencie konieczności, np. ‘wywalenia’ programu.
//trzeba podjąć decyzje strukturalne co do sposobu bezpośredniego indeksowania bloków, bloku bieżącego— w przepływie wykonania funkcji ‹modułu›.
//odczyt dostępnego bloku pamięci do podanej wielkości rozmiaru.
//==============================================================================
struct E_mem_Q_rel_map_blk_Z
{ N pos;
  N l;
  Pc data;
};
struct E_mem_Z_range
{ N pos;
  N pos_end;
};
struct E_mem_Q_file_Z
{ struct E_mem_Q_rel_map_blk_Z *blk; ///tablica bloków danych wczytanych uporządkowana wg pozycji danych w pliku.
  N blk_n;
  struct E_mem_Z_range *unsaved; ///tablica zakresów danych nie zapisanych uporządkowana wg pozycji danych w pliku.
  N unsaved_n;
  N pos;
  N current_blk;
  N current_blk_pos;
  int fd;
  unsigned U_R( current_blk, valid )    :1;
  unsigned U_R( current_blk, valid_sob ):1;
  unsigned U_R( current_blk, valid_eob ):1;
};
//==============================================================================
I
E_mem_Q_file_M( Pc path
){  int fd;
        #ifdef __gnu_linux__
    VO1( fd = open( path, O_RDWR | O_DIRECT ))
        #else
    VO1( fd = open( path, O_RDWR ))
        #endif
        return ~0;
    I id = E_mem_Q_tab_I_add( E_base_S->E_mem_Q_file_S );
    struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    Mt_( file->blk, file->blk_n = 0 );
    Mt_( file->unsaved, file->unsaved_n = 0 );
    file->pos = 0;
    file->fd = fd;
    U_L( file->current_blk, valid );
    U_L( file->current_blk, valid_sob );
    U_L( file->current_blk, valid_eob );
    return id;
}
void
E_mem_Q_file_W( I id
){  struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    struct E_mem_Z_range *range = file->unsaved;
    for_n( i, file->unsaved_n )
    {   N data_pos = E_simple_Z_n_I_align_down_to_v_2( range->pos, E_base_S->E_mem_Q_file_S_buffer_l );
        N buf_pos = 0;
        N blk_i;
        for( blk_i = 0; blk_i != file->blk_n; blk_i++ )
            if( range->pos < file->blk[ blk_i ].pos )
                break;
        N data_pos_end;
        if( data_pos != range->pos )
        {   N data_l = E_mem_Q_file_I_read_pos( file->fd, data_pos );
            while( buf_pos < data_l
            && blk_i != file->blk_n
            ){  N l;
                E_mem_Q_blk_I_copy( E_base_S->E_mem_Q_file_S_buffer + buf_pos
                , file->blk[ blk_i ].data
                , l = file->blk[ blk_i ].l > data_l - buf_pos ? data_l - buf_pos : file->blk[ blk_i ].l
                );
                buf_pos += l;
                blk_i++;
            }
            E_mem_Q_file_I_write_pos( file->fd, data_pos );
            data_pos_end = data_l == E_base_S->E_mem_Q_file_S_buffer_l
            ? E_simple_Z_n_I_align_up_to_v_2( range->pos, E_base_S->E_mem_Q_file_S_buffer_l )
            : data_pos + data_l;
        }else
            data_pos_end = E_simple_Z_n_I_align_up_to_v_2( range->pos, E_base_S->E_mem_Q_file_S_buffer_l );
        buf_pos = 0;
        if( data_pos_end < range->pos_end )
        {   N l;
            while( data_pos_end < range->pos_end )
            {   buf_pos += E_base_S->E_mem_Q_file_S_buffer_l;
                E_mem_Q_blk_I_copy( E_base_S->E_mem_Q_file_S_buffer
                , file->blk[ blk_i ].data + buf_pos
                , l = file->blk[ blk_i ].l - buf_pos > E_base_S->E_mem_Q_file_S_buffer_l ? E_base_S->E_mem_Q_file_S_buffer_l : file->blk[ blk_i ].l
                );
                if( l < E_base_S->E_mem_Q_file_S_buffer_l )
                    E_mem_Q_file_I_read_pos( file->fd, data_pos_end );
                E_mem_Q_file_I_write_pos( file->fd, data_pos_end );
                data_pos_end += E_base_S->E_mem_Q_file_S_buffer_l;
            }
            data_pos_end -= E_base_S->E_mem_Q_file_S_buffer_l - l;
        }
        range++;
        while( i != file->unsaved_n
        && range->pos < data_pos_end
        ){  i++;
            range++;
        }
    }
    W( file->unsaved );
    struct E_mem_Q_rel_map_blk_Z *blk = file->blk;
    for_n_( i, file->blk_n )
    {   W( blk->data );
        blk++;
    }
    W( file->blk );
    V0( close( file->fd )){} //NDFN co robić, gdy się nie powiedzie?
    E_mem_Q_tab_I_rem( E_base_S->E_mem_Q_file_S, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
N
E_mem_Q_file_I_write_pos( int fd
, N pos
){  V1( lseek( fd, pos, SEEK_SET ))
        return ~0;
        #ifdef __gnu_linux__
    N l;
    VO1( l = write( fd, E_base_S->E_mem_Q_file_S_buffer, E_base_S->E_mem_Q_file_S_buffer_l )){}
        #else
    N l = 0;
    N l_;
    O{  VO1( l_ = write( fd, E_base_S->E_mem_Q_file_S_buffer + l, E_base_S->E_mem_Q_file_S_buffer_l - l )){}
        if( !l_
        || !~l_
        )
            break;
        l += l_;
        if( l == E_base_S->E_mem_Q_file_S_buffer_l )
            break;
    }
        #endif
    return l;
}
_internal
N
E_mem_Q_file_I_read_pos( int fd
, N pos
){  V1( lseek( fd, pos, SEEK_SET ))
        return ~0;
        #ifdef __gnu_linux__
    N l;
    VO1( l = read( fd, E_base_S->E_mem_Q_file_S_buffer, E_base_S->E_mem_Q_file_S_buffer_l )){}
        #else
    N l = 0;
    N l_;
    O{  VO1( l_ = read( fd, E_base_S->E_mem_Q_file_S_buffer + l, E_base_S->E_mem_Q_file_S_buffer_l - l )){}
        if( !l_
        || !~l_
        )
            break;
        l += l_;
        if( l == E_base_S->E_mem_Q_file_S_buffer_l )
            break;
    }
        #endif
    return l;
}
_internal
N
E_mem_Q_file_R_current_blk( struct E_mem_Q_file_Z *file
){  if( U_R( file->current_blk, valid ))
        return 0;
    N l;
    N pos;
    struct E_mem_Q_rel_map_blk_Z *blk;
    N blk_i;
    if( file->blk_n )
    {   ///czy pozycja w pliku znajduje się w już obecnym bloku danych wczytanych.
        if( U_E( file->current_blk, valid_sob ))
        {   blk_i = file->current_blk;
            if( blk_i )
                pos = blk[ blk_i - 1 ].pos;
            else
                pos = 0;
        }
        else if( U_E( file->current_blk, valid_eob ))
        {   blk_i = file->current_blk + 1;
            pos = blk[ blk_i ].pos;
        }
        else
        {   blk_i = 0;
            pos = 0;
        }
        for( blk = file->blk + blk_i; blk_i != file->blk_n; blk_i++, blk++ )
        {   if( file->pos < blk->pos )
                break;
            pos = blk->pos;
            if( file->pos < pos + blk->l )
            {   file->current_blk = blk_i;
                file->current_blk_pos = file->pos - pos;
                l = 0;
                goto End;
            }
        }
    }
    N data_pos = E_simple_Z_n_I_align_down_to_v_2( file->pos, E_base_S->E_mem_Q_file_S_buffer_l );
    l = E_mem_Q_file_I_read_pos( file->fd, data_pos );
    if( !~l )
        return l;
    if( l <= file->pos - data_pos )
        return E_mem_Q_file_S_eof;
    N data_pos_end = data_pos + l;
    if( file->blk_n )
    {   ///scalenie bloków danych wczytanych zawartych w bloku odczytanym z pliku.
        struct E_mem_Q_rel_map_blk_Z *blk_begin;
        N pos_begin;
        if( blk_i )
        {   blk_begin = blk - 1;
            pos_begin = pos;
            O{  if( data_pos >= pos_begin )
                {   if( data_pos > pos_begin + blk_begin->l )
                    {   blk_begin++;
                        pos_begin = blk_begin->pos;
                    }
                    break;
                }
                if( blk_begin == file->blk )
                    break;
                blk_begin--;
                pos_begin = blk_begin->pos;
            }
        }else
        {   blk_begin = blk;
            pos_begin = blk_begin->pos;
        }
        struct E_mem_Q_rel_map_blk_Z *blk_end;
        N pos_end = pos;
        if( blk_i != file->blk_n )
        {   blk_end = blk;
            O{  if( data_pos_end < blk_end->pos )
                {   blk_end--;
                    break;
                }
                pos_end = blk_end->pos;
                if( data_pos_end < pos_end + blk_end->l )
                    break;
                if( blk_end + 1 == file->blk + file->blk_n )
                    break;
                blk_end++;
            }
        }else
            blk_end = blk - 1;
        if( blk_begin <= blk_end ) //NDFN ‘wrap around’ przy krańcowości tablicy.
        {   struct E_mem_Q_rel_map_blk_Z new_blk;
            N pos;
            if( data_pos < pos_begin )
            {   new_blk.pos = blk_begin->pos - ( pos_begin - data_pos );
                pos = pos_begin - data_pos;
                pos_begin = data_pos;
            }else
            {   new_blk.pos = blk_begin->pos;
                pos = 0;
            }
            new_blk.data = M( new_blk.l = ( data_pos_end <= pos_end + blk_end->l ? pos_end + blk_end->l : data_pos_end ) - pos_begin ); //TODO użyć funkcji “append”/“prepend”.
            E_mem_Q_blk_I_copy( new_blk.data + ( data_pos - pos_begin ), E_base_S->E_mem_Q_file_S_buffer, l );
            struct E_mem_Q_rel_map_blk_Z *blk = blk_begin;
            O{  E_mem_Q_blk_I_copy( new_blk.data + pos, blk->data, blk->l );
                if( blk == blk_end )
                    break;
                blk++;
                pos = blk->pos - ( data_pos < pos_begin ? data_pos : pos_begin );
            }
            N i = ( blk_begin - file->blk ) / sizeof( struct E_mem_Q_rel_map_blk_Z );
            N n = ( blk_end - blk_begin ) / sizeof( struct E_mem_Q_rel_map_blk_Z );
            if(n)
                E_mem_Q_blk_I_rem( &file->blk, i + 1, n );
            file->blk[i] = new_blk;
            file->current_blk = i;
            file->current_blk_pos = file->pos - pos_begin;
        }else
        {   file->current_blk = ( blk_begin - file->blk ) / sizeof( struct E_mem_Q_rel_map_blk_Z );
            file->current_blk_pos = file->pos - data_pos;
            struct E_mem_Q_rel_map_blk_Z *new_blk = E_mem_Q_blk_I_insert( &file->blk, file->current_blk, 1 );
            if( !new_blk )
                return ~0;
            new_blk->pos = data_pos;
            new_blk->data = M( new_blk->l = l );
            E_mem_Q_blk_I_copy( new_blk->data, E_base_S->E_mem_Q_file_S_buffer, l );
        }
    }else
    {   file->current_blk = 0;
        file->current_blk_pos = file->pos - data_pos;
        struct E_mem_Q_rel_map_blk_Z *new_blk = E_mem_Q_blk_I_append( &file->blk, file->blk_n = 1 );
        if( !new_blk )
            return ~0;
        new_blk->pos = data_pos;
        new_blk->data = M( new_blk->l = l );
        E_mem_Q_blk_I_copy( new_blk->data, E_base_S->E_mem_Q_file_S_buffer, l );
    }
End:U_F( file->current_blk, valid );
    return l;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_mem_Q_file_P_pos( I id
, N pos
){  struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    file->pos = pos;
    if( file->blk_n )
    {   if( file->pos < file->blk[0].pos )
        {   U_L( file->current_blk, valid );
            if( file->pos == file->blk[0].pos - 1 )
                U_F( file->current_blk, valid_sob );
            else
                U_L( file->current_blk, valid_sob );
            U_L( file->current_blk, valid_eob );
            return;
        }
        N blk_i;
        for( blk_i = 1; blk_i != file->blk_n; blk_i++ )
            if( file->pos < file->blk[ blk_i ].pos )
                break;
        if( blk_i-- != file->blk_n )
        {   if( file->pos < file->blk[ blk_i ].pos + file->blk[ blk_i ].l )
            {   U_F( file->current_blk, valid );
                U_L( file->current_blk, valid_sob );
                U_L( file->current_blk, valid_eob );
            }else if( file->pos == file->blk[ blk_i ].pos + file->blk[ blk_i ].l )
            {   U_L( file->current_blk, valid );
                U_L( file->current_blk, valid_sob );
                U_F( file->current_blk, valid_eob );
            }else if( file->pos == file->blk[ blk_i + 1 ].pos - 1 )
            {   U_L( file->current_blk, valid );
                U_F( file->current_blk, valid_sob );
                U_L( file->current_blk, valid_eob );
            }else
            {   U_L( file->current_blk, valid );
                U_L( file->current_blk, valid_sob );
                U_L( file->current_blk, valid_eob );
            }
        }else if( file->pos >= file->blk[ blk_i ].pos
        && file->pos < file->blk[ blk_i ].pos + file->blk[ blk_i ].l
        )
        {   U_F( file->current_blk, valid );
            U_L( file->current_blk, valid_sob );
            U_L( file->current_blk, valid_eob );
        }else if( file->pos == file->blk[ blk_i ].pos + file->blk[ blk_i ].l )
        {   U_L( file->current_blk, valid );
            U_L( file->current_blk, valid_sob );
            U_F( file->current_blk, valid_eob );
        }
    }else
    {   U_L( file->current_blk, valid );
        U_L( file->current_blk, valid_sob );
        U_L( file->current_blk, valid_eob );
    }
}
N
E_mem_Q_file_R_c( I id
){  struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    N ret = E_mem_Q_file_R_current_blk(file);
    if( !~ret
    || ret == E_mem_Q_file_S_eof
    )
        return ret;
    char c = file->blk[ file->current_blk ].data[ file->current_blk_pos++ ];
    file->pos++;
    if( file->current_blk_pos == file->blk[ file->current_blk ].l )
    {   U_L( file->current_blk, valid );
        U_F( file->current_blk, valid_eob );
    }
    return c;
}
N
E_mem_Q_file_R_rev_c( I id
){  struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    N ret = E_mem_Q_file_R_current_blk(file);
    if( !~ret
    || ret == E_mem_Q_file_S_eof
    )
        return ret;
    char c = file->blk[ file->current_blk ].data[ file->current_blk_pos-- ];
    file->pos--;
    if( file->current_blk_pos == -1 )
    {   U_L( file->current_blk, valid );
        U_F( file->current_blk, valid_sob );
    }
    return c;
}
void
E_mem_Q_file_P_c( I id
, C c
){  struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, id );
    ///czy da się skleić zakresy danych nie zapisanych.
    B f = no;
    for_n( unsaved_i, file->unsaved_n )
    {   if( file->pos == file->unsaved[ unsaved_i ].pos - 1 )
        {   f = yes;
            if( unsaved_i
            && file->unsaved[ unsaved_i - 1 ].pos_end == file->unsaved[ unsaved_i ].pos - 1
            ){  file->unsaved[ unsaved_i - 1 ].pos_end = file->unsaved[ unsaved_i ].pos_end;
                E_mem_Q_blk_I_rem( &file->unsaved, unsaved_i, 1 );
            }else
                file->unsaved[ unsaved_i ].pos--;
            break;
        }
        if( file->pos < file->unsaved[ unsaved_i ].pos )
            break;
        if( file->pos >= file->unsaved[ unsaved_i ].pos
        && file->pos < file->unsaved[ unsaved_i ].pos_end
        )
        {   f = yes;
            break;
        }
        if( file->pos == file->unsaved[ unsaved_i ].pos_end )
        {   f = yes;
            if( unsaved_i + 1 != file->unsaved_n
            && file->unsaved[ unsaved_i + 1 ].pos == file->unsaved[ unsaved_i ].pos_end + 1
            ){  file->unsaved[ unsaved_i ].pos_end = file->unsaved[ unsaved_i + 1 ].pos_end;
                E_mem_Q_blk_I_rem( &file->unsaved, unsaved_i + 1, 1 );
            }else
                file->unsaved[ unsaved_i ].pos_end++;
            break;
        }
    }
    if( !f )
    {   E_mem_Q_blk_I_insert( &file->unsaved, unsaved_i, 1 );
        file->unsaved[ unsaved_i ].pos = file->pos;
        file->unsaved[ unsaved_i ].pos_end = file->pos + 1;
    }
    ///ustawienie nowej pozycji w pliku.
    if( U_R( file->current_blk, valid ))
    {   if( file->current_blk_pos + 1 == file->blk[ file->current_blk ].l )
        {   U_L( file->current_blk, valid );
            U_F( file->current_blk, valid_eob );
        }
    }else if( U_R( file->current_blk, valid_eob ))
    {   if( file->current_blk != file->blk_n
        && file->blk[ file->current_blk + 1 ].pos - ( file->blk[ file->current_blk ].pos + file->blk[ file->current_blk ].l ) == 1
        )
        {   E_mem_Q_blk_I_append( &file->blk[ file->current_blk ].data, 1 + file->blk[ file->current_blk + 1 ].l );
            E_mem_Q_blk_I_copy( file->blk[ file->current_blk ].data + 1, file->blk[ file->current_blk + 1 ].data, file->blk[ file->current_blk + 1 ].l );
            W( file->blk[ file->current_blk + 1 ].data );
            E_mem_Q_blk_I_rem( &file->blk, file->current_blk + 1, 1 );
            U_F( file->current_blk, valid );
            U_L( file->current_blk, valid_eob );
        }else
        {   E_mem_Q_blk_I_append( &file->blk[ file->current_blk ].data, 1 );
            file->blk[ file->current_blk ].l++;
        }
    }else if( U_R( file->current_blk, valid_sob ))
    {   if( file->current_blk
        && file->blk[ file->current_blk ].pos - ( file->blk[ file->current_blk - 1 ].pos + file->blk[ file->current_blk - 1 ].l ) == 1
        )
        {   file->current_blk--;
            file->current_blk_pos = file->blk[ file->current_blk ].l;
            file->blk[ file->current_blk ].l += 1 + file->blk[ file->current_blk + 1 ].l;
            E_mem_Q_blk_I_append( &file->blk[ file->current_blk ].data, 1 + file->blk[ file->current_blk + 1 ].l );
            E_mem_Q_blk_I_copy( file->blk[ file->current_blk ].data + 1, file->blk[ file->current_blk + 1 ].data, file->blk[ file->current_blk + 1 ].l );
            W( file->blk[ file->current_blk + 1 ].data );
            E_mem_Q_blk_I_rem( &file->blk, file->current_blk + 1, 1 );
            U_F( file->current_blk, valid );
        }else
        {   E_mem_Q_blk_I_prepend( &file->blk[ file->current_blk ].data, 1 );
            file->blk[ file->current_blk ].l++;
            if( file->current_blk_pos + 1 == file->blk[ file->current_blk ].l )
                U_F( file->current_blk, valid_eob );
            else
                U_F( file->current_blk, valid );
        }
        U_L( file->current_blk, valid_sob );
    }else
    {   N blk_i = 0;
        N pos;
        for( pos = 0; blk_i != file->blk_n; blk_i++ )
            if( file->pos < file->blk[ blk_i ].pos )
                break;
        if( blk_i != file->blk_n )
            E_mem_Q_blk_I_insert( &file->blk, blk_i, 1 );
        else
            E_mem_Q_blk_I_append( &file->blk, 1 );
        file->blk_n++;
        file->current_blk = blk_i;
        file->blk[ file->current_blk ].data = M( file->blk[ file->current_blk ].l = 1 );
        file->blk[ file->current_blk ].pos = file->pos;
    }
    file->pos++;
    file->blk[ file->current_blk ].data[ file->current_blk_pos++ ] = c;
}
/******************************************************************************/
