//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   base
*         memory tables
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
// Menedżer tablic danych obiektów tworzonych, niekolejkowanych, indeksowanych w pamięci operacyjnej.
//------------------------------------------------------------------------------
// W szczególności 〃 obiektów wykonywania programów.
// Dane:
// • stałego rozmiaru (np. struktura w języku C)
// • zawsze w pamięci operacyjnej
// • z szybkim dostępem przez identyfikator
// • ze statycznymi ‘iteratorami’ ‛dla każdego’
// • z aktualizowanymi ‘iteratorami’ ‛dla każdego’ (które powinny być wyliczane bez oczekiwania na ‹raporcie›, by ‹zadanie› oddawało nieużywaną pamięć operacyjną, ale nie muszą)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Ze względu na powstające już tablice wielowymiarowe wydawanie wskaźnika do “struct E_mem_Q_tab_Z” zostanie zmienione na wydawanie identyfikatora (do zmiennej globalnej tablic tego ‹menedżera›).
// Dodatkowe ‘iteratory’ statyczne uwzględniające zwalnianie elementów kolekcji możliwe do zrobienia, ale potrzebują bardziej wymagającego sprawdzania warunków.
//==============================================================================
struct E_mem_Q_tab_Z
{ Pc *index; // Tablica mapowania indeksów do adresów w “data”.
  Pc data; // Dane ciągłe.
  N u; // Rozmiar elementu tablicy.
  struct E_mem_Q_tab_Z *iterator;
  I index_n;
  I data_n;
};
struct E_mem_Q_tab_S_iterator_Z
{ I *index; // Dowolna sekwencja ‹identyfikatorów› (indeksów) danych, ale bez powtórzeń.
  I n;
};
//==============================================================================
_export
struct E_mem_Q_tab_Z *
E_mem_Q_tab_M(
  N u
, I n
){  struct E_mem_Q_tab_Z *tab_ = E_mem_Q_blk_M( sizeof( struct E_mem_Q_tab_Z ));
    if( !tab_ )
        return 0;
    Mt_( tab_->index, n );
    if( !tab_->index )
    {   if( W( tab_ ))
            return (P)~1;
        return 0;
    }
    tab_->data = Mt( u, n );
    if( !tab_->data )
    {   if( W( tab_->index )
        || W( tab_ )
        )
            return (P)~1;
        return 0;
    }
    tab_->index_n = n;
    tab_->data_n = n;
    tab_->u = u;
    for_i( i, n )
        tab_->index[i] = tab_->data + i * tab_->u;
    tab_->iterator = 0;
    return tab_;
}
_export
N
E_mem_Q_tab_W( struct E_mem_Q_tab_Z *tab_
){  if( U_R( E_base_S->E_flow_S_signal, exit_all ))
        return 0;
    if( tab_->iterator )
    {   for_each( i, tab_->iterator, E_mem_Q_tab )
        {   struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[i];
            if( W( iterator->index ))
                return ~1;
        }
        if( W( tab_->iterator->data )
        || W( tab_->iterator->index )
        || W( tab_->iterator )
        )
            return ~1;
    }
    if( W( tab_->data )
    || W( tab_->index )
    || W( tab_ )
    )
        return ~1;
    return 0;
}
//------------------------------------------------------------------------------
_export
I
E_mem_Q_tab_I_add( struct E_mem_Q_tab_Z *tab_
){  for_i( id, tab_->index_n )
        if( !tab_->index[id] )
            break;
    Pc data = tab_->data;
    N n_prepended;
    if( !E_mem_Q_blk_I_add( &tab_->data, 1, &n_prepended, 0 ))
        return ~0;
    tab_->data_n++;
    if( tab_->data != data )
    {   for_i( i, id )
            tab_->index[i] += tab_->data + ( n_prepended ? tab_->u : 0 ) - data;
        if( i != tab_->index_n )
            while( ++i != tab_->index_n )
                if( tab_->index[i] )
                    tab_->index[i] += tab_->data + ( n_prepended ? tab_->u : 0 ) - data;
    }
    if( id == tab_->index_n )
    {   if( !E_mem_Q_blk_I_append( &tab_->index, 1 ))
        {   if( !E_mem_Q_blk_I_remove( &tab_->data, n_prepended ? 0 : tab_->data_n - 1, 1 ))
                return ~2;
            return ~0;
        }
        tab_->index_n++;
    }
    tab_->index[id] = tab_->data + ( n_prepended ? 0 : ( tab_->data_n - 1 ) * tab_->u );
    if( tab_->iterator )
    {   for_i( i, tab_->iterator->index_n )
        {   struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[i];
            if(iterator)
            {   I *p = E_mem_Q_blk_I_append( &iterator->index, 1 );
                if( !p )
                    return ~2;
                *p = id;
                iterator->n++;
            }
        }
    }
    return id;
}
_export
N
E_mem_Q_tab_I_add_i( struct E_mem_Q_tab_Z *tab_
, I id
){  J_assert( ~id && !E_mem_Q_tab_T( tab_, id ));
    Pc data = tab_->data;
    N n_prepended;
    if( !E_mem_Q_blk_I_add( &tab_->data, 1, &n_prepended, 0 ))
        return ~0;
    tab_->data_n++;
    if( tab_->data != data )
    {   if( id < tab_->index_n )
        {   for_i( i, id )
                if( tab_->index[i] )
                    tab_->index[i] += tab_->data + ( n_prepended ? tab_->u : 0 ) - data;
            if( i != tab_->index_n )
                while( ++i != tab_->index_n )
                    if( tab_->index[i] )
                        tab_->index[i] += tab_->data + ( n_prepended ? tab_->u : 0 ) - data;
        }else
        {   for_i( i, tab_->index_n )
                if( tab_->index[i] )
                    tab_->index[i] += tab_->data + ( n_prepended ? tab_->u : 0 ) - data;
        }
    }
    if( id >= tab_->index_n )
    {   if( !E_mem_Q_blk_I_append( &tab_->index, id + 1 - tab_->index_n ))
        {   if( !E_mem_Q_blk_I_remove( &tab_->data, n_prepended ? 0 : tab_->data_n - 1, id + 1 - tab_->index_n ))
                return ~2;
            return ~0;
        }
        for( I i = tab_->index_n; (In)i < (In)id; i++ )
            tab_->index[i] = 0;
        tab_->index_n = id + 1;
    }
    tab_->index[id] = tab_->data + ( n_prepended ? 0 : ( tab_->data_n - 1 ) * tab_->u );
    if( tab_->iterator )
    {   for_i( i, tab_->iterator->index_n )
        {   struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[i];
            if(iterator)
            {   I *p = E_mem_Q_blk_I_append( &iterator->index, 1 );
                if( !p )
                    return ~2;
                *p = id;
                iterator->n++;
            }
        }
    }
    return 0;
}
_export
N
E_mem_Q_tab_I_remove( struct E_mem_Q_tab_Z *tab_
, I id
){  J_assert( E_mem_Q_tab_T( tab_, id ));
    if( tab_->iterator )
    {   for_i( i, tab_->iterator->index_n )
            if( tab_->iterator->index[i] )
            {   struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[i];
                for_i( j, iterator->n )
                    if( iterator->index[j] == id )
                    {   if( !E_mem_Q_blk_I_remove( &iterator->index, j, 1 ))
                            return ~2;
                        iterator->n--;
                        break;
                    }
            }
    }
    Pc p = tab_->index[id];
    if( id == tab_->index_n - 1 )
    {   I i = id;
        while(i)
            if( tab_->index[ --i ])
            {   i++;
                break;
            }
        if( E_mem_Q_blk_I_remove( &tab_->index, i, id - i + 1 ))
            tab_->index_n = i;
        else
            tab_->index[id] = 0;
    }else
        tab_->index[id] = 0;
    Pc data = tab_->data;
    if( !E_mem_Q_blk_I_remove( &tab_->data, ( p - data ) / tab_->u, 1 ))
        return ~2;
    tab_->data_n--;
    if( tab_->data != data )
    {   for_i( i, tab_->index_n )
            if( tab_->index[i] )
            {   if( tab_->index[i] > p )
                    tab_->index[i] -= tab_->u;
                tab_->index[i] += tab_->data - data;
            }
    }else
    {   for_i( i, tab_->index_n )
            if( tab_->index[i] > p )
                tab_->index[i] -= tab_->u;
    }
    return 0;
}
#if 0
_export
N
E_mem_Q_tab_I_copy( //NDFN kolejność do odwrócenia.
  struct E_mem_Q_tab_Z *tab_src
, I src_id
, struct E_mem_Q_tab_Z *tab_dest
){  I dest_id = E_mem_Q_tab_I_add( tab_dest );
    E_mem_Q_blk_P_copy( tab_dest->index[ dest_id ], tab_src->index[ src_id ], tab_src->u );
    return dest_id;
}
_export
N
E_mem_Q_tab_I_move(
  struct E_mem_Q_tab_Z *tab_src
, I src_id
, struct E_mem_Q_tab_Z *tab_dest
){  I dest_id = E_mem_Q_tab_I_copy( tab_src, src_id, tab_dest );
    E_mem_Q_tab_I_remove( tab_src, src_id );
    return dest_id;
}
#endif
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Iteratory statyczne. Gdy wiadomo, że nie nastąpi przełączenie ‹zadania›, ponieważ wyliczenie wartości musi być wykonane w jednym ‹atomie›, i nie nastąpi zmiana kolekcji.
_export
I
E_mem_Q_tab_Z_iter_R_next( struct E_mem_Q_tab_Z *tab_
, I id
, I out_id // Pomijany— i od następnego do poprzedniego elementu.
){  if( (In)id + 1 > (In)out_id )
    {   while( ++id != tab_->index_n )
            if( tab_->index[id] )
                return id;
        id = ~0;
    }
    if( !~out_id )
        out_id = tab_->index_n;
    while( ++id != out_id )
        if( tab_->index[id] )
            return id;
    return ~0;
}
_export
I
E_mem_Q_tab_Z_iter_R_prev( struct E_mem_Q_tab_Z *tab_
, I id
, I out_id
){  if( !~id )
        id = tab_->index_n;
    if( (In)id - 1 < (In)out_id )
    {   while( ~--id )
            if( tab_->index[id] )
                return id;
        if( !~out_id )
            return ~0;
        id = tab_->index_n;
    }
    while( --id != out_id )
        if( tab_->index[id] )
            return id;
    return ~0;
}
//------------------------------------------------------------------------------
_export
I
E_mem_Q_tab_Q_iter_M( struct E_mem_Q_tab_Z *tab_
, I out_id
){  I n = tab_->data_n;
    if( ~out_id
    && n
    )
        n--;
    I iterator_id;
    P tab_iterator = tab_->iterator;
    if( tab_iterator )
    {   iterator_id = E_mem_Q_tab_I_add( tab_->iterator );
        if( (S)iterator_id < 0 )
            return iterator_id;
    }else
    {   P r = E_mem_Q_tab_M( sizeof( struct E_mem_Q_tab_S_iterator_Z ), 1 );
        if( !r )
            return ~0;
        if( (S)r < 0 )
            return (S)r;
        tab_->iterator = r;
        iterator_id = 0;
    }
    struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[ iterator_id ];
    Mt_( iterator->index, n );
    if( !iterator->index )
    {   N r;
        if( tab_iterator )
            r = E_mem_Q_tab_I_remove( tab_->iterator, iterator_id );
        else
        {   r = E_mem_Q_tab_W( tab_->iterator );
            if( !r )
                tab_->iterator = 0;
        }
        return r;
    }
    iterator->n = n;
    I i = 0;
    I id;
    for( id = out_id + 1; id != tab_->index_n; id++ )
        if( tab_->index[id] )
            iterator->index[ i++ ] = id;
    if( ~out_id )
    {   for_i_( id, out_id )
            if( tab_->index[id] )
                iterator->index[ i++ ] = id;
    }
    return iterator_id;
}
// Do zwalniania ‘iteratora’ tylko wtedy, gdy nie zakończy się wartością “empty” (czyli gdy pętla zostanie przerwana).
_export
N
E_mem_Q_tab_Q_iter_W( struct E_mem_Q_tab_Z *tab_
, I iterator_id
){  struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[ iterator_id ];
    if( W( iterator->index ))
        return ~0;
    N r;
    if( tab_->iterator->data_n != 1 )
        r = E_mem_Q_tab_I_remove( tab_->iterator, iterator_id );
    else
    {   r = E_mem_Q_tab_W( tab_->iterator );
        if( !r )
            tab_->iterator = 0;
    }
    return r ? ~2 : 0;
}
    #if 0 //Brak koncepcji pętli usuwających.
_export
I
E_mem_Q_tab_Q_iter_R_shift( struct E_mem_Q_tab_Z *tab_
, I iterator_id
){  struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[ iterator_id ];
    if( !iterator->n )
    {   N r = E_mem_Q_tab_Q_iter_W( tab_, iterator_id );
        return r ? r : ~0;
    }
    I id = iterator->index[0];
    if( !E_mem_Q_blk_I_remove( &iterator->index, 0, 1 ))
        return ~1;
    iterator->n--;
    return id;
}
    #endif
_export
I
E_mem_Q_tab_Q_iter_R_next( struct E_mem_Q_tab_Z *tab_
, I iterator_id
, I id
){  struct E_mem_Q_tab_S_iterator_Z *iterator = (P)tab_->iterator->index[ iterator_id ];
    I r = (In)id < (In)iterator->n ? iterator->index[id] : ~0;
    if( !~r )
    {   if( W( iterator->index ))
            return ~2;
        N r;
        if( tab_->iterator->data_n != 1 )
            r = E_mem_Q_tab_I_remove( tab_->iterator, iterator_id );
        else
        {   r = E_mem_Q_tab_W( tab_->iterator );
            if( !r )
                tab_->iterator = 0;
        }
        if(r)
            return ~2;
    }
    return r;
}
/******************************************************************************/
