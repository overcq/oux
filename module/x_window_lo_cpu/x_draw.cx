/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   ‟X window” —low ‘cpu’
*         window drawing
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
enum E_x_Z_aa_pixel
{ Z_aa_pixel_S_e = 1 << 0,
  Z_aa_pixel_S_se = 1 << 1,
  Z_aa_pixel_S_s = 1 << 2,
  Z_aa_pixel_S_sw = 1 << 3,
  Z_aa_pixel_S_w = 1 << 4,
  Z_aa_pixel_S_nw = 1 << 5,
  Z_aa_pixel_S_n = 1 << 6,
  Z_aa_pixel_S_ne = 1 << 7
};
//==============================================================================
N32
E_x_Z_color_M(
  N8 red
, N8 green
, N8 blue
){  return ( red << 16 ) | ( green << 8 ) | blue;
}
N8
E_x_Z_color_R_red( N32 color
){  return ( color >> 16 ) & 0xff;
}
N8
E_x_Z_color_R_green( N32 color
){  return ( color >> 8 ) & 0xff;
}
N8
E_x_Z_color_R_blue( N32 color
){  return color & 0xff;
}
N32
E_x_Z_color_M_gray(
  N8 luminance
){  return E_x_Z_color_M( luminance, luminance, luminance );
}
N32
E_x_Z_color_P_luminance( struct E_x_Q_display_Z *display
, N32 color
, F luminance
){  N8 red = E_x_Z_color_R_red(color);
    N8 green = E_x_Z_color_R_green(color);
    N8 blue = E_x_Z_color_R_blue(color);
    F color_luminance = E_x_Z_color_R_luminance( display, color );
    if( luminance < color_luminance )
    {   red = round( red * luminance / color_luminance );
        green = round( green * luminance / color_luminance );
        blue = round( blue * luminance / color_luminance );
    }else if( luminance > color_luminance )
    {   red += lround(( 0xff - red ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        green += lround(( 0xff - green ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        blue += lround(( 0xff - blue ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
    }else
        return color;
    return E_x_Z_color_M( red, green, blue );
}
F
E_x_Z_color_R_luminance( struct E_x_Q_display_Z *display
, N32 color
){  return ( display->red_luminance_ratio * E_x_Z_color_R_red(color) + display->green_luminance_ratio * E_x_Z_color_R_green(color) + display->blue_luminance_ratio * E_x_Z_color_R_blue(color) ) / 255;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_x_Q_window_I_draw_P_color(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, N32 color
){  if( screen->draw_color != color )
        xcb_change_gc( display->x_display
        , screen->drawable_gc
        , XCB_GC_FOREGROUND
        , ( N32[] )
          { screen->draw_color = color
          }
        );
}
//------------------------------------------------------------------------------
void
E_x_Q_window_I_fill_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_fill_poly( display->x_display
    , window->drawable
    , screen->drawable_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
    xcb_fill_poly( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
    xcb_fill_poly( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
}
void
E_x_Q_window_I_draw_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable
    , screen->drawable_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->object_mask
    , screen->object_mask_gc
    , n
    , points
    );
}
void
E_x_Q_window_I_draw_Z_segments(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_segment_t *segments
){  xcb_poly_segment( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , segments
    );
}
N
E_x_Q_window_I_draw_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_segment_t *Mt_( segments, n );
    if( !segments )
        return ~0;
    for_n( i, n - 1 )
    {   segments[i] = ( xcb_segment_t )
        { .x1 = points[i].x
        , .y1 = points[i].y
        , .x2 = points[ i + 1 ].x - ( points[i].x != points[ i + 1 ].x ? 1 : 0 )
        , .y2 = points[ i + 1 ].y - ( points[i].y != points[ i + 1 ].y ? 1 : 0 )
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n
    , segments
    );
    W(segments);
    E_x_Q_window_I_draw_Z_points_((
      ( xcb_point_t[] )
      { { .x = points[ i + 1 ].x - 1 + ( points[ n - 2 ].x != points[ n - 1 ].x ? 1 : 0 )
        , .y = points[ i + 1 ].y - 1 + ( points[ n - 2 ].y != points[ n - 1 ].y ? 1 : 0 )
        }
      }
    ));
    return 0;
}
N
E_x_Q_window_I_draw_Z_rectangles(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_rectangle_t *rectangles
){  xcb_segment_t *Mt_( segments, n * 4 );
    if( !segments )
        return ~0;
    for_n( i, n )
    {   segments[ 4 * i ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1 - ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y2 = rectangles[i].y
        };
        segments[ 4 * i + 1 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + rectangles[i].width - 1
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1 - ( rectangles[i].height != 1 ? 1 : 0 )
        };
        segments[ 4 * i + 2 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y1 = rectangles[i].y + rectangles[i].height - 1
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
        segments[ 4 * i + 3 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y + ( rectangles[i].height != 1 ? 1 : 0 )
        , .x2 = rectangles[i].x
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n * 4
    , segments
    );
    W(segments);
    return 0;
}
void
E_x_Q_window_I_draw_Z_arcs(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_arc_t *arcs
){  xcb_poly_arc( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , arcs
    );
    
}
//==============================================================================
void
E_x_Q_window_I_draw_aa_Z_pixel(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N x
, N y
, N32 color
, N get_pixel
){  N p[8];
    p[0] = ( get_pixel & Z_aa_pixel_S_e ) && x + 1 < (N) window->width ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y ) : color;
    p[1] = ( get_pixel & Z_aa_pixel_S_se ) && x + 1 < (N) window->width && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y + 1 ) : color;
    p[2] = ( get_pixel & Z_aa_pixel_S_s ) && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x, y + 1 ) : color;
    p[3] = ( get_pixel & Z_aa_pixel_S_sw ) && x > 1 && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y + 1 ) : color;
    p[4] = ( get_pixel & Z_aa_pixel_S_w ) && x > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y ) : color;
    p[5] = ( get_pixel & Z_aa_pixel_S_nw ) && x > 1 && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y - 1 ) : color;
    p[6] = ( get_pixel & Z_aa_pixel_S_n ) && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x, y - 1 ) : color;
    p[7] = ( get_pixel & Z_aa_pixel_S_ne ) && x + 1 < (N) window->width && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y - 1 ) : color;
    N red = 0;
    N green = 0;
    N blue = 0;
    N n = 0;
    for_n( i, 8 )
        if( p[i] != color )
        {   red += E_x_Z_color_R_red( p[i] ) + E_x_Z_color_R_red(color);
            green += E_x_Z_color_R_green( p[i] ) + E_x_Z_color_R_green(color);
            blue += E_x_Z_color_R_red( p[i] ) + E_x_Z_color_R_blue(color);
            n += 2;
        }
    if( !n )
        n = 1;
    E_x_Q_window_I_draw_P_color( display, screen, E_x_Z_color_M( red / n, green / n, blue / n ));
    E_x_Q_window_I_draw_Z_points_(
      (( xcb_point_t[] )
      { x, y
      })
    );
}
//NDFN rysować linię tej samej szerokości niezależnie od kąta.
void
E_x_Q_window_I_draw_aa_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N n
, xcb_point_t *points
, N32 color
){  for_n( i, n - 1 )
    {   if( points[ i + 1 ].x > points[i].x )
            if( points[ i + 1 ].y > points[i].y )
                if( points[ i + 1 ].x - points[i].x >= points[ i + 1 ].y - points[i].y )
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_y = points[i].y + round( (F)( points[ i + 1 ].y - points[i].y ) * ( x + 1 - points[i].x ) / ( points[ i + 1 ].x - points[i].x ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | ( y != next_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_se ) | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
                    S16 last_y = y;
                    while( ++x != points[ i + 1 ].x )
                    {   y = next_y;
                        next_y = points[i].y + round( (F)( points[ i + 1 ].y - points[i].y ) * ( x + 1 - points[i].x ) / ( points[ i + 1 ].x - points[i].x ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | ( y != next_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_se ) | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | ( y != last_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_nw )
                        );
                        last_y = y;
                    }
                }else
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_x = points[i].x + round( (F)( points[ i + 1 ].x - points[i].x ) * ( y + 1 - points[i].y ) / ( points[ i + 1 ].y - points[i].y ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | ( x != next_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_se ) | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
                    S16 last_x = x;
                    while( ++y != points[ i + 1 ].y )
                    {   x = next_x;
                        next_x = points[i].x + round( (F)( points[ i + 1 ].x - points[i].x ) * ( y + 1 - points[i].y ) / ( points[ i + 1 ].y - points[i].y ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , Z_aa_pixel_S_ne | Z_aa_pixel_S_e | ( x != next_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_se ) | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | ( x != last_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_nw )
                        );
                        last_x = x;
                    }
                }
            else if( points[ i + 1 ].y < points[i].y )
                if( points[ i + 1 ].x - points[i].x >= points[i].y - points[ i + 1 ].y )
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_y = points[i].y - round( (F)( points[i].y - points[ i + 1 ].y ) * ( x + 1 - points[i].x ) / ( points[ i + 1 ].x - points[i].x ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | ( y != next_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
                    S16 last_y = y;
                    while( ++x != points[ i + 1 ].x )
                    {   y = next_y;
                        next_y = points[i].y - round( (F)( points[i].y - points[ i + 1 ].y ) * ( x + 1 - points[i].x ) / ( points[ i + 1 ].x - points[i].x ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , Z_aa_pixel_S_n | ( y != next_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_se | Z_aa_pixel_S_s | ( y != last_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_nw
                        );
                        last_y = y;
                    }
                }else
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_x = points[i].x + round( (F)( points[ i + 1 ].x - points[i].x ) * ( points[i].y - y - 1 ) / ( points[i].y - points[ i + 1 ].y ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , ( x != next_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
                    S16 last_x = x;
                    while( --y != points[ i + 1 ].y )
                    {   x = next_x;
                        next_x = points[i].x + round( (F)( points[ i + 1 ].x - points[i].x ) * ( points[i].y - y - 1 ) / ( points[i].y - points[ i + 1 ].y ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , ( x != next_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_e | Z_aa_pixel_S_se | ( x != last_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                        );
                        last_x = x;
                    }
                }
            else
            {   S16 x = points[i].x;
                E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                , x, points[i].y
                , color
                , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                );
                while( ++x != points[ i + 1 ].x )
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, points[i].y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_nw
                    );
            }
        else if( points[ i + 1 ].x < points[i].x )
            if( points[ i + 1 ].y > points[i].y )
                if( points[i].x - points[ i + 1 ].x >= points[ i + 1 ].y - points[i].y )
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_y = points[i].y + round( (F)( points[ i + 1 ].y - points[i].y ) * ( points[i].x - x - 1 ) / ( points[i].x - points[ i + 1 ].x ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_e | Z_aa_pixel_S_ne | Z_aa_pixel_S_se | Z_aa_pixel_S_s | ( y != next_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_nw
                    );
                    S16 last_y = y;
                    while( --x != points[ i + 1 ].x )
                    {   y = next_y;
                        next_y = points[i].y + round( (F)( points[ i + 1 ].y - points[i].y ) * ( points[i].x - x - 1 ) / ( points[i].x - points[ i + 1 ].x ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , Z_aa_pixel_S_n | ( y != last_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_se | Z_aa_pixel_S_s | ( y != next_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_nw
                        );
                        last_y = y;
                    }
                }else
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_x = points[i].x - round( (F)( points[i].x - points[ i + 1 ].x ) * ( y + 1 - points[i].y ) / ( points[ i + 1 ].y - points[i].y ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | ( x != next_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
                    S16 last_x = x;
                    while( ++y != points[ i + 1 ].y )
                    {   x = next_x;
                        next_x = points[i].x - round( (F)( points[i].x - points[ i + 1 ].x ) * ( y + 1 - points[i].y ) / ( points[ i + 1 ].y - points[i].y ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , ( x != last_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_ne ) | Z_aa_pixel_S_e | Z_aa_pixel_S_se | ( x != next_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_sw ) | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                        );
                        last_x = x;
                    }
                }
            else if( points[ i + 1 ].y < points[i].y )
                if( points[i].x - points[ i + 1 ].x >= points[i].y - points[ i + 1 ].y )
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_y = points[i].y - round( (F)( points[i].y - points[ i + 1 ].y ) * ( points[i].x - x - 1 ) / ( points[i].x - points[ i + 1 ].x ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | ( y != next_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_nw )
                    );
                    S16 last_y = y;
                    while( --x != points[ i + 1 ].x )
                    {   y = next_y;
                        next_y = points[i].y - round( (F)( points[i].y - points[ i + 1 ].y ) * ( points[i].x - x - 1 ) / ( points[i].x - points[ i + 1 ].x ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | ( y != last_y ? Z_aa_pixel_S_e : Z_aa_pixel_S_se ) | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | ( y != next_y ? Z_aa_pixel_S_w : Z_aa_pixel_S_nw )
                        );
                        last_y = y;
                    }
                }else
                {   S16 x = points[i].x;
                    S16 y = points[i].y;
                    S16 next_x = points[i].x - round( (F)( points[i].x - points[ i + 1 ].x ) * ( points[i].y - y - 1 ) / ( points[i].y - points[ i + 1 ].y ));
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , ( x != next_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_nw ) | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w
                    );
                    S16 last_x = x;
                    while( --y != points[ i + 1 ].y )
                    {   x = next_x;
                        next_x = points[i].x - round( (F)( points[i].x - points[ i + 1 ].x ) * ( points[i].y - y - 1 ) / ( points[i].y - points[ i + 1 ].y ));
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x, y
                        , color
                        , ( x != next_x ? Z_aa_pixel_S_n : Z_aa_pixel_S_nw ) | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | ( x != last_x ? Z_aa_pixel_S_s : Z_aa_pixel_S_se ) | Z_aa_pixel_S_sw | Z_aa_pixel_S_w
                        );
                        last_x = x;
                    }
                }
            else
            {   S16 x = points[i].x;
                E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                , x, points[i].y
                , color
                , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_nw
                );
                while( --x != points[ i + 1 ].x )
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, points[i].y
                    , color
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_nw
                    );
            }
        else
            if( points[ i + 1 ].y > points[i].y )
            {   S16 y = points[i].y;
                E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                , points[i].x, y
                , color
                , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                );
                while( ++y != points[ i + 1 ].y )
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , points[i].x, y
                    , color
                    , Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
            }
            else if( points[ i + 1 ].y < points[i].y )
            {   S16 y = points[i].y;
                E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                , points[i].x, y
                , color
                , Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                );
                while( --y != points[ i + 1 ].y )
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , points[i].x, y
                    , color
                    , Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                    );
            }
            else
                E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                , points[i].x, points[i].y
                , color
                , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
                );
    }
    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
    , points[ n - 1 ].x, points[ n - 1 ].y
    , color
    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e | Z_aa_pixel_S_se | Z_aa_pixel_S_s | Z_aa_pixel_S_sw | Z_aa_pixel_S_w | Z_aa_pixel_S_nw
    );
}
/******************************************************************************/
