/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   ‟X window” —low ‘cpu’
*         window drawing
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
enum E_x_Z_aa_pixel
{ Z_aa_pixel_S_e = 1 << 0,
  Z_aa_pixel_S_se = 1 << 1,
  Z_aa_pixel_S_s = 1 << 2,
  Z_aa_pixel_S_sw = 1 << 3,
  Z_aa_pixel_S_w = 1 << 4,
  Z_aa_pixel_S_nw = 1 << 5,
  Z_aa_pixel_S_n = 1 << 6,
  Z_aa_pixel_S_ne = 1 << 7
};
//==============================================================================
N32
E_x_Z_color_M(
  N8 red
, N8 green
, N8 blue
){  return ( red << 16 ) | ( green << 8 ) | blue;
}
N8
E_x_Z_color_R_red( N32 color
){  return ( color >> 16 ) & 0xff;
}
N8
E_x_Z_color_R_green( N32 color
){  return ( color >> 8 ) & 0xff;
}
N8
E_x_Z_color_R_blue( N32 color
){  return color & 0xff;
}
N32
E_x_Z_color_M_gray(
  N8 luminance
){  return E_x_Z_color_M( luminance, luminance, luminance );
}
N32
E_x_Z_color_P_luminance( struct E_x_Q_display_Z *display
, N32 color
, F luminance
){  N8 red = E_x_Z_color_R_red(color);
    N8 green = E_x_Z_color_R_green(color);
    N8 blue = E_x_Z_color_R_blue(color);
    F color_luminance = E_x_Z_color_R_luminance( display, color );
    if( luminance < color_luminance )
    {   red = round( red * luminance / color_luminance );
        green = round( green * luminance / color_luminance );
        blue = round( blue * luminance / color_luminance );
    }else if( luminance > color_luminance )
    {   red += lround(( 0xff - red ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        green += lround(( 0xff - green ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        blue += lround(( 0xff - blue ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
    }else
        return color;
    return E_x_Z_color_M( red, green, blue );
}
F
E_x_Z_color_R_luminance( struct E_x_Q_display_Z *display
, N32 color
){  return ( display->red_luminance_ratio * E_x_Z_color_R_red(color) + display->green_luminance_ratio * E_x_Z_color_R_green(color) + display->blue_luminance_ratio * E_x_Z_color_R_blue(color) ) / 255;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_x_Q_window_I_draw_P_color(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, N32 color
){  if( screen->draw_color != color )
        xcb_change_gc( display->x_display
        , screen->drawable_gc
        , XCB_GC_FOREGROUND
        , ( N32[] )
          { screen->draw_color = color
          }
        );
}
//------------------------------------------------------------------------------
void
E_x_Q_window_I_fill_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_fill_poly( display->x_display
    , window->drawable
    , screen->drawable_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
    xcb_fill_poly( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
    xcb_fill_poly( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , XCB_POLY_SHAPE_COMPLEX
    , XCB_COORD_MODE_ORIGIN
    , n
    , points
    );
}
void
E_x_Q_window_I_fill_Z_rectangles(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_rectangle_t *rectangles
){  xcb_poly_fill_rectangle( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , rectangles
    );
    xcb_poly_fill_rectangle( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , rectangles
    );
    xcb_poly_fill_rectangle( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , rectangles
    );
}
void
E_x_Q_window_I_draw_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable
    , screen->drawable_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->object_mask
    , screen->object_mask_gc
    , n
    , points
    );
}
void
E_x_Q_window_I_draw_Z_segments(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_segment_t *segments
){  xcb_poly_segment( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , segments
    );
}
N
E_x_Q_window_I_draw_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_segment_t *Mt_( segments, n );
    if( !segments )
        return ~0;
    for_n( i, n - 1 )
    {   segments[i] = ( xcb_segment_t )
        { .x1 = points[i].x
        , .y1 = points[i].y
        , .x2 = points[ i + 1 ].x - ( points[i].x != points[ i + 1 ].x ? 1 : 0 )
        , .y2 = points[ i + 1 ].y - ( points[i].y != points[ i + 1 ].y ? 1 : 0 )
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n
    , segments
    );
    W(segments);
    E_x_Q_window_I_draw_Z_points_((
      ( xcb_point_t[] )
      { { .x = points[ i + 1 ].x - 1 + ( points[ n - 2 ].x != points[ n - 1 ].x ? 1 : 0 )
        , .y = points[ i + 1 ].y - 1 + ( points[ n - 2 ].y != points[ n - 1 ].y ? 1 : 0 )
        }
      }
    ));
    return 0;
}
N
E_x_Q_window_I_draw_Z_rectangles(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_rectangle_t *rectangles
){  xcb_segment_t *Mt_( segments, n * 4 );
    if( !segments )
        return ~0;
    for_n( i, n )
    {   segments[ 4 * i ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1 - ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y2 = rectangles[i].y
        };
        segments[ 4 * i + 1 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + rectangles[i].width - 1
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1 - ( rectangles[i].height != 1 ? 1 : 0 )
        };
        segments[ 4 * i + 2 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y1 = rectangles[i].y + rectangles[i].height - 1
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
        segments[ 4 * i + 3 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y + ( rectangles[i].height != 1 ? 1 : 0 )
        , .x2 = rectangles[i].x
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n * 4
    , segments
    );
    W(segments);
    return 0;
}
void
E_x_Q_window_I_draw_Z_arcs(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_arc_t *arcs
){  xcb_poly_arc( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , arcs
    );
    
}
//==============================================================================
struct E_x_Z_points
{ F x, y;
};
F
E_x_I_pole_wielokata(
  N n
, struct E_x_Z_points *points
){  F pole = 0;
    for_n( i, n - 1 )
        pole += points[i].x * points[ i + 1 ].y - points[ i + 1 ].x * points[i].y;
    pole += points[ n - 1 ].x * points[0].y - points[0].x * points[ n - 1 ].y;
    return 0.5 * fabs(pole);
}
void
E_x_Q_window_I_draw_aa_Z_pixel(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N x
, N y
, N32 color
, F brightness
, N get_pixel
){  N p[8];
    p[0] = ( get_pixel & Z_aa_pixel_S_e ) && x + 1 < (N) window->width ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y ) : color;
    p[1] = ( get_pixel & Z_aa_pixel_S_se ) && x + 1 < (N) window->width && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y + 1 ) : color;
    p[2] = ( get_pixel & Z_aa_pixel_S_s ) && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x, y + 1 ) : color;
    p[3] = ( get_pixel & Z_aa_pixel_S_sw ) && x > 1 && y + 1 < (N) window->height ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y + 1 ) : color;
    p[4] = ( get_pixel & Z_aa_pixel_S_w ) && x > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y ) : color;
    p[5] = ( get_pixel & Z_aa_pixel_S_nw ) && x > 1 && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x - 1, y - 1 ) : color;
    p[6] = ( get_pixel & Z_aa_pixel_S_n ) && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x, y - 1 ) : color;
    p[7] = ( get_pixel & Z_aa_pixel_S_ne ) && x + 1 < (N) window->width && y > 1 ? E_x_Q_image_R_pixel( display, window->drawable, x + 1, y - 1 ) : color;
    N background_red = 0, background_green = 0, background_blue = 0;
    N n = 0;
    for_n( i, 8 )
        if( p[i] != color )
        {   background_red += E_x_Z_color_R_red( p[i] );
            background_green += E_x_Z_color_R_green( p[i] );
            background_blue += E_x_Z_color_R_red( p[i] );
            n++;
        }
    if( !n )
    {   background_red = E_x_Z_color_R_red( E_x_theme_Q_theme.window_bg );
        background_green = E_x_Z_color_R_green( E_x_theme_Q_theme.window_bg );
        background_blue = E_x_Z_color_R_blue( E_x_theme_Q_theme.window_bg );
        n = 1;
    }
    background_red /= n;
    background_green /= n;
    background_blue /= n;
    N red = E_x_Z_color_R_red(color);
    N green = E_x_Z_color_R_green(color);
    N blue = E_x_Z_color_R_blue(color);
    if( red > background_red )
        red = background_red + ( red - background_red ) * brightness;
    else
        red = background_red - ( background_red - red ) * brightness;
    if( green > background_green )
        green = background_green + ( green - background_green ) * brightness;
    else
        green = background_green - ( background_green - green ) * brightness;
    if( blue > background_blue )
        blue = background_blue + ( blue - background_blue ) * brightness;
    else
        blue = background_blue - ( background_blue - blue ) * brightness;
    E_x_Q_window_I_draw_P_color( display, screen, E_x_Z_color_M( red, green, blue ));
    E_x_Q_window_I_draw_Z_points_(
      (( xcb_point_t[] )
      { x, y
      })
    );
}
N
E_x_Q_window_I_draw_aa_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N n
, xcb_point_t *points
, F thickness
, N32 color
){  F a = screen->pixel_width;
    F b = screen->pixel_height;
    F pole_pixela = a * b;
    for_n( i, n - 1 )
    {   F alfa = atan( (F)( points[ i + 1 ].y - points[i].y ) / ( points[ i + 1 ].x - points[i].x ));
        if( points[ i + 1 ].x > points[i].x )
        {   if( points[ i + 1 ].y < points[i].y )
                alfa += M_PI_2;
            else if( points[i].y == points[ i + 1 ].y )
            {   xcb_rectangle_t rectangle;
                rectangle.x = points[i].x;
                rectangle.y = points[i].y - (S16)( 0.5 * thickness / b );
                rectangle.width = points[ i + 1 ].x - points[i].x + 1;
                rectangle.height = (N16)( thickness / b );
                F pole = fmod( 0.5 * thickness, b );
                if(pole)
                {   pole *= a;
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x, rectangle.y - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_nw | Z_aa_pixel_S_n
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width - 1, rectangle.y - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x, rectangle.y + rectangle.height
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_se | Z_aa_pixel_S_s
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width - 1, rectangle.y + rectangle.height
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_s | Z_aa_pixel_S_se | Z_aa_pixel_S_e
                    );
                    if( points[i].x + 1 < points[ i + 1 ].x )
                        for( S16 x = points[i].x + 1; x != points[ i + 1 ].x; x++ )
                        {   E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , x, rectangle.y - 1
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_n
                            );
                            E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , x, rectangle.y + rectangle.height
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_s
                            );
                        }
                }
                if( rectangle.height )
                {   E_x_Q_window_I_draw_P_color( display, screen, color );
                    E_x_Q_window_I_fill_Z_rectangles( display, screen, window, 1, &rectangle );
                }
                continue;
            }
        }else if( points[ i + 1 ].x < points[i].x )
        {   if( points[ i + 1 ].y > points[i].y )
                alfa += M_PI_2;
            else if( points[i].y == points[ i + 1 ].y )
            {   xcb_rectangle_t rectangle;
                rectangle.x = points[ i + 1 ].x;
                rectangle.y = points[i].y - (S16)( 0.5 * thickness / b );
                rectangle.width = points[i].x - points[ i + 1 ].x + 1;
                rectangle.height = (N16)( thickness / b );
                F pole = fmod( 0.5 * thickness, b );
                if(pole)
                {   pole *= a;
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x, rectangle.y - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_nw | Z_aa_pixel_S_n
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width - 1, rectangle.y - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x, rectangle.y + rectangle.height
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_sw | Z_aa_pixel_S_s
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width - 1, rectangle.y + rectangle.height
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_s | Z_aa_pixel_S_se | Z_aa_pixel_S_e
                    );
                    if( points[ i + 1 ].x + 1 < points[i].x )
                        for( S16 x = points[ i + 1 ].x + 1; x != points[i].x; x++ )
                        {   E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , x, rectangle.y - 1
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_n
                            );
                            E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , x, rectangle.y + rectangle.height
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_s
                            );
                        }
                }
                if( rectangle.height )
                {   E_x_Q_window_I_draw_P_color( display, screen, color );
                    E_x_Q_window_I_fill_Z_rectangles( display, screen, window, 1, &rectangle );
                }
                continue;
            }
        }else
        {   if( points[ i + 1 ].y > points[i].y )
            {   xcb_rectangle_t rectangle;
                rectangle.x = points[i].x - (S16)( 0.5 * thickness / a );
                rectangle.y = points[i].y;
                rectangle.width = (N16)( thickness / a );
                rectangle.height = points[ i + 1 ].y - points[i].y + 1;
                F pole = fmod( 0.5 * thickness, a );
                if(pole)
                {   pole *= b;
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x - 1, rectangle.y
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_nw | Z_aa_pixel_S_n
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width, rectangle.y
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x - 1, rectangle.y + rectangle.height - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_sw | Z_aa_pixel_S_s
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width, rectangle.y + rectangle.height - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_s | Z_aa_pixel_S_se | Z_aa_pixel_S_e
                    );
                    if( points[i].y + 1 < points[ i + 1 ].y )
                        for( S16 y = points[i].y + 1; y != points[ i + 1 ].y; y++ )
                        {   E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , rectangle.x - 1, y
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_w
                            );
                            E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , rectangle.x + rectangle.width, y
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_e
                            );
                        }
                }
                if( rectangle.height )
                {   E_x_Q_window_I_draw_P_color( display, screen, color );
                    E_x_Q_window_I_fill_Z_rectangles( display, screen, window, 1, &rectangle );
                }
            }else if( points[ i + 1 ].y < points[i].y )
            {   xcb_rectangle_t rectangle;
                rectangle.x = points[i].x - (S16)( 0.5 * thickness / a );
                rectangle.y = points[ i + 1 ].y;
                rectangle.width = (N16)( thickness / a );
                rectangle.height = points[i].y - points[ i + 1 ].y + 1;
                F pole = fmod( 0.5 * thickness, a );
                if(pole)
                {   pole *= b;
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x - 1, rectangle.y
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_nw | Z_aa_pixel_S_n
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width, rectangle.y
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_n | Z_aa_pixel_S_ne | Z_aa_pixel_S_e
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x - 1, rectangle.y + rectangle.height - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_w | Z_aa_pixel_S_sw | Z_aa_pixel_S_s
                    );
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , rectangle.x + rectangle.width, rectangle.y + rectangle.height - 1
                    , color
                    , pole / pole_pixela
                    , Z_aa_pixel_S_s | Z_aa_pixel_S_se | Z_aa_pixel_S_e
                    );
                    if( points[ i + 1 ].y + 1 < points[i].y )
                        for( S16 y = points[ i + 1 ].y + 1; y != points[i].y; y++ )
                        {   E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , rectangle.x - 1, y
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_w
                            );
                            E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                            , rectangle.x + rectangle.width, y
                            , color
                            , pole / pole_pixela
                            , Z_aa_pixel_S_e
                            );
                        }
                }
                if( rectangle.height )
                {   E_x_Q_window_I_draw_P_color( display, screen, color );
                    E_x_Q_window_I_fill_Z_rectangles( display, screen, window, 1, &rectangle );
                }
            }else
            {   GV( "point instead of line" );
            }
            continue;
        }
        F sin_alfa, cos_alfa, tan_alfa;
        S16 dx_direction, dy_direction;
        F pixel_dx, pixel_dy;
        B prawoskretny;
        struct
        { S16 dx, dy;
        } *Mt_( dx_dy, 0 );
        if( !dx_dy )
            return ~0;
        N dx_dy_n = 0;
        for_n( j, 6 )
        {   F length;
            S16 x, y;
            B U_R( first_pixel, overdrawn );
            switch(j)
            { case 0:
                  U_F( first_pixel, overdrawn );
                  prawoskretny = no;
                  alfa = M_PI_2 - alfa;
                  sin_alfa = sin(alfa);
                  cos_alfa = cos(alfa);
                  tan_alfa = tan(alfa);
                  length = 0.5 * thickness;
                  x = points[i].x;
                  y = points[i].y;
                  if( points[ i + 1 ].x > points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = -1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = -1;
                      }
                  else if( points[ i + 1 ].x < points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = 1;
                      }
                  pixel_dx = 0.5 * a;
                  pixel_dy = 0.5 * b;
                  break;
              case 1:
                  U_F( first_pixel, overdrawn );
                  length = hypot(( points[ i + 1 ].x - points[i].x + 1 ) * a, ( points[ i + 1 ].y - points[i].y + 1 ) * b );
                  if( points[ i + 1 ].x > points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = 1;
                          dy_direction = -1;
                      }
                  else if( points[ i + 1 ].x < points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = -1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = -1;
                      }
                  break;
              case 2:
                  U_F( first_pixel, overdrawn );
                  prawoskretny = yes;
                  alfa = M_PI_2 - alfa;
                  sin_alfa = sin(alfa);
                  cos_alfa = cos(alfa);
                  tan_alfa = tan(alfa);
                  length = 0.5 * thickness;
                  x = points[ i + 1 ].x;
                  y = points[ i + 1 ].y;
                  if( points[ i + 1 ].x > points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = -1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = -1;
                      }
                  else if( points[ i + 1 ].x < points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = 1;
                      }
                  pixel_dx = 0.5 * a;
                  pixel_dy = 0.5 * b;
                  break;
              case 3:
                  U_L( first_pixel, overdrawn );
                  prawoskretny = no;
                  alfa = M_PI_2 - alfa;
                  sin_alfa = sin(alfa);
                  cos_alfa = cos(alfa);
                  tan_alfa = tan(alfa);
                  length = 0.5 * thickness;
                  x = points[ i + 1 ].x;
                  y = points[ i + 1 ].y;
                  dx_direction = -dx_direction;
                  dy_direction = -dy_direction;
                  pixel_dx = 0.5 * a;
                  pixel_dy = 0.5 * b;
                  break;
              case 4:
                  U_L( first_pixel, overdrawn );
                  prawoskretny = yes;
                  alfa = M_PI_2 - alfa;
                  sin_alfa = sin(alfa);
                  cos_alfa = cos(alfa);
                  tan_alfa = tan(alfa);
                  length = 0.5 * thickness;
                  x = points[i].x;
                  y = points[i].y;
                  pixel_dx = 0.5 * a;
                  pixel_dy = 0.5 * b;
                  break;
              case 5:
                  U_F( first_pixel, overdrawn );
                  length = hypot(( points[ i + 1 ].x - points[i].x + 1 ) * a, ( points[ i + 1 ].y - points[i].y + 1 ) * b );
                  if( points[ i + 1 ].x > points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = 1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = 1;
                          dy_direction = -1;
                      }
                  else if( points[ i + 1 ].x < points[i].x )
                      if( points[ i + 1 ].y > points[i].y )
                      {   dx_direction = -1;
                          dy_direction = 1;
                      }else
                      {   dx_direction = -1;
                          dy_direction = -1;
                      }
                  break;
            }
            //G_(); fprintf( stderr, "|alfa = %f", alfa * 180 / M_PI );
            B wariant_0 = ( prawoskretny && (( dx_direction > 0 && dy_direction > 0 ) || ( dx_direction < 0 && dy_direction < 0 )))
                || ( !prawoskretny && (( dx_direction > 0 && dy_direction < 0 ) || ( dx_direction < 0 && dy_direction > 0 )));
            //G_(); Gd( wariant_0 );
            if( !wariant_0 )
            {   J_swap( F, a, b );
                J_swap( F, pixel_dx, pixel_dy );
            }
            S16 dx, dy;
            B U_F( first_pixel, computed );
            while( length > 0 )
            {   F alfa_przekatnej = atan(( b - pixel_dy ) / ( a - pixel_dx ));
                //G_(); fprintf( stderr, "|alfa przekątnej = %f", alfa_przekatnej * 180 / M_PI );
                struct E_x_Z_points *pixel_points;
                N n_;
                if( alfa <= alfa_przekatnej )
                {   if( length >= ( a - pixel_dx ) / cos_alfa )
                    {   Mt_( pixel_points, n_ = 3 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = a;
                        pixel_points[1].y = pixel_dy + ( a - pixel_dx ) * tan_alfa;
                        pixel_points[2].x = a;
                        pixel_points[2].y = pixel_dy;
                    }else if( length <= ( a - pixel_dx ) * cos_alfa )
                    {   Mt_( pixel_points, n_ = 3 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + length * cos_alfa;
                        pixel_points[1].y = pixel_dy + length * sin_alfa;
                        pixel_points[2].x = pixel_dx + length / cos_alfa;
                        pixel_points[2].y = pixel_dy;
                    }else
                    {   Mt_( pixel_points, n_ = 4 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + length * cos_alfa;
                        pixel_points[1].y = pixel_dy + length * sin_alfa;
                        pixel_points[2].x = a;
                        pixel_points[2].y = pixel_dy + ( length / cos_alfa - ( a - pixel_dx )) / tan_alfa;
                        pixel_points[3].x = a;
                        pixel_points[3].y = pixel_dy;
                    }
                    length -= ( a - pixel_dx ) / cos_alfa;
                    if( wariant_0 )
                    {   dx = dx_direction;
                        dy = alfa == alfa_przekatnej ? dy_direction : 0;
                    }else
                    {   dx = alfa == alfa_przekatnej ? dx_direction : 0;
                        dy = dy_direction;
                    }
                }else
                {   if( length >= ( b - pixel_dy ) / sin_alfa + ( a - pixel_dx - ( b - pixel_dy ) / tan_alfa ) * cos_alfa )
                    {   Mt_( pixel_points, n_ = 4 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + ( b - pixel_dy ) / tan_alfa;
                        pixel_points[1].y = b;
                        pixel_points[2].x = a;
                        pixel_points[2].y = b;
                        pixel_points[3].x = a;
                        pixel_points[3].y = pixel_dy;
                    }else if( length <= ( a - pixel_dx ) * cos_alfa )
                    {   Mt_( pixel_points, n_ = 3 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + length * cos_alfa;
                        pixel_points[1].y = pixel_dy + length * sin_alfa;
                        pixel_points[2].x = pixel_dx + length / cos_alfa;
                        pixel_points[2].y = pixel_dy;
                    }else if( length > ( b - pixel_dy ) / sin_alfa )
                    {   Mt_( pixel_points, n_ = 5 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + ( b - pixel_dy ) / tan_alfa;
                        pixel_points[1].y = b;
                        pixel_points[2].x = pixel_dx + ( b - pixel_dy ) / tan_alfa + ( length - ( b - pixel_dy ) / sin_alfa ) / cos_alfa;
                        pixel_points[2].y = b;
                        pixel_points[3].x = a;
                        pixel_points[3].y = b - ( a - ( pixel_dx + ( b - pixel_dy ) / tan_alfa + ( length - ( b - pixel_dy ) / sin_alfa ) / cos_alfa )) / tan_alfa;
                        pixel_points[4].x = a;
                        pixel_points[4].y = pixel_dy;
                    }else
                    {   Mt_( pixel_points, n_ = 4 );
                        if( !pixel_points )
                        {   W( dx_dy );
                            return ~0;
                        }
                        pixel_points[1].x = pixel_dx + length * cos_alfa;
                        pixel_points[1].y = pixel_dy + length * sin_alfa;
                        pixel_points[2].x = a;
                        pixel_points[2].y = pixel_dy + ( pixel_dx + length / cos_alfa - a ) / tan_alfa;
                        pixel_points[3].x = a;
                        pixel_points[3].y = pixel_dy;
                    }
                    length -= ( b - pixel_dy ) / sin_alfa;
                    if( wariant_0 )
                    {   dx = 0;
                        dy = dy_direction;
                    }else
                    {   dx = dx_direction;
                        dy = 0;
                    }
                }
                pixel_points[0].x = pixel_dx;
                pixel_points[0].y = pixel_dy;
                if( alfa <= alfa_przekatnej )
                {   pixel_dy = alfa == alfa_przekatnej ? 0 : pixel_dy + ( a - pixel_dx ) * tan_alfa;
                    if( pixel_dy >= b )
                        pixel_dy = 0;
                    pixel_dx = 0;
                }else
                {   pixel_dx += ( b - pixel_dy ) / tan_alfa;
                    if( pixel_dx >= a )
                        pixel_dx = 0;
                    pixel_dy = 0;
                }
                if( !wariant_0 )
                {   for_n( i, n_ - 1 )
                        J_swap( F, pixel_points[ i + 1 ].x, pixel_points[ i + 1 ].y );
                }
                for_n( i, n_ )
                {   //G_(); Gd(i); fprintf( stderr, "|x = %f, y = %f", pixel_points[i].x, pixel_points[i].y );
                    if( pixel_points[i].x < 0 || pixel_points[i].y < 0 )
                    {   G_(); Gs_( "błąd" );
                        U_F( E_base_S->E_flow_S_signal, exit );
                        I_B(){}
                    }
                }
                F pole = E_x_I_pole_wielokata( n_, pixel_points );
                W( pixel_points );
                if( j == 0 )
                {   if( !E_mem_Q_blk_I_append( &dx_dy, 1 ))
                        return ~0;
                    dx_dy[ dx_dy_n ].dx = dx;
                    dx_dy[ dx_dy_n ].dy = dy;
                    dx_dy_n++;
                }else if( j == 4 )
                {   if( !U_R( first_pixel, computed ))
                    {   if( !E_mem_Q_blk_I_append( &dx_dy, 1 ))
                            return ~0;
                        dx_dy[ dx_dy_n ].dx = dx;
                        dx_dy[ dx_dy_n ].dy = dy;
                        dx_dy_n++;
                    }
                }else if( j == 1 || j == 5 )
                {   if( !U_R( first_pixel, computed )
                    && length >= 0
                    ){  E_x_Q_window_I_draw_P_color( display, screen, color );
                        S16 x_ = x, y_ = y;
                        for_n_rev( i, dx_dy_n )
                        {   x_ -= dx_dy[i].dx;
                            y_ -= dx_dy[i].dy;
                            xcb_point_t point = { x_, y_ };
                            E_x_Q_window_I_draw_Z_points( display, screen, window, 1, &point );
                        }
                    }
                }else if( j == 2 )
                {   E_mem_Q_blk_I_rem( &dx_dy, 0, dx_dy_n );
                    dx_dy_n = 0;
                }
                if( U_E( first_pixel, computed )
                && ( j == 3 || j == 4 )
                )
                    pole *= 2;
                //G_(); fprintf( stderr, "|pole = %f, prostokąta = %f, brightness = %f", pole, pole_pixela, pole / pole_pixela );
                if( pole > pole_pixela )
                {   G_(); Gs_( "błąd" );
                    U_F( E_base_S->E_flow_S_signal, exit );
                    I_B(){}
                }
                if( U_E( first_pixel, overdrawn ))
                    ;
                else
                    E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                    , x, y
                    , color
                    , pole / pole_pixela
                    , 0 //TODO
                    );
                x += dx;
                y += dy;
            }
            if( j != 5 && !wariant_0 )
            {   J_swap( F, a, b );
                J_swap( F, pixel_dx, pixel_dy );
            }
        }
        W( dx_dy );
    }
    return 0;
}
/******************************************************************************/
