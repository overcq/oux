/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   ‟X window” —low ‘cpu’
*         window drawing
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
const F red_luminance_ratio = 0.2126;
const F green_luminance_ratio = 0.7152;
const F blue_luminance_ratio = 0.0722;
//==============================================================================
enum E_x_Z_aa_pixel
{ Z_aa_pixel_S_e = 1 << 0,
  Z_aa_pixel_S_se = 1 << 1,
  Z_aa_pixel_S_s = 1 << 2,
  Z_aa_pixel_S_sw = 1 << 3,
  Z_aa_pixel_S_w = 1 << 4,
  Z_aa_pixel_S_nw = 1 << 5,
  Z_aa_pixel_S_n = 1 << 6,
  Z_aa_pixel_S_ne = 1 << 7
};
//==============================================================================
N32
E_x_Z_color_M(
  N8 red
, N8 green
, N8 blue
){  return ( red << 16 ) | ( green << 8 ) | blue; //TODO “maski” kolorów do odczytu z “xcb_setup”.
}
N8
E_x_Z_color_R_red( N32 color
){  return ( color >> 16 ) & 0xff;
}
N8
E_x_Z_color_R_green( N32 color
){  return ( color >> 8 ) & 0xff;
}
N8
E_x_Z_color_R_blue( N32 color
){  return color & 0xff;
}
N32
E_x_Z_color_M_gray(
  N8 luminance
){  return E_x_Z_color_M( luminance, luminance, luminance );
}
N8
E_x_Z_color_P_luminance( N32 color
, F luminance
){  N8 red = E_x_Z_color_R_red(color);
    N8 green = E_x_Z_color_R_green(color);
    N8 blue = E_x_Z_color_R_blue(color);
    F color_luminance = E_x_Z_color_R_luminance(color);
    if( luminance < color_luminance )
    {   red = round( red * luminance / color_luminance );
        green = round( green * luminance / color_luminance );
        blue = round( blue * luminance / color_luminance );
    }else if( luminance > color_luminance )
    {   red += round(( 0xff - red ) * ( luminance - color_luminance ) / ( 0xff - color_luminance ));
        green += round(( 0xff - green ) * ( luminance - color_luminance ) / ( 0xff - color_luminance ));
        blue += round(( 0xff - blue ) * ( luminance - color_luminance ) / ( 0xff - color_luminance ));
    }else
        return color;
    return E_x_Z_color_M( red, green, blue );
}
F
E_x_Z_color_R_luminance( N32 color
){  return red_luminance_ratio * E_x_Z_color_R_red(color) + green_luminance_ratio * E_x_Z_color_R_green(color) + blue_luminance_ratio * E_x_Z_color_R_blue(color);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_x_Q_window_I_draw_P_color(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, N32 color
){  if( screen->draw_color != color )
        xcb_change_gc( display->x_display
        , screen->drawable_gc
        , XCB_GC_FOREGROUND
        , ( N32[] )
          { screen->draw_color = color
          }
        );
}
//------------------------------------------------------------------------------
void
E_x_Q_window_I_draw_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable
    , screen->drawable_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , points
    );
    xcb_poly_point( display->x_display
    , XCB_COORD_MODE_ORIGIN
    , window->object_mask
    , screen->object_mask_gc
    , n
    , points
    );
}
void
E_x_Q_window_I_draw_Z_segments(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_segment_t *segments
){  xcb_poly_segment( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , segments
    );
    xcb_poly_segment( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , segments
    );
}
void
E_x_Q_window_I_draw_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_point_t *points
){  xcb_segment_t *Mt_( segments, n );
    for_n( i, n - 1 )
    {   segments[i] = ( xcb_segment_t )
        { .x1 = points[i].x
        , .y1 = points[i].y
        , .x2 = points[ i + 1 ].x - ( points[i].x != points[ i + 1 ].x ? 1 : 0 )
        , .y2 = points[ i + 1 ].y - ( points[i].y != points[ i + 1 ].y ? 1 : 0 )
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n
    , segments
    );
    W(segments);
    E_x_Q_window_I_draw_Z_points_((
      ( xcb_point_t[] )
      { { .x = points[ i + 1 ].x - 1 + ( points[ n - 2 ].x != points[ n - 1 ].x ? 1 : 0 )
        , .y = points[ i + 1 ].y - 1 + ( points[ n - 2 ].y != points[ n - 1 ].y ? 1 : 0 )
        }
      }
    ));
}
void
E_x_Q_window_I_draw_Z_rectangles(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_rectangle_t *rectangles
){  xcb_segment_t *Mt_( segments, n * 4 );
    for_n( i, n )
    {   segments[ 4 * i ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1 - ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y2 = rectangles[i].y
        };
        segments[ 4 * i + 1 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + rectangles[i].width - 1
        , .y1 = rectangles[i].y
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1 - ( rectangles[i].height != 1 ? 1 : 0 )
        };
        segments[ 4 * i + 2 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x + ( rectangles[i].width != 1 - 1 ? 1 : 0 )
        , .y1 = rectangles[i].y + rectangles[i].height - 1
        , .x2 = rectangles[i].x + rectangles[i].width - 1
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
        segments[ 4 * i + 3 ] = ( xcb_segment_t )
        { .x1 = rectangles[i].x
        , .y1 = rectangles[i].y + ( rectangles[i].height != 1 ? 1 : 0 )
        , .x2 = rectangles[i].x
        , .y2 = rectangles[i].y + rectangles[i].height - 1
        };
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window
    , n * 4
    , segments
    );
    W(segments);
}
void
E_x_Q_window_I_draw_Z_arcs(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N32 n
, xcb_arc_t *arcs
){  xcb_poly_arc( display->x_display
    , window->drawable
    , screen->drawable_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->drawable_mask
    , screen->bitmask_1_gc
    , n
    , arcs
    );
    xcb_poly_arc( display->x_display
    , window->object_mask
    , screen->object_mask_gc
    , n
    , arcs
    );
    
}
//==============================================================================
void
E_x_Q_window_I_put_pixel_aa(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N x
, N y
, N32 color
, N get_pixel
){
#if 0
    N p[8];
    p[0] = ( get_pixel & Z_aa_pixel_S_e ) && x + 1 < (N) window->width ? /* XGetPixel( ximage, x + 1, y ) */ 0 : color;
    p[1] = ( get_pixel & Z_aa_pixel_S_se ) && x + 1 < (N) window->width && y + 1 < (N) window->height ? /* XGetPixel( ximage, x + 1, y + 1 ) */ 0 : color;
    p[2] = ( get_pixel & Z_aa_pixel_S_s ) && y + 1 < (N) window->height ? /* XGetPixel( ximage, x, y + 1 ) */ 0 : color;
    p[3] = ( get_pixel & Z_aa_pixel_S_sw ) && x > 1 && y + 1 < (N) window->height ? /* XGetPixel( ximage, x - 1, y + 1 ) */ 0 : color;
    p[4] = ( get_pixel & Z_aa_pixel_S_w ) && x > 1 ? /* XGetPixel( ximage, x - 1, y ) */ 0 : color;
    p[5] = ( get_pixel & Z_aa_pixel_S_nw ) && x > 1 && y > 1 ? /* XGetPixel( ximage, x - 1, y - 1 ) */ 0 : color;
    p[6] = ( get_pixel & Z_aa_pixel_S_n ) && y > 1 ? /* XGetPixel( ximage, x, y - 1 ) */ 0 : color;
    p[7] = ( get_pixel & Z_aa_pixel_S_ne ) && x + 1 < (N) window->width && y > 1 ? /* XGetPixel( ximage, x + 1, y - 1 ) */ 0 : color;
    N red = 8 * E_x_Z_color_R_red(color);
    N green = 8 * E_x_Z_color_R_green(color);
    N blue = 8 * E_x_Z_color_R_blue(color);
    for( N i = 0; i < 8; i++ )
    {   red += E_x_Z_color_R_red( p[i] );
        green += E_x_Z_color_R_green( p[i] );
        blue += E_x_Z_color_R_red( p[i] );
    }
    E_x_Q_window_I_draw_P_color( display, screen, E_x_Z_color_M( red / 16, green / 16, blue / 16 ));
    E_x_Q_window_I_draw_P_color( display, screen, color);
#endif
    E_x_Q_window_I_draw_Z_points_(
      (( xcb_point_t[] )
      { x, y
      })
    );
}
//NDFN zamienić na rysowanie wektorowe, według segmentów.
void
E_x_Q_window_I_angle_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N angle
, N x
, N y
, N max_width
, N max_height
, N32 color
){
#ifdef C_check_arg
    if( !max_width )
        V();
    if( !max_height )
        V();
#endif
    if( T_sign(angle) )
        angle = 360 - J_abs(angle) % 360;
    else
        angle %= 360;
    F a = angle * M_PI / 180;
    F d = tan(a); //NDFN oblicza skończoną wartość dla 90!
    const N dpi_x = 98; //NDFN zuniwersalizować ‘dpi’ do opisu wyświetlacza.
    const N dpi_y = 96;
    N width;
    N height;
    if( dpi_x < dpi_y )
        width = round( dpi_x * max_height / ( fabs(d) * dpi_y ));
    else
        width = round( max_height / fabs(d) );
    if( dpi_y < dpi_x )
        height = round( max_width * fabs(d) * dpi_y / dpi_x );
    else
        height = round( max_width * fabs(d) );
    if( angle == 0
        || ( height == 0
            && ( angle > 360 - 45
                || angle < 0 + 45
    )))
        E_x_Q_window_I_draw_Z_line_(
          (( xcb_point_t[] )
          { x, y
          , x + max_width - 1, y
          })
        );
    else if( angle == 90
        || ( width == 0
            && angle > 90 - 45
            && angle < 90 + 45
    ))
        E_x_Q_window_I_draw_Z_line_(
          (( xcb_point_t[] )
          { x, y
          , x, y + max_height - 1
          })
        );
    else if( angle == 180
        || ( height == 0
            && angle > 180 - 45
            && angle < 180 + 45
    ))
        E_x_Q_window_I_draw_Z_line_(
          (( xcb_point_t[] )
          { x - ( max_width - 1 ), y
          , x, y
          })
        );
    else if( angle == 270
        || ( width == 0
            && angle > 270 - 45
            && angle < 270 + 45
    ))
        E_x_Q_window_I_draw_Z_line_(
          (( xcb_point_t[] )
          { x, y - ( max_height - 1 )
          , x, y
          })
        );
    else
    {   if( width == 0 || height == 0 )
            V();
        const N aa_segment_size_start = 2;
        bool sin_gtz = sin(a) > 0; //0 do 180 stopni.
        bool cos_gtz = cos(a) > 0; //-90 do 90 stopni.
        if( width > max_width )
            width = max_width;
        if( height > max_height )
            height = max_height;
        xcb_point_t *point;
        N point_count = 0;
        N segment_size;
        N segment;
        F insertion_step;
        F insertion;
        N i;
        if( width >= height )
        {   point = E_mem_Q_blk_M_tab( sizeof( xcb_point_t ),  width - 1 + width / 2 );
            segment_size = width / height;
            segment = segment_size;
            insertion_step = (F) width / ( width % height + 1 );
            insertion = insertion_step;
            N yi = y;
            for( i = 0; i < width - 1; i++ )
            {   point[ point_count ].x = x + ( cos_gtz ? i : -i );
                point[ point_count ].y = yi;
                point_count++;
                N insertion_tmp = ceil(insertion);
                if( i == insertion_tmp )
                    insertion += insertion_step;
                else if( !--segment )
                {   yi += sin_gtz ? 1 : -1;
                    if( segment_size >= aa_segment_size_start ) //punkt nadmiarowy.
                    {   if( point_count )
                        {   E_x_Q_window_I_draw_Z_points( display
                            , screen
                            , window
                            , point_count
                            , point
                            );
                            point_count = 0;
                        }
                        E_x_Q_window_I_put_pixel_aa( display
                        , screen
                        , window
                        , x + ( cos_gtz ? i : -i ), yi
                        , color
                        , ( cos_gtz ? Z_aa_pixel_S_w : Z_aa_pixel_S_e ) //1.
                            | ( sin_gtz ? Z_aa_pixel_S_s : Z_aa_pixel_S_n ) //2.
                            | ( cos_gtz ? Z_aa_pixel_S_ne | Z_aa_pixel_S_se : Z_aa_pixel_S_nw | Z_aa_pixel_S_sw ) //3.
                            | ( sin_gtz ? ( cos_gtz ? Z_aa_pixel_S_sw : Z_aa_pixel_S_se ) : ( cos_gtz ? Z_aa_pixel_S_nw : Z_aa_pixel_S_ne )) //4.
                        );
                        E_x_Q_window_I_draw_P_color( display, screen, color );
                    }
                    segment = segment_size;
                }
            }
            if( point_count )
                E_x_Q_window_I_draw_Z_points( display
                , screen
                , window
                , point_count
                , point
                );
            E_x_Q_window_I_draw_Z_points_(
              (( xcb_point_t[] )
              { x + ( cos_gtz ? i : -i ), yi
              })
            );
        }else
        {   point = E_mem_Q_blk_M_tab( sizeof( xcb_point_t ),  height - 1 + height / 2 );
            segment_size = height / width;
            segment = segment_size;
            insertion_step = (F) height / ( height % width + 1 );
            insertion = insertion_step;
            N xi = x;
            for( i = 0; i < height - 1; i++ )
            {   point[ point_count ].x = xi;
                point[ point_count ].y = y + ( sin_gtz ? i : -i );
                point_count++;
                N insertion_tmp = ceil(insertion);
                if( i == insertion_tmp )
                    insertion += insertion_step;
                else if( !--segment )
                {   xi += cos_gtz ? 1 : -1;
                    if( segment_size >= aa_segment_size_start )
                    {   if( point_count )
                        {   E_x_Q_window_I_draw_Z_points( display
                            , screen
                            , window
                            , point_count
                            , point
                            );
                            point_count = 0;
                        }
                        E_x_Q_window_I_put_pixel_aa( display
                        , screen
                        , window
                        , xi, y + ( sin_gtz ? i : -i )
                        , color
                        , ( sin_gtz ? Z_aa_pixel_S_n : Z_aa_pixel_S_s ) //1.
                            | ( cos_gtz ? Z_aa_pixel_S_e : Z_aa_pixel_S_w ) //2.
                            | ( sin_gtz ? Z_aa_pixel_S_sw | Z_aa_pixel_S_se : Z_aa_pixel_S_nw | Z_aa_pixel_S_ne ) //3.
                            | ( sin_gtz ? ( cos_gtz ? Z_aa_pixel_S_ne : Z_aa_pixel_S_nw ) : ( cos_gtz ? Z_aa_pixel_S_se : Z_aa_pixel_S_sw )) //4.
                        );
                        E_x_Q_window_I_draw_P_color( display, screen, color );
                    }
                    segment = segment_size;
                }
            }
            if( point_count )
                E_x_Q_window_I_draw_Z_points( display
                , screen
                , window
                , point_count
                , point
                );
            E_x_Q_window_I_draw_Z_points_(
              (( xcb_point_t[] )
              { xi, y + ( sin_gtz ? i : -i )
              })
            );
        }
        E_mem_Q_blk_W(point);
    }
}
/******************************************************************************/
