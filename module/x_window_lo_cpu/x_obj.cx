/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   ‟X window”
*         window objects manager
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
///są to obiekty wizualne.
//każdy obiekt okna jest jednokrotny w konkretnym oknie. typy obiektów w celu przypisania referencyjnego funkcji obiektu ewentualnie do zrobienia później, jeśli to rozwiązanie okaże się potrzebne zamiast zwykłego ustawiania wskaźników do procedur.
//==============================================================================
typedef
void
(*draw_object_proc)(
  struct E_x_Q_display_Z *
, struct E_x_Q_screen_Z *
, struct E_x_Q_window_Z *
, struct E_x_Q_object_Z *
);
typedef
void
(*click_object_proc)(
  struct E_x_Q_window_Z *
, struct E_x_Q_object_Z *
, N8
, N8
);
struct E_x_Q_object_Z
{ void ///ale obiekt zawiera punkty, które narysuje ta funkcja w czasie wywołania.
  (*draw)(
    struct E_x_Q_display_Z *
  , struct E_x_Q_screen_Z *
  , struct E_x_Q_window_Z *
  , struct E_x_Q_object_Z *
  );
  void
  (*click)(
    struct E_x_Q_window_Z *
  , struct E_x_Q_object_Z *
  , N8
  , N8
  );
  N child_n;
  I *child;
  P data;
  S16 x, y;
  N16 width, height; ///prostokąt oczekiwanej widoczności obiektu.
  unsigned U_R( mode, lay_height ):1;
  unsigned U_R( mode, draggable ) :1;
  unsigned U_R( mode, drag_src )  :1;
  unsigned U_R( req, draw )       :1;
};
//==============================================================================
S16 E_x_Q_object_S_layout_dx = 4, E_x_Q_object_S_layout_dy = 4;
//==============================================================================
I
E_x_Q_object_M(
  struct E_x_Q_display_Z *display
, struct E_x_Q_window_Z *window
, N child_n
, N x
, N y
, N width
, N height
, void
  (*draw)(
    struct E_x_Q_display_Z *
  , struct E_x_Q_screen_Z *
  , struct E_x_Q_window_Z *
  , struct E_x_Q_object_Z *
  )
, void
  (*click)(
    struct E_x_Q_window_Z *
  , struct E_x_Q_object_Z *
  , N8 button
  , N8 seq
  )
){  I object_id = E_mem_Q_tab_I_add( window->object );
    struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->draw = draw;
    object->click = click;
    object->child_n = child_n;
    Mt_( object->child, child_n );
    object->data = 0;
    object->x = x;
    object->y = y;
    object->width = width;
    object->height = height;
    U_L( object->mode, lay_height );
    U_F( object->mode, draggable );
    U_L( object->mode, drag_src );
    U_R( object->req, draw );
    return object_id;
}
void
E_x_Q_object_W(
  struct E_x_Q_display_Z *display
, struct E_x_Q_window_Z *window
, I object_id
){  struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    if( object->data )
        W( object->data );
    W( object->child );
    E_mem_Q_tab_I_rem( window->object, object_id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
B
E_x_Q_object_R_top( struct E_x_Q_window_Z *window
, I id
){  for_each( object_id, window->object, E_mem_Q_tab )
    {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
        for_n( child_i, object->child_n )
        {   if( object->child[ child_i ] == id )
                return no;
        }
    }
    return yes;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_x_Q_object_I_add( struct E_x_Q_window_Z *window
, I id
, I child_id
){  struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    if( !E_mem_Q_blk_I_append( &object->child, 1 ))
        return ~0;
    object->child[ object->child_n ] = child_id;
    object->child_n++;
    return 0;
}
//------------------------------------------------------------------------------
N
E_x_Q_object_I_rem( struct E_x_Q_window_Z *window
, I id
){  for_each( object_id, window->object, E_mem_Q_tab )
    {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
        for_n( child_i, object->child_n )
        {   if( object->child[ child_i ] == id )
            {   E_mem_Q_blk_I_rem( &object->child, child_i, 1 );
                object->child_n--;
                struct E_x_Q_object_Z *object_rem = E_mem_Q_tab_R( window->object, id );
                if( object_rem->child_n )
                {   if( !E_mem_Q_blk_I_append( &object->child, object_rem->child_n ))
                        return ~0;
                    E_mem_Q_blk_I_copy_rev( &object->child[ child_i ] + object_rem->child_n, &object->child[ child_i ], ( object->child_n - child_i ) * sizeof( object->child[0] ));
                    for_n( i, object_rem->child_n )
                        object->child[ child_i + i ] = object_rem->child[i];
                    object->child_n += object_rem->child_n;
                }
                goto End;
            }
        }
    }
End:E_mem_Q_tab_I_rem( window->object, id );
    return 0;
}
N
E_x_Q_object_I_rem_descendants( struct E_x_Q_window_Z *window
, I id
){  struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    N ids_n = object->child_n;
    I * Mt_( ids, ids_n );
    if( !ids )
        return ~0;
    for_n( child_i, object->child_n )
        ids[ child_i ] = object->child[ child_i ];
    E_mem_Q_blk_I_rem( &object->child, 0, object->child_n );
    object->child_n = 0;
    for_n( ids_i, ids_n )
    {   object = E_mem_Q_tab_R( window->object, ids[ ids_i ] );
        if( !E_mem_Q_blk_I_append( &ids, object->child_n ))
            return ~0;
        for_n( child_i, object->child_n )
            ids[ ids_n + child_i ] = object->child[ child_i ];
        ids_n += object->child_n;
    }
    for_n_( ids_i, ids_n )
        E_mem_Q_tab_I_rem( window->object, ids[ ids_i ] );
    W(ids);
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_x_Q_object_I_draw_P_color(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_object_Z *object
, N32 color
){  if( !U_R( object->mode, drag_src ))
        E_x_Q_window_I_draw_P_color( display, screen, color );
}
//------------------------------------------------------------------------------
void
E_x_Q_object_I_fill_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_point_t *points
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    E_x_Q_window_I_fill_Z_points( display, screen, window, n, points );
}
void
E_x_Q_object_I_draw_Z_points(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_point_t *points
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    E_x_Q_window_I_draw_Z_points( display, screen, window, n, points );
}
void
E_x_Q_object_I_draw_Z_segments(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_segment_t *segments
){  for_n( i, n )
    {   segments[i].x1 += object->x;
        segments[i].y1 += object->y;
        segments[i].x2 += object->x;
        segments[i].y2 += object->y;
    }
    E_x_Q_window_I_draw_Z_segments( display, screen, window, n, segments );
}
void
E_x_Q_object_I_draw_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_point_t *points
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    E_x_Q_window_I_draw_Z_lines( display, screen, window, n, points );
}
void
E_x_Q_object_I_draw_Z_rectangles(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_rectangle_t *rectangles
){  for_n( i, n )
    {   rectangles[i].x += object->x;
        rectangles[i].y += object->y;
    }
    E_x_Q_window_I_draw_Z_rectangles( display, screen, window, n, rectangles );
}
void
E_x_Q_object_I_draw_Z_arcs(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N32 n
, xcb_arc_t *arcs
){  for_n( i, n )
    {   arcs[i].x += object->x;
        arcs[i].y += object->y;
    }
    E_x_Q_window_I_draw_Z_arcs( display, screen, window, n, arcs );
}
void
E_x_Q_object_I_draw_aa_Z_line(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N n
, xcb_point_t *points
, N32 color
, F thickness
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    E_x_Q_window_I_draw_aa_Z_line( display, screen, window, n, points, thickness, color );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_x_Q_object_I_lay(
  struct E_x_Q_display_Z *display
, struct E_x_Q_window_Z *window
){  if( !E_mem_Q_tab_R_n( window->object ))
        return 0;
    struct Z_stack
    { struct E_x_Q_object_Z *object;
      N i;
    };
    struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, 0 );
    if( object->child_n )
    {   for_each( id, window->object, E_mem_Q_tab )
        {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
            U_L( object->mode, lay_height );
        }
Restart:;
        struct Z_stack *stack = Mt( sizeof( struct Z_stack ), 0 );
        if( !stack )
            return ~0;
        N stack_i = ~0;
        S16 next_x = E_x_Q_object_S_layout_dx;
        S16 next_y = E_x_Q_object_S_layout_dy;
        S16 after_x = E_x_Q_object_S_layout_dx;
        S16 after_y = E_x_Q_object_S_layout_dy;
        O{  if( object->child_n )
            {   if( ~stack_i )
                    if( U_R( object->mode, lay_height ))
                    {   next_x = stack[ stack_i ].object->x + E_x_Q_object_S_layout_dx;
                        after_x = next_x + E_x_Q_object_S_layout_dx;
                        next_y = after_y;
                        after_y += E_x_Q_object_S_layout_dy;
                    }else
                        after_y = next_y + E_x_Q_object_S_layout_dy;
                struct Z_stack *stack_top = E_mem_Q_blk_I_append( &stack, 1 );
                if( !stack_top )
                {   W(stack);
                    return ~0;
                }
                stack_i++;
                stack_top->object = object;
                stack_top->i = 0;
                object->x = next_x;
                object->y = next_y;
                object->width = E_x_Q_object_S_layout_dx;
                object->height = E_x_Q_object_S_layout_dy;
                next_x += E_x_Q_object_S_layout_dx;
                if( next_x > window->width
                && !U_R( object->mode, lay_height )
                ){  U_F( object->mode, lay_height );
                    do
                    {   object = stack[ stack_i ].object;
                    }while( ~--stack_i
                    && !stack[ stack_i ].i
                    );
                    U_F( object->mode, lay_height );
                    W(stack);
                    object = E_mem_Q_tab_R( window->object, 0 );
                    goto Restart;
                }
                next_y += E_x_Q_object_S_layout_dy;
                object = E_mem_Q_tab_R( window->object, object->child[0] );
                continue;
            }
            if( stack[ stack_i ].i != stack[ stack_i ].object->child_n )
            {   stack[ stack_i ].i++;
                if( U_R( object->mode, lay_height )
                && stack[ stack_i ].i != 1
                ){  next_x = stack[ stack_i ].object->x + E_x_Q_object_S_layout_dx;
                    next_y = after_y;
                }
                object->x = next_x;
                object->y = next_y;
                if( after_x < next_x + object->width + E_x_Q_object_S_layout_dx )
                    after_x = next_x + object->width + E_x_Q_object_S_layout_dx;
                if( after_y < next_y + object->height + E_x_Q_object_S_layout_dy )
                    after_y = next_y + object->height + E_x_Q_object_S_layout_dy;
                struct E_x_Q_object_Z *object_ = object;
                N stack_i_ = stack_i;
                N16 after_x_ = after_x;
                N16 after_y_ = after_y;
                do
                {   object_ = stack[ stack_i_ ].object;
                    if( object_->width < after_x_ - object_->x )
                        object_->width = after_x_ - object_->x;
                    if( object_->height < after_y_ - object_->y )
                        object_->height = after_y_ - object_->y;
                    after_x_ += E_x_Q_object_S_layout_dx;
                    after_y_ += E_x_Q_object_S_layout_dy;
                }while( ~--stack_i_ );
                next_x += object->width + E_x_Q_object_S_layout_dx;
                if( next_x > window->width
                && !U_R( object->mode, lay_height )
                ){  U_F( object->mode, lay_height );
                    if( stack[ stack_i ].i == 1 )
                    {   do
                        {   object = stack[ stack_i ].object;
                        }while( ~--stack_i
                        && !stack[ stack_i ].i
                        );
                        U_F( object->mode, lay_height );
                    }
                    W(stack);
                    object = E_mem_Q_tab_R( window->object, 0 );
                    goto Restart;
                }
                if( stack[ stack_i ].i != stack[ stack_i ].object->child_n )
                {   object = E_mem_Q_tab_R( window->object, stack[ stack_i ].object->child[ stack[ stack_i ].i ] );
                    continue;
                }
            }
            N stack_i_1 = stack_i;
            do
            {   next_x = stack[ stack_i ].object->x + stack[ stack_i ].object->width + E_x_Q_object_S_layout_dx;
                if( next_x > window->width
                && !U_R( stack[ stack_i ].object->mode, lay_height )
                ){  U_F( stack[ stack_i ].object->mode, lay_height );
                    N stack_i_ = stack_i;
                    O{  if( object->child_n )
                        {   struct Z_stack *stack_top = E_mem_Q_blk_I_append( &stack, 1 );
                            if( !stack_top )
                            {   W(stack);
                                return ~0;
                            }
                            stack_i_++;
                            stack_top->object = object;
                            stack_top->i = object->child_n;
                            object = E_mem_Q_tab_R( window->object, object->child[ stack_top->i - 1 ] );
                            continue;
                        }
                        if( ~stack[ stack_i_ ].i )
                        {   stack[ stack_i_ ].i--;
                            U_L( object->mode, lay_height );
                            if( ~stack[ stack_i_ ].i )
                            {   object = E_mem_Q_tab_R( window->object, stack[ stack_i_ ].object->child[ stack[ stack_i_ ].i ] );
                                continue;
                            }
                        }
                        N stack_i_1 = stack_i_;
                        do
                        {   if( stack_i_ == stack_i )
                                goto Cont;
                            U_L( stack[ stack_i_ ].object->mode, lay_height );
                            stack_i_--;
                            if( ~stack[ stack_i_ ].i )
                                stack[ stack_i_ ].i--;
                        }while( !~stack[ stack_i_ ].i );
                        E_mem_Q_blk_I_rem( &stack, stack_i_ + 1, stack_i_1 - stack_i_ );
                        object = E_mem_Q_tab_R( window->object, stack[ stack_i_ ].object->child[ stack[ stack_i_ ].i ] );
                    }
Cont:               do
                    {   object = stack[ stack_i ].object;
                    }while( ~--stack_i
                    && !stack[ stack_i ].i
                    );
                    U_F( object->mode, lay_height );
                    W(stack);
                    object = E_mem_Q_tab_R( window->object, 0 );
                    goto Restart;
                }
                next_y -= E_x_Q_object_S_layout_dy;
                if( after_y < stack[ stack_i ].object->y + stack[ stack_i ].object->height + E_x_Q_object_S_layout_dy )
                    after_y = stack[ stack_i ].object->y + stack[ stack_i ].object->height + E_x_Q_object_S_layout_dy;
            }while( ~--stack_i
            && ++stack[ stack_i ].i == stack[ stack_i ].object->child_n
            );
            if( !~stack_i )
                break;
            E_mem_Q_blk_I_rem( &stack, stack_i + 1, stack_i_1 - stack_i );
            object = E_mem_Q_tab_R( window->object, stack[ stack_i ].object->child[ stack[ stack_i ].i ] );
        }
        W(stack);
    }
    return 0;
}
//------------------------------------------------------------------------------
I
E_x_Q_object_Z_button_M(
  struct E_x_Q_display_Z *display
, struct E_x_Q_window_Z *window
){  return E_x_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 40
    , 30
    , E_x_Q_object_Z_button_I_draw
    , E_x_Q_object_Z_button_I_click
    );
}
void
E_x_Q_object_Z_button_I_draw(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
){  E_x_Q_object_I_draw_P_color_( E_x_theme_Q_theme.line );
    E_x_Q_object_I_draw_Z_rectangles_((
      ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width
        , .height = object->height
        }
      }
    ));
    E_x_Q_object_I_draw_P_color_( E_x_theme_Q_theme.object_bg );
    E_x_Q_object_I_fill_Z_points_((
      ( xcb_point_t[] )
      { { 1, 1 }
      , { object->width - 1, 1 }
      , { object->width - 1, object->height - 1 }
      , { 1, object->height - 1 }
      }
    ));
}
void
E_x_Q_object_Z_button_I_click(
  struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N8 button
, N8 seq
){  if( button == 1 && seq == 2 )
    {   G();
    }
}
//------------------------------------------------------------------------------
I
E_x_Q_object_Z_text_field_M(
  struct E_x_Q_display_Z *display
, struct E_x_Q_window_Z *window
){  return E_x_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 40
    , 30
    , E_x_Q_object_Z_text_field_I_draw
    , 0
    );
}
void
E_x_Q_object_Z_text_field_I_draw(
  struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
){  E_x_Q_object_I_draw_P_color_( E_x_theme_Q_theme.line );
    E_x_Q_object_I_draw_Z_rectangles_((
      ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width
        , .height = object->height
        }
      }
    ));
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_x_Q_object_I_draw( void (*draw_object_proc)( struct E_x_Q_display_Z *, struct E_x_Q_screen_Z *, struct E_x_Q_window_Z *, struct E_x_Q_object_Z * )
){  X_A( x_object, draw );
    for_each( display_id, E_x_Q_display_S, E_mem_Q_tab )
    {   struct E_x_Q_display_Z *display = E_mem_Q_tab_R( E_x_Q_display_S, display_id );
        for_each( window_id, display->window, E_mem_Q_tab )
        {   struct E_x_Q_window_Z *window = E_mem_Q_tab_R( display->window, window_id );
            for_each( object_id, window->object, E_mem_Q_tab )
            {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                if( object->draw == draw_object_proc )
                {   U_F( object->req, draw );
                    U_F( x_object, draw );
                }
            }
        }
        if( U_R( display->mode, drag ))
        {   struct E_x_Q_screen_Z *screen = E_mem_Q_tab_R( display->screen, display->drag_S_dnd_window_screen_id );
            struct E_x_Q_window_Z *window = &screen->dnd_window;
            for_each( object_id, window->object, E_mem_Q_tab )
            {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                if( object->draw == draw_object_proc )
                {   U_F( object->req, draw );
                    U_F( x_object, draw );
                }
            }
        }
    }
    X_U( x_object, draw );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
D( x_object, draw )
{   X_M( x_object, draw );
    X_A( x_window, draw );
    I_D
    {   X_B( x_object, draw, 0 )
            break;
        for_each( display_id, E_x_Q_display_S, E_mem_Q_tab )
        {   B U_L( display, draw );
            struct E_x_Q_display_Z *display = E_mem_Q_tab_R( E_x_Q_display_S, display_id );
            for_each( window_id, display->window, E_mem_Q_tab )
            {   struct E_x_Q_window_Z *window = E_mem_Q_tab_R( display->window, window_id );
                B U_L( window, draw );
                for_each( object_id, window->object, E_mem_Q_tab )
                {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                    if( U_E( object->req, draw ))
                        U_F( window, draw );
                }
                if( U_R( window, draw ))
                {   U_F( window->req, draw );
                    U_F( display, draw );
                }
            }
            if( U_R( display->mode, drag ))
            {   struct E_x_Q_screen_Z *screen = E_mem_Q_tab_R( display->screen, display->drag_S_dnd_window_screen_id );
                struct E_x_Q_window_Z *window = &screen->dnd_window;
                B U_L( window, draw );
                for_each( object_id, window->object, E_mem_Q_tab )
                {   struct E_x_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                    if( U_E( object->req, draw ))
                        U_F( window, draw );
                }
                if( U_R( window, draw ))
                {   U_F( window->req, draw );
                    U_F( display, draw );
                }
            }
            if( U_R( display, draw ))
            {   U_F( display->req, draw );
                U_F( x_window, draw );
            }
        }
        X_U( x_window, draw );
    }
    X_W( x_object, draw );
}
/******************************************************************************/
