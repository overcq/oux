/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  component
*   ---   ‟X window”
*         bitmap font manager
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”            2019‒11‒23 V
*******************************************************************************/
struct E_x_Q_font_Z
{ Pc name;
  N height;
  N bitmaps_n;
  struct E_x_Q_font_Z_bitmap *bitmaps;
};
struct E_x_Q_font_Z_bitmap
{ U u;
  N width;
  N16 *bitmap;
};
//==============================================================================
struct E_mem_Q_tab_Z *E_x_Q_font_S;
//==============================================================================
N
E_x_Q_font_Q_window_I_draw( I id
, U u
, struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N x
, N y
, N color
){  struct E_x_Q_font_Z *font = E_mem_Q_tab_R( E_x_Q_font_S, id );
    for_n( i, font->bitmaps_n )
        if( font->bitmaps[i].u == u )
        {   N j = 0;
            C c;
            N x_, y_ = y;
            for_n( font_y, font->height )
            {   x_ = x;
                for_n( font_x, font->bitmaps[i].width )
                {   if( j % 4 == 0 )
                        c = font->bitmaps[i].bitmap[ j / 4 ];
                    if(( c >> ( j % 4 * 2 )) & 3 )
                    {   F brightness;
                        switch(( c >> ( j % 4 * 2 )) & 3 )
                        { case 1:
                              brightness = (F)( (N8)~0 >> 2 ) / (N8)~0;
                              break;
                          case 2:
                              brightness = (F)( (N8)~0 >> 1 ) / (N8)~0;
                              break;
                          case 3:
                              brightness = 1;
                              break;
                        }
                        E_x_Q_window_I_draw_aa_Z_pixel( display, screen, window
                        , x_, y_
                        , color
                        , brightness
                        , 0
                        );
                    }
                    x_++;
                    j++;
                }
                y_++;
            }
            return 0;
        }
    return ~0;
}
N
E_x_Q_font_Q_window_I_draw_Z_s( I id
, Pc s
, struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, N x
, N y
, N color
){  struct E_x_Q_font_Z *font = E_mem_Q_tab_R( E_x_Q_font_S, id );
    U u;
    do
    {   Pc s_ = E_text_Z_s_Z_utf8_R_u( s, &u );
        if( s_ == s )
        {   GV( "bad UTF-8 character" );
            return ~0;
        }
        if( E_x_Q_font_Q_window_I_draw( id, u, display, screen, window, x, y, color ))
            return ~0;
        s = s_;
        for_n( i, font->bitmaps_n )
            if( font->bitmaps[i].u == u )
            {   x += font->bitmaps[i].width + 1;
                break;
            }
    }while( *s );
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_x_Q_font_Q_object_I_draw( I id
, U u
, struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N x
, N y
, N color
){  return E_x_Q_window_I_draw_Z_font_( id, u
    , object->x + x
    , object->y + y
    , color
    );
}
N
E_x_Q_font_Q_object_I_draw_Z_s( I id
, Pc s
, struct E_x_Q_display_Z *display
, struct E_x_Q_screen_Z *screen
, struct E_x_Q_window_Z *window
, struct E_x_Q_object_Z *object
, N x
, N y
, N color
){  return E_x_Q_window_I_draw_Z_font_Z_s_( id, s
    , object->x + x
    , object->y + y
    , color
    );
}
/******************************************************************************/
