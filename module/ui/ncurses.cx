//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   user interface
*         ncurses frontend
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”             2022‒6‒10 Q
*******************************************************************************/
struct E_ncurses_Q_field_Z
{ int x, y;
};
//==============================================================================
int E_ncurses_I_getch_S_ret;
wint_t E_ncurses_I_getch_S_c;
B E_ncurses_I_getch_S_meta_key;
SCREEN *E_ncurses_S_screen;
int E_ncurses_S_scroll_x, E_ncurses_S_scroll_y;
int E_ncurses_S_scroll_max_x, E_ncurses_S_scroll_max_y;
struct E_mem_Q_tab_Z *E_ncurses_Q_layout_S;
//==============================================================================
void
E_ncurses_I_lay( void
){  erase();
    E_ncurses_S_scroll_max_x = E_ncurses_S_scroll_max_y = 0;
    int x = 0, y = 0;
    int cur_x = 0;
    int max_x, max_y;
    getmaxyx( stdscr, max_y, max_x );
    max_x -= 2;
    max_y -= 2;
    if( max_x - x > 0
    && max_y - y > 0
    && E_mem_Q_tab_R_n( E_data_Q_layout_S )
    )
    {   int focus_x_0 = ~0, focus_x, focus_y;
        move( y, x );
        B not_first = no, not_first_visible = no;;
        for_each( input_id, E_data_Q_layout_S, E_mem_Q_tab )
        {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, input_id );
            N l = E_text_Z_su0_R_n( input->label );
            if( not_first )
            {   if( cur_x + 1 + l + 1 + ( input->select_n ? 1 : 0 ) + input->width > max_x )
                {   if( E_ncurses_S_scroll_max_x < x )
                        E_ncurses_S_scroll_max_x = x;
                    x = 0;
                    if( not_first_visible )
                    {   cur_x = 0;
                        move( getcury(stdscr) + 1, cur_x );
                    }
                }else
                {   y--; // Wycofanie nowej linii.
                    x++; // Odstęp przed następną etykietą.
                    if( y >= E_ncurses_S_scroll_y
                    && getcury(stdscr) <= max_y
                    )
                    {   if( x >= E_ncurses_S_scroll_x
                        && cur_x <= max_x
                        )
                            cur_x++;
                        move( getcury(stdscr), cur_x );
                    }
                }
            }
            struct E_ncurses_Q_field_Z *data = E_mem_Q_tab_R( E_ncurses_Q_layout_S, input_id );
            data->x = x;
            data->y = y;
            if( y >= E_ncurses_S_scroll_y
            && getcury(stdscr) <= max_y
            )
                not_first_visible = yes;
            not_first = yes;
            Pc s = input->label;
            for( N i = 0; *s; i++ )
            {   U u;
                s = E_text_Z_s_Z_utf8_R_u( s, &u );
                if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = { u, L'\0' };
                    setcchar( &cc, &wc[0], A_NORMAL, 1, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
                x++;
            }
            x++; // Odstęp pomiędzy etykietą a polem.
            if( y >= E_ncurses_S_scroll_y
            && getcury(stdscr) <= max_y
            && x >= E_ncurses_S_scroll_x
            )
            {   if( cur_x <= max_x )
                    cur_x++;
                if( cur_x <= max_x )
                    move( getcury(stdscr), cur_x );
            }
            if( input->select_n )
            {   if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   add_wch( !~E_data_Q_layout_S_focus_select ? WACS_DARROW : WACS_UARROW );
                    cur_x++;
                }
                x++;
            }
            s = input->s;
            l = E_text_Z_su0_R_n( input->s );
            N width = input->width;
            if( input_id == E_data_Q_layout_S_focus )
            {   focus_y = y;
                focus_x_0 = focus_x = x;
                if( E_data_Q_layout_S_focus_x < width )
                {   focus_x += E_data_Q_layout_S_focus_x;
                    if( l > width )
                        width--; // Miejsce na strzałkę na końcu.
                }else
                {   if( y >= E_ncurses_S_scroll_y
                    && getcury(stdscr) <= max_y
                    && x >= E_ncurses_S_scroll_x
                    && cur_x <= max_x
                    )
                    {   add_wch( WACS_LARROW );
                        cur_x++;
                    }
                    x++;
                    width--; // Miejsce na strzałkę na początku.
                    if( l > width
                    && E_data_Q_layout_S_focus_x < l - width
                    )
                        width--; // Miejsce na strzałkę na końcu.
                    N after = l - E_data_Q_layout_S_focus_x;
                    if( after > width )
                        after = width;
                    focus_x += width - after;
                    if( focus_x < x )
                        focus_x = x;
                    s += input->s_i;
                    for( int i = x; i != focus_x; i++ )
                    {   U u;
                        s = E_text_Z_s_Z_utf8_R_u_rev( s, &u );
                    }
                    if( y >= E_ncurses_S_scroll_y
                    && getcury(stdscr) <= max_y
                    && x >= E_ncurses_S_scroll_x
                    && cur_x <= max_x
                    )
                        for( int i = x; i != focus_x; i++ )
                        {   U u;
                            s = E_text_Z_s_Z_utf8_R_u( s, &u );
                            cchar_t cc;
                            wchar_t wc[2] = { u, L'\0' };
                            setcchar( &cc, &wc[0], A_NORMAL, 2, 0 );
                            add_wch( &cc );
                            cur_x++;
                        }
                    width -= focus_x - x;
                    x += focus_x - x;
                }
            }else if( l > width )
            {   if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   add_wch( WACS_LARROW );
                    cur_x++;
                }
                x++;
                width--; // Miejsce na strzałkę na początku.
                if( l > width )
                    width--; // Miejsce na strzałkę na końcu.
            }
            N i;
            for( i = 0; *s && i != width; i++ )
            {   U u;
                s = E_text_Z_s_Z_utf8_R_u( s, &u );
                if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = { u, L'\0' };
                    setcchar( &cc, &wc[0], A_NORMAL, 2, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
                x++;
            }
            x += width - i;
            for( ; i != width; i++ )
            {   if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = L" ";
                    setcchar( &cc, &wc[0], A_NORMAL, 2, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
            }
            if( l > width
            && E_data_Q_layout_S_focus_x < l - width
            )
            {   if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   add_wch( WACS_RARROW );
                    cur_x++;
                }
                x++;
            }
            y++;
        }
        if( E_ncurses_S_scroll_max_x < x )
            E_ncurses_S_scroll_max_x = x;
        E_ncurses_S_scroll_max_y = y;
        max_x++;
        max_y++;
        if( E_ncurses_S_scroll_max_x < max_x )
            E_ncurses_S_scroll_max_x = max_x;
        if( E_ncurses_S_scroll_max_y < max_y )
            E_ncurses_S_scroll_max_y = max_y;
        int pos_x = round( (F)E_ncurses_S_scroll_x * max_x / E_ncurses_S_scroll_max_x );
        int pos_y = round( (F)E_ncurses_S_scroll_y * max_y / E_ncurses_S_scroll_max_y );
        int len_x = round( (F)max_x * max_x / E_ncurses_S_scroll_max_x );
        int len_y = round( (F)max_y * max_y / E_ncurses_S_scroll_max_y );
        move( max_y, 0 );
        for( int x = 0; x != max_x; x++ )
            add_wch( x < pos_x || x >= pos_x + len_x ? WACS_HLINE : WACS_BLOCK );
        add_wch( WACS_LRCORNER );
        for( int y = 0; y != max_y; y++ )
            mvadd_wch( y, max_x, y < pos_y || y >= pos_y + len_y ? WACS_VLINE : WACS_BLOCK );
        if( ~focus_x_0
        && focus_y >= E_ncurses_S_scroll_y
        && focus_y - E_ncurses_S_scroll_y < max_y
        && focus_x >= E_ncurses_S_scroll_x
        && focus_x - E_ncurses_S_scroll_x < max_x
        )
            move( focus_y - E_ncurses_S_scroll_y, focus_x - E_ncurses_S_scroll_x );
    }
    refresh();
}
//==============================================================================
_internal
void
E_ncurses_I_focus_internal( void
){  struct E_ncurses_Q_field_Z *data = E_mem_Q_tab_R( E_ncurses_Q_layout_S, E_data_Q_layout_S_focus );
    struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
    if( data->x < E_ncurses_S_scroll_x
    || data->x >= E_ncurses_S_scroll_x + getmaxx(stdscr) - 1
    )
        E_ncurses_S_scroll_x = data->x + E_text_Z_su0_R_n( input->label ) + 1 + ( input->select_n ? 1 : 0 ) + input->width < getmaxx(stdscr)
        ? 0
        : data->x < E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 )
          ? data->x
          : E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 );
    if( data->y < E_ncurses_S_scroll_y
    || data->y >= E_ncurses_S_scroll_y + getmaxy(stdscr) - 1
    )
        E_ncurses_S_scroll_y = data->y < E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 )
        ? data->y
        : E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 );
    E_data_Q_layout_S_focus_x = 0;
    E_data_Q_layout_S_focus_select = ~0;
    E_ncurses_I_lay();
}
B
E_ncurses_I_sigsuspend( sigset_t *sigset
){  sigset_t old_sigset;
    _sigprocmask( SIG_SETMASK, sigset, &old_sigset ); //NDFN dopóki jest tak zrobione, że odblokowanie “sygnałów” jest wcześniej niż zablokowanie na “read”, to mogą występować przypadki zablokowania oczekującego na “read” mimo “sygnału” (ustawiającego “wake”) obsłużonego i danych czekających na przetworzenie w ‹zadaniach›, a gdy nie jest ustawione “E_flow_Q_system_unblock_report_S_setitimer_I”, to oczywiście– nieodblokowania po ustawionym czasie —do czasu ‹systemowego raportu odblokowującego› lub nietrafienia któregoś interpretowanego (ustawiającego “wake”) “sygnału” w obszar programu pomiędzy tym “sigprocmask” a “read” w “E_flow_Q_system_unblock_report_S_sigsuspend_I”.
    E_ncurses_I_getch_S_ret = get_wch( &E_ncurses_I_getch_S_c );
    _sigprocmask( SIG_SETMASK, &old_sigset, 0 );
    return E_ncurses_I_getch_S_ret != ERR; // Naciśnięto klawisz.
}
void
E_ncurses_I_setitimer( Z_clock_time *tv
){
#ifndef E_flow_drv_C_clock_monotonic
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999 ) / 1000 );
#else
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999999 ) / 1000000 );
#endif
}
D( ncurses, getch )
{   Xh1_M( &E_ncurses_I_sigsuspend, &E_ncurses_I_setitimer );
    I_D
    {   Xh1_B()
            break;
        switch( E_ncurses_I_getch_S_ret )
        { case KEY_CODE_YES:
                if( E_ncurses_I_getch_S_meta_key )
                {   switch( E_ncurses_I_getch_S_c )
                    { case KEY_DC:
                            break;
                      case KEY_RIGHT:
                        {   break;
                        }
                      case KEY_LEFT:
                        {   break;
                        }
                      case KEY_A1: // “KEY_HOME” na klawiaturze numerycznej.
                            if( E_ncurses_S_scroll_max_x )
                            {   E_ncurses_S_scroll_x = 0;
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_C1: // “KEY_END” na klawiaturze numerycznej.
                            if( E_ncurses_S_scroll_max_x )
                            {   E_ncurses_S_scroll_x = E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 );
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_NPAGE:
                      case KEY_C3: // “KEY_NPAGE” na klawiaturze numerycznej.
                            if( E_ncurses_S_scroll_max_x )
                            {   if( E_ncurses_S_scroll_max_x - E_ncurses_S_scroll_x > 2 * ( getmaxx(stdscr) - 1 ))
                                    E_ncurses_S_scroll_x += getmaxx(stdscr) - 1;
                                else
                                    E_ncurses_S_scroll_x = E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 );
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_PPAGE:
                      case KEY_A3: // “KEY_PPAGE” na klawiaturze numerycznej.
                            if( E_ncurses_S_scroll_max_x )
                            {   if( E_ncurses_S_scroll_x > getmaxx(stdscr) - 1 )
                                    E_ncurses_S_scroll_x -= getmaxx(stdscr) - 1;
                                else
                                    E_ncurses_S_scroll_x = 0;
                                E_ncurses_I_lay();
                            }
                            break;
                      default:
                        {   beep();
                            G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                            break;
                        }
                    }
                    E_ncurses_I_getch_S_meta_key = no;
                    break;
                }
                switch( E_ncurses_I_getch_S_c )
                { case KEY_MOUSE:
                        if( E_ncurses_S_scroll_max_x )
                        {   MEVENT ev;
                            getmouse( &ev );
                            if( ev.bstate & BUTTON1_CLICKED )
                                if( ev.y == getmaxy(stdscr) - 1
                                && ev.x != getmaxx(stdscr) - 1
                                )
                                {   int max_x = getmaxx(stdscr) - 1;
                                    int len_x = round( (F)max_x * max_x / E_ncurses_S_scroll_max_x );
                                    int E_ncurses_S_scroll_x_ = round(( (F)ev.x - 0.5 * len_x ) * E_ncurses_S_scroll_max_x / max_x );
                                    if( E_ncurses_S_scroll_x_ < 0 )
                                        E_ncurses_S_scroll_x_ = 0;
                                    else if( E_ncurses_S_scroll_x_ > E_ncurses_S_scroll_max_x - max_x )
                                        E_ncurses_S_scroll_x_ = E_ncurses_S_scroll_max_x - max_x;
                                    if( E_ncurses_S_scroll_x != E_ncurses_S_scroll_x_ )
                                    {   E_ncurses_S_scroll_x = E_ncurses_S_scroll_x_;
                                        E_ncurses_I_lay();
                                    }
                                }else if( ev.x == getmaxx(stdscr) - 1
                                && ev.y != getmaxy(stdscr) - 1
                                )
                                {   int max_y = getmaxy(stdscr) - 1;
                                    int len_y = round( (F)max_y * max_y / E_ncurses_S_scroll_max_y );
                                    int E_ncurses_S_scroll_y_ = round(( (F)ev.y - 0.5 * len_y ) * E_ncurses_S_scroll_max_y / max_y );
                                    if( E_ncurses_S_scroll_y_ < 0 )
                                        E_ncurses_S_scroll_y_ = 0;
                                    else if( E_ncurses_S_scroll_y_ > E_ncurses_S_scroll_max_y - max_y )
                                        E_ncurses_S_scroll_y_ = E_ncurses_S_scroll_max_y - max_y;
                                    if( E_ncurses_S_scroll_y != E_ncurses_S_scroll_y_ )
                                    {   E_ncurses_S_scroll_y = E_ncurses_S_scroll_y_;
                                        E_ncurses_I_lay();
                                    }
                                }else if( ev.x != getmaxx(stdscr) - 1
                                && ev.y != getmaxy(stdscr) - 1
                                )
                                {   for_each( input_id, E_ncurses_Q_layout_S, E_mem_Q_tab )
                                    {   struct E_ncurses_Q_field_Z *data = E_mem_Q_tab_R( E_ncurses_Q_layout_S, input_id );
                                        struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, input_id );
                                        if( ev.y == data->y - E_ncurses_S_scroll_y
                                        && (( ev.x >= data->x - E_ncurses_S_scroll_x
                                            && ev.x < data->x - E_ncurses_S_scroll_x + E_text_Z_su0_R_n( input->label ) + 1
                                          )
                                          || ( ev.x >= data->x - E_ncurses_S_scroll_x + E_text_Z_su0_R_n( input->label ) + 1 + ( input->select_n ? 1 : 0 )
                                            && ev.x < data->x - E_ncurses_S_scroll_x + E_text_Z_su0_R_n( input->label ) + 1 + ( input->select_n ? 1 : 0 ) + input->width
                                        )))
                                        {   E_data_Q_layout_S_focus = input_id;
                                            E_ncurses_I_focus_internal();
                                            break;
                                        }
                                    }
                                }
                            break;
                        }
                  case KEY_DC:
                        if( ~E_data_Q_layout_S_focus )
                        {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                            if( !~E_data_Q_layout_S_focus_select )
                            {   if( E_data_Q_field_P_remove_on(input) )
                                    E_ncurses_I_lay();
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_BACKSPACE:
                        if( ~E_data_Q_layout_S_focus )
                        {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                            if( !~E_data_Q_layout_S_focus_select )
                            {   if( E_data_Q_field_P_remove_back(input) )
                                {   E_data_Q_layout_S_focus_x--;
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_ENTER: // Na klawiaturze numerycznej.
                        E_ncurses_I_getch_S_c = '\r';
                        goto Enter;
                  case KEY_RIGHT:
                        if( ~E_data_Q_layout_S_focus )
                        {   if( !~E_data_Q_layout_S_focus_select )
                            {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                                if( E_data_Q_field_P_right(input) )
                                {   E_data_Q_layout_S_focus_x++;
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_LEFT:
                        if( ~E_data_Q_layout_S_focus )
                        {   if( !~E_data_Q_layout_S_focus_select )
                            {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                                if( E_data_Q_field_P_left(input) )
                                {   E_data_Q_layout_S_focus_x--;
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_DOWN:
                    {   break;
                    }
                  case KEY_UP:
                    {   break;
                    }
                  case KEY_BTAB:
                        if( E_ncurses_S_scroll_max_x )
                        {   if( ~E_data_Q_layout_S_focus
                            && E_data_Q_layout_S_focus
                            )
                                E_data_Q_layout_S_focus--;
                            else
                                E_data_Q_layout_S_focus = E_mem_Q_tab_R_n( E_data_Q_layout_S ) - 1;
                            E_ncurses_I_focus_internal();
                        }
                        break;
                  case KEY_HOME:
                        if( ~E_data_Q_layout_S_focus )
                        {   if( !~E_data_Q_layout_S_focus_select )
                            {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                                if( E_data_Q_field_P_left(input) )
                                {   do
                                    {   E_data_Q_layout_S_focus_x--;
                                    }while( E_data_Q_field_P_left(input) );
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_A1: // “KEY_HOME” na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   E_ncurses_S_scroll_y = 0;
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_END:
                        if( ~E_data_Q_layout_S_focus )
                        {   if( !~E_data_Q_layout_S_focus_select )
                            {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                                if( E_data_Q_field_P_right(input) )
                                {   do
                                    {   E_data_Q_layout_S_focus_x++;
                                    }while( E_data_Q_field_P_right(input) );
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                  case KEY_C1: // “KEY_END” na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   E_ncurses_S_scroll_y = E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 );
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_NPAGE:
                  case KEY_C3: // “KEY_NPAGE” na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   if( E_ncurses_S_scroll_max_y - E_ncurses_S_scroll_y > 2 * ( getmaxy(stdscr) - 1 ))
                                E_ncurses_S_scroll_y += getmaxy(stdscr) - 1;
                            else
                                E_ncurses_S_scroll_y = E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 );
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_PPAGE:
                  case KEY_A3: // “KEY_PPAGE” na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   if( E_ncurses_S_scroll_y > getmaxy(stdscr) - 1 )
                                E_ncurses_S_scroll_y -= getmaxy(stdscr) - 1;
                            else
                                E_ncurses_S_scroll_y = 0;
                            E_ncurses_I_lay();
                        }
                        break;
                  default:
                    {   beep();
                        G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                        break;
                    }
                }
                break;
          case OK:
                if( E_ncurses_I_getch_S_meta_key )
                {   switch( E_ncurses_I_getch_S_c )
                    { case 's':
                            break;
                    }
                    E_ncurses_I_getch_S_meta_key = no;
                    break;
                }
                switch( E_ncurses_I_getch_S_c )
                { case 3: // Ctrl+c

                        break;
                  case '\t':
                        if( E_ncurses_S_scroll_max_x )
                        {   if( ~E_data_Q_layout_S_focus
                            && E_data_Q_layout_S_focus + 1 != E_mem_Q_tab_R_n( E_data_Q_layout_S )
                            )
                                E_data_Q_layout_S_focus++;
                            else
                                E_data_Q_layout_S_focus = 0;
                            E_ncurses_I_focus_internal();
                        }
                        break;
                  case 17: // Ctrl+q
                        U_F( E_base_S->E_flow_S_signal, exit );
                        break;
                  case 19: // Ctrl+s
                        break;
                  case 27: // “meta” key
                        E_ncurses_I_getch_S_meta_key = yes;
                        break;
                  default:
                        if( !iswprint( E_ncurses_I_getch_S_c ))
                        {   beep();
                            G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                            break;
                        }
Enter:                  if( ~E_data_Q_layout_S_focus )
                        {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, E_data_Q_layout_S_focus );
                            if( !~E_data_Q_layout_S_focus_select )
                            {   if( E_data_Q_field_P_insert( input, E_ncurses_I_getch_S_c ))
                                {   E_data_Q_layout_S_focus_x++;
                                    E_ncurses_I_lay();
                                }
                            }else
                            {
                            }
                        }
                        break;
                }
                break;
        }
    }
    Xh1_W();
}
/******************************************************************************/
