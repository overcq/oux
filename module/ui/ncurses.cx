//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   user interface
*         ncurses frontend
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”             2022‒6‒10 Q
*******************************************************************************/
int E_ncurses_I_getch_S_ret;
wint_t E_ncurses_I_getch_S_c;
B E_ncurses_I_getch_S_meta_key;
SCREEN *E_ncurses_S_screen;
int E_ncurses_S_scroll_x, E_ncurses_S_scroll_y;
int E_ncurses_S_scroll_max_x, E_ncurses_S_scroll_max_y;
//==============================================================================
void
E_ncurses_M( void
){  E_ncurses_I_getch_S_meta_key = no;
    int tty_master, tty_slave;
    Pc tty_name = M(1024);
    V1_( openpty( &tty_master, &tty_slave, tty_name, 0, 0 ));
    pid_t pid = E_flow_I_fork_I_begin();
    if( !pid )
    {   E_flow_I_fork_I_start();
        N l = E_text_Z_n_N_s_G( tty_master, sizeof( tty_master ), 10 );
        Pc s = M( l + 1 );
        s[l] = '\0';
        E_text_Z_n_N_s( s + l, tty_master, sizeof( tty_master ), 10 );
        struct E_flow_Z_args args[1];
        args[0].argc = 3;
        args[0].argv = ( Pc [] ){ "urxvtc", "-pty-fd", s, 0 };
        E_flow_I_fork_I_exec( 0, args, 1 );
        W(s);
        l = 2 + E_text_Z_s0_R_l( tty_name ) + 1 + E_text_Z_n_N_s_G( tty_master, sizeof( tty_master ), 10 );
        s = M( l + 1 );
        s[l] = '\0';
        E_text_Z_n_N_s( s + l, tty_master, sizeof( tty_master ), 10 );
        E_text_Z_s_P_s0_copy( E_text_Z_s_P_s0_copy( E_text_Z_s_P_s0_copy( s, "-S" ), tty_name ), "/" );
        args[0].argv = ( Pc [] ){ "xterm", "-maximized", s, 0 };
        E_flow_I_fork_I_exec( 0, args, 1 );
    }
    E_flow_I_fork_I_end(pid);
    W( tty_name );
    setupterm( 0, STDERR_FILENO, 0 );
    int max_x, max_y;
    max_x = tigetnum( "cols" );
    max_y = tigetnum( "lines" );
    del_curterm( cur_term );
    FILE *file;
    Vp_( file = fdopen( tty_slave, "r+" ));
    Vp_( E_ncurses_S_screen = newterm( 0, file, file ));
    start_color();
    init_pair( 1, COLOR_WHITE, COLOR_BLACK ); // Label text.
    init_pair( 2, COLOR_BLACK, COLOR_WHITE ); // Field text.
    attr_set( A_NORMAL, 1, 0 );
    noecho();
    intrflush( stdscr, FALSE );
    keypad( stdscr, TRUE );
    nonl();
    notimeout( stdscr, TRUE );
    raw();
    idlok( stdscr, FALSE );
    idcok( stdscr, TRUE );
    immedok( stdscr, FALSE );
    leaveok( stdscr, FALSE );
    scrollok( stdscr, FALSE );
    resize_term( max_y, max_x );
    E_ncurses_S_scroll_y = E_ncurses_S_scroll_x = E_ncurses_S_scroll_max_x = E_ncurses_S_scroll_max_y = 0;
    D_M( ncurses, getch );
}
void
E_ncurses_W( void
){  D_W( ncurses, getch );
    endwin();
    delscreen( E_ncurses_S_screen );
}
//==============================================================================
void
E_ncurses_I_lay( void
){  erase();
    E_ncurses_S_scroll_max_x = E_ncurses_S_scroll_max_y = 0;
    int x = 0, y = 0;
    int cur_x = 0;
    int max_x, max_y;
    getmaxyx( stdscr, max_y, max_x );
    max_x -= 2;
    max_y -= 2;
    if( max_x - x > 0
    && max_y - y > 0
    && E_mem_Q_tab_R_n( E_data_Q_layout_S )
    )
    {   move( y, x );
        B not_first = no;
        for_each( input_id, E_data_Q_layout_S, E_mem_Q_tab )
        {   struct E_data_Q_field_Z *input = E_mem_Q_tab_R( E_data_Q_layout_S, input_id );
            N l = E_text_Z_su0_R_n( input->label );
            if( not_first )
            {   if( cur_x + 1 + l + 1 + input->width > max_x )
                {   if( E_ncurses_S_scroll_max_x < x )
                        E_ncurses_S_scroll_max_x = x;
                    cur_x = x = 0;
                }else
                {   y--; // Wycofanie nowej linii.
                    cur_x++;
                    x++; // Odstęp przed następną etykietą.
                    if( y >= E_ncurses_S_scroll_y
                    && getcury(stdscr) <= max_y
                    && cur_x <= max_x
                    )
                        move( getcury(stdscr), cur_x );
                }
            }
            not_first = yes;
            Pc s = input->label;
            for( N i = 0; *s; i++ )
            {   U u;
                s = E_text_Z_s_Z_utf8_R_u( s, &u );
                if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = { u, L'\0' };
                    setcchar( &cc, &wc[0], A_NORMAL, 1, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
                x++;
            }
            if( x >= E_ncurses_S_scroll_x
            && cur_x <= max_x
            )
            {   cur_x++;
                x++; // Odstęp pomiędzy etykietą a polem.
            }
            if( y >= E_ncurses_S_scroll_y
            && getcury(stdscr) + 1 <= max_y
            )
                move( getcury(stdscr), cur_x );
            s = input->s + input->s_i;
            N i;
            for( i = 0; *s && i != input->width; i++ )
            {   U u;
                s = E_text_Z_s_Z_utf8_R_u( s, &u );
                if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = { u, L'\0' };
                    setcchar( &cc, &wc[0], A_NORMAL, 2, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
                x++;
            }
            for( ; i != input->width; i++ )
            {   if( y >= E_ncurses_S_scroll_y
                && getcury(stdscr) <= max_y
                && x >= E_ncurses_S_scroll_x
                && cur_x <= max_x
                )
                {   cchar_t cc;
                    wchar_t wc[2] = L" ";
                    setcchar( &cc, &wc[0], A_NORMAL, 2, 0 );
                    add_wch( &cc );
                    cur_x++;
                }
                x++;
            }
            if( y >= E_ncurses_S_scroll_y
            && getcury(stdscr) <= max_y
            )
                move( getcury(stdscr) + 1, 0 );
            y++;
        }
        if( E_ncurses_S_scroll_max_x < x )
            E_ncurses_S_scroll_max_x = x;
        E_ncurses_S_scroll_max_y = y;
        max_x++;
        max_y++;
        if( E_ncurses_S_scroll_max_x < max_x )
            E_ncurses_S_scroll_max_x = max_x;
        if( E_ncurses_S_scroll_max_y < max_y )
            E_ncurses_S_scroll_max_y = max_y;
        int pos_x = E_ncurses_S_scroll_x * max_x / E_ncurses_S_scroll_max_x;
        int pos_y = E_ncurses_S_scroll_y * max_y / E_ncurses_S_scroll_max_y;
        int len_x = max_x * max_x / E_ncurses_S_scroll_max_x;
        int len_y = max_y * max_y / E_ncurses_S_scroll_max_y;
        move( max_y, 0 );
        for( int x = 0; x != max_x; x++ )
            add_wch( x < pos_x || x >= pos_x + len_x ? WACS_HLINE : WACS_BLOCK );
        add_wch( WACS_LRCORNER );
        for( int y = 0; y != max_y; y++ )
            mvadd_wch( y, max_x, y < pos_y || y >= pos_y + len_y ? WACS_VLINE : WACS_BLOCK );
    }
    refresh();
}
//==============================================================================
B
E_ncurses_I_sigsuspend( sigset_t *sigset
){  sigset_t old_sigset;
    _sigprocmask( SIG_SETMASK, sigset, &old_sigset ); //NDFN dopóki jest tak zrobione, że odblokowanie “sygnałów” jest wcześniej niż zablokowanie na “read”, to mogą występować przypadki zablokowania oczekującego na “read” mimo “sygnału” (ustawiającego “wake”) obsłużonego i danych czekających na przetworzenie w ‹zadaniach›, a gdy nie jest ustawione “E_flow_Q_system_unblock_report_S_setitimer_I”, to oczywiście– nieodblokowania po ustawionym czasie —do czasu ‹systemowego raportu odblokowującego› lub nietrafienia któregoś interpretowanego (ustawiającego “wake”) “sygnału” w obszar programu pomiędzy tym “sigprocmask” a “read” w “E_flow_Q_system_unblock_report_S_sigsuspend_I”.
    E_ncurses_I_getch_S_ret = get_wch( &E_ncurses_I_getch_S_c );
    _sigprocmask( SIG_SETMASK, &old_sigset, 0 );
    return E_ncurses_I_getch_S_ret != ERR; // Naciśnięto klawisz.
}
void
E_ncurses_I_setitimer( Z_clock_time *tv
){
#ifndef E_flow_drv_C_clock_monotonic
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999 ) / 1000 );
#else
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999999 ) / 1000000 );
#endif
}
D( ncurses, getch )
{   Xh1_M( &E_ncurses_I_sigsuspend, &E_ncurses_I_setitimer );
    I_D
    {   Xh1_B()
            break;
        switch( E_ncurses_I_getch_S_ret )
        { case KEY_CODE_YES:
                if( E_ncurses_I_getch_S_meta_key )
                {   switch( E_ncurses_I_getch_S_c )
                    { case KEY_DC:
                        {   break;
                        }
                      case KEY_RIGHT:
                        {   break;
                        }
                      case KEY_LEFT:
                        {   break;
                        }
                      case KEY_HOME:
                      case KEY_A1:
                            if( E_ncurses_S_scroll_max_x )
                            {   E_ncurses_S_scroll_x = 0;
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_END:
                      case KEY_C1:
                            if( E_ncurses_S_scroll_max_x )
                            {   E_ncurses_S_scroll_x = E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 );
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_NPAGE:
                      case KEY_C3:
                            if( E_ncurses_S_scroll_max_x )
                            {   if( E_ncurses_S_scroll_max_x - E_ncurses_S_scroll_x > 2 * ( getmaxx(stdscr) - 1 ))
                                    E_ncurses_S_scroll_x += getmaxx(stdscr) - 1;
                                else
                                    E_ncurses_S_scroll_x = E_ncurses_S_scroll_max_x - ( getmaxx(stdscr) - 1 );
                                E_ncurses_I_lay();
                            }
                            break;
                      case KEY_PPAGE:
                      case KEY_A3:
                            if( E_ncurses_S_scroll_max_x )
                            {   if( E_ncurses_S_scroll_x > getmaxx(stdscr) - 1 )
                                    E_ncurses_S_scroll_x -= getmaxx(stdscr) - 1;
                                else
                                    E_ncurses_S_scroll_x = 0;
                                E_ncurses_I_lay();
                            }
                            break;
                      default:
                        {   beep();
                            G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                            break;
                        }
                    }
                    E_ncurses_I_getch_S_meta_key = no;
                    break;
                }
                switch( E_ncurses_I_getch_S_c )
                { case KEY_DC:
                    {   break;
                    }
                  case KEY_BACKSPACE:
                    {   break;
                    }
                  case KEY_ENTER: // Na klawiaturze numerycznej.
                        E_ncurses_I_getch_S_c = '\r';
                        goto Enter;
                  case KEY_RIGHT:
                    {   break;
                    }
                  case KEY_LEFT:
                    {   break;
                    }
                  case KEY_DOWN:
                    {   break;
                    }
                  case KEY_UP:
                    {   break;
                    }
                  case KEY_HOME:
                  case KEY_A1: // Na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   E_ncurses_S_scroll_y = 0;
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_END:
                  case KEY_C1: // Na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   E_ncurses_S_scroll_y = E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 );
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_NPAGE:
                  case KEY_C3: // Na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   if( E_ncurses_S_scroll_max_y - E_ncurses_S_scroll_y > 2 * ( getmaxy(stdscr) - 1 ))
                                E_ncurses_S_scroll_y += getmaxy(stdscr) - 1;
                            else
                                E_ncurses_S_scroll_y = E_ncurses_S_scroll_max_y - ( getmaxy(stdscr) - 1 );
                            E_ncurses_I_lay();
                        }
                        break;
                  case KEY_PPAGE:
                  case KEY_A3: // Na klawiaturze numerycznej.
                        if( E_ncurses_S_scroll_max_y )
                        {   if( E_ncurses_S_scroll_y > getmaxy(stdscr) - 1 )
                                E_ncurses_S_scroll_y -= getmaxy(stdscr) - 1;
                            else
                                E_ncurses_S_scroll_y = 0;
                            E_ncurses_I_lay();
                        }
                        break;
                  default:
                    {   beep();
                        G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                        break;
                    }
                }
                break;
          case OK:
            {   if( E_ncurses_I_getch_S_meta_key )
                {   switch( E_ncurses_I_getch_S_c )
                    { case 's':
                            break;
                    }
                    E_ncurses_I_getch_S_meta_key = no;
                    break;
                }
                switch( E_ncurses_I_getch_S_c )
                { case 3: // Ctrl+c

                        break;
                  case 17: // Ctrl+q
                        U_F( E_base_S->E_flow_S_signal, exit );
                        break;
                  case 19: // Ctrl+s
                        break;
                  case 27: // “meta” key
                        E_ncurses_I_getch_S_meta_key = yes;
                        break;
                  default:
                        goto Cont;
                }
                break;
Cont:           if( !( E_ncurses_I_getch_S_c == '\r'
                || E_ncurses_I_getch_S_c == '\t'
                || iswprint( E_ncurses_I_getch_S_c )
                ))
                {   beep();
                    G_(); Gd( E_ncurses_I_getch_S_c ); //DBG
                    break;
                }
Enter:;
                break;
            }
        }
    }
    Xh1_W();
}
/******************************************************************************/
