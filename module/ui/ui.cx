//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   user interface
*         user interface
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”             2025‒9‒26 c
*******************************************************************************/
enum E_ui_Z_ui_Z_type
{ E_ui_Z_ui_Z_type_Z_group
, E_ui_Z_ui_Z_type_Z_text
, E_ui_Z_ui_Z_type_Z_list
, E_ui_Z_ui_Z_type_Z_action
, E_ui_Z_ui_Z_type_Z_level
};
struct E_ui_Q_object_Z
{ N child_n;
  I *child;
  I parent;
  enum E_ui_Z_ui_Z_type type;
  union
  { Pc title; // “E_ui_Z_ui_Z_type_Z_group”
    struct // “E_ui_Z_ui_Z_type_Z_text”
    { Pc s;
      B pathname;
    }text;
    struct  // “E_ui_Z_ui_Z_type_Z_list”
    { Pc title;
      Pc *select;
      N32 select_n;
      N32 select_i;
      B multi;
    }list;
    struct // “E_ui_Z_ui_Z_type_Z_action”
    { Pc label;
      void (*action)(void);
    }action;
    N max; // “E_ui_Z_ui_Z_type_Z_level”. Jeśli “max” równe 0, to typu ‘undefined’.
  };
};
struct E_ui_Q_collection_Z
{ struct E_mem_Q_tab_Z *object;
  Pc title;
};
struct E_mem_Q_tab_Z *E_ui_Q_collection_S;
//==============================================================================
I
E_ui_Q_collection_M( Pc title
){  I id = E_mem_Q_tab_I_add( E_ui_Q_collection_S );
    if( id < 0 )
        return id;
    struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    collection->object = E_mem_Q_tab_M( sizeof( struct E_ui_Q_object_Z ), 0 );
    if( !collection->object )
    {   N r = E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
        return r ? ~2 : ~0;
    }
    collection->title = title;
    return id;
}
N
E_ui_Q_collection_W( I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    N r = E_mem_Q_tab_W( collection->object );
    if(r)
        return ~2;
    return E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I
E_ui_Q_object_M( I collection_id
, I parent_id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    I id = E_mem_Q_tab_I_add( collection->object );
    if( id < 0 )
        return id;
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    Mt_( object->child, 0 );
    if( !object->child )
    {   N r = E_mem_Q_tab_I_remove( collection->object, id );
        return r ? ~2 : ~0;
    }
    object->child_n = 0;
    if( ~parent_id )
    {   struct E_ui_Q_object_Z *parent = E_mem_Q_tab_R( collection->object, parent_id );
        N n_prepended;
        if( !E_mem_Q_blk_I_add( &parent->child, 1, &n_prepended, 0 ))
        {   N r = E_mem_Q_tab_I_remove( collection->object, id );
            return r ? ~2 : ~0;
        }
        parent->child[ n_prepended ? 0 : parent->child_n ] = id;
        parent->child_n++;
    }
    object->parent = parent_id;
    return id;
}
N
E_ui_Q_object_W( I collection_id
, I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    struct E_ui_Q_object_Z *parent = E_mem_Q_tab_R( collection->object, object->parent );
    for_i( i, parent->child_n )
        if( parent->child[i] == id )
        {   if( !E_mem_Q_blk_I_remove( &parent->child, i, 1 ))
                return ~0;
            parent->child_n--;
            break;
        }
    N r = W( object->child );
    if(r)
        return ~2;
    switch( object->type )
    { case E_ui_Z_ui_Z_type_Z_text:
            if( object->text.s )
            {   N r = W( object->text.s );
                if(r)
                    return ~2;
            }
            break;
    }
    return E_mem_Q_tab_I_remove( collection->object, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_ui_I_build( I client_id
){  struct E_ui_Q_client_Z *client = E_mem_Q_tab_R( E_ui_Q_client_S, client_id );
    N r;
    Pc s;
    switch( client->type )
    { case E_ui_Q_client_Z_type_Z_gtk:
            r = E_ui_Q_gtk_cli_N( &s );
            break;
      case E_ui_Q_client_Z_type_Z_qt:
            r = E_ui_Q_qt_cli_N( &s );
            break;
    }
    if(r)
        return r;
    N l = E_text_Z_s0_R_l_0(s);
    Pc p;
    I call_id = E_flow_Q_process_call_M( sizeof(N) + l + sizeof(N), (P)&p );
    if( (S)call_id < 0 )
        return (N)call_id;
    *( N * )p = 2;
    p += sizeof(N);
    p = E_text_Z_s_P_copy_s0_0( p, s );
    *( N * )p = 0;
    r = W(s);
    if(r)
    {   r = E_flow_Q_process_call_W( call_id );
        return r ? ~1 : ~0;
    }
    B res;
    E_flow_Q_process_call_I( call_id, client->srv_pid, &res );
    r = E_flow_Q_process_call_W( call_id );
    return r ? ~1 : 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_ui_X( Pc *p
){  if( **p != '_' )
        return ~0;
    I collection_id = E_text_Z_s0_N_n( *p + 1, p, 36 );
    if( **p != '_'
    || !E_mem_Q_tab_T( E_ui_Q_collection_S, collection_id )
    )
        return ~0;
    struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    I object_id = E_text_Z_s0_N_n( *p + 1, p, 36 );
    if( **p
    || !E_mem_Q_tab_T( collection->object, object_id )
    )
        return ~0;
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, object_id );
    switch( object->type )
    { case E_ui_Z_ui_Z_type_Z_text:
        {   N l = E_text_Z_s0_R_l_0( ++*p );
            if( !E_mem_Q_blk_M_replace( &object->text.s, l ))
                return ~0;
            E_text_Z_s_P_copy_s0_0( object->text.s, *p );
            *p += l;
            G_(); Gs0( object->text.s );
            break;
        }
      case E_ui_Z_ui_Z_type_Z_list:
            if( *( N32 * )p >= object->list.select_n )
                return ~0;
            object->list.select_i = *( N32 * )p;
            p += sizeof(N32);
            break;
      case E_ui_Z_ui_Z_type_Z_action:
            object->action.action();
            break;
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_ui_Q_object_Z_level_P( I client_id
, I collection_id
, I object_id
, N level
){  struct E_ui_Q_client_Z *client = E_mem_Q_tab_R( E_ui_Q_client_S, client_id );
    struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, object_id );
    N l_1 = E_text_Z_n_N_s_G( collection_id, sizeof( collection_id ), 36 );
    N l_2 = E_text_Z_n_N_s_G( object_id, sizeof( object_id ), 36 );
    Pc p;
    I call_id = E_flow_Q_process_call_M( sizeof(N) + 1 + l_1 + 1 + l_2 + 1 + sizeof(F) + sizeof(N), (P)&p );
    if( (S)call_id < 0 )
        return (N)call_id;
    *( N * )( p + sizeof(N) + 1 + l_1 + 1 + l_2 + 1 + sizeof(F) ) = 0;
    if( object->max )
        *( F * )( p + sizeof(N) + 1 + l_1 + 1 + l_2 + 1 ) = level / object->max;
    p[ sizeof(N) + 1 + l_1 + 1 + l_2 ] = '\0';
    E_text_Z_n_N_s( p + sizeof(N) + 1 + l_1 + 1 + l_2, object_id, sizeof( object_id ), 36 );
    p[ sizeof(N) + 1 + l_1 ] = '_';
    E_text_Z_n_N_s( p + sizeof(N) + 1 + l_1, collection_id, sizeof( collection_id ), 36 );
    p[ sizeof(N) ] = '_';
    *( N * )p = 3;
    B res;
    E_flow_Q_process_call_I( call_id, client->srv_pid, &res );
    return E_flow_Q_process_call_W( call_id );
}
/******************************************************************************/
