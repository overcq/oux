//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   user interface
*         user interface
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”             2025‒9‒26 c
*******************************************************************************/
enum E_ui_Z_ui_Z_type
{ E_ui_Z_ui_Z_type_Z_group
, E_ui_Z_ui_Z_type_Z_text
, E_ui_Z_ui_Z_type_Z_list
, E_ui_Z_ui_Z_type_Z_action
, E_ui_Z_ui_Z_type_Z_level
};
struct E_ui_Q_object_Z
{ N child_n;
  I *child;
  enum E_ui_Z_ui_Z_type type;
};
struct E_ui_Q_collection_Z
{ struct E_mem_Q_tab_Z *object;
};
struct E_mem_Q_tab_Z *E_ui_Q_collection_S;
//==============================================================================
I
E_ui_Q_collection_M( void
){  I id = E_mem_Q_tab_I_add( E_ui_Q_collection_S );
    if( (S)id < 0 )
        return id;
    struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    collection->object = E_mem_Q_tab_M( sizeof( struct E_ui_Q_object_Z ), 0 );
    if( !collection->object )
    {   N ret = E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
        return ret ? ret : ~0;
    }
    return id;
}
N
E_ui_Q_collection_W( I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    N ret = E_mem_Q_tab_W( collection->object );
    if(ret)
        return ret;
    return E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I
E_ui_Q_object_M( I collection_id
, I parent_id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    I id = E_mem_Q_tab_I_add( collection->object );
    if( (S)id < 0 )
        return id;
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    Mt_( object->child, 0 );
    if( !object->child )
    {   N ret = E_mem_Q_tab_I_remove( collection->object, id );
        return ret ? ret : ~0;
    }
    object->child_n = 0;
    if( ~parent_id )
    {   struct E_ui_Q_object_Z *parent = E_mem_Q_tab_R( collection->object, parent_id );
        N n_prepended;
        if( !E_mem_Q_blk_I_add( &parent->child, 1, &n_prepended, 0 ))
        {   N ret = E_mem_Q_tab_I_remove( collection->object, id );
            return ret ? ret : ~0;
        }
        parent->child[ n_prepended ? 0 : parent->child_n ] = id;
        parent->child_n++;
    }
    return id;
}
N
E_ui_Q_object_W( I collection_id
, I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    for_each( object_id, collection->object, E_mem_Q_tab )
    {   struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, object_id );
        B found = no;
        for( N i = 0; i != object->child_n; i++ )
            if( object->child[i] == id )
            {   if( !E_mem_Q_blk_I_remove( &object->child, i, 1 ))
                    return ~0;
                object->child_n--;
                found = yes;
                break;
            }
        if(found)
            break;
    }
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    N ret = W( object->child );
    if(ret)
        return ret;
    return E_mem_Q_tab_I_remove( collection->object, id );
}
/******************************************************************************/
