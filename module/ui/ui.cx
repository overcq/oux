//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   user interface
*         user interface
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”             2025‒9‒26 c
*******************************************************************************/
enum E_ui_Z_ui_Z_type
{ E_ui_Z_ui_Z_type_Z_group
, E_ui_Z_ui_Z_type_Z_text
, E_ui_Z_ui_Z_type_Z_list
, E_ui_Z_ui_Z_type_Z_action
, E_ui_Z_ui_Z_type_Z_level
};
struct E_ui_Q_object_Z
{ N child_n;
  I *child;
  I parent;
  enum E_ui_Z_ui_Z_type type;
  union
  { Pc title; // “E_ui_Z_ui_Z_type_Z_group”
    Pc pathname; // “E_ui_Z_ui_Z_type_Z_text”
    struct  // “E_ui_Z_ui_Z_type_Z_list”
    { Pc title;
      Pc *select;
      N select_n;
      B multi;
    }list;
    struct // “E_ui_Z_ui_Z_type_Z_action”
    { Pc label;
      void (*action)(void);
    }action;
    struct // “E_ui_Z_ui_Z_type_Z_level”
    { N current, max; // Jeśli “max” równe 0, to typu ‘undefined’.
    }level;
  };
};
struct E_ui_Q_collection_Z
{ struct E_mem_Q_tab_Z *object;
  Pc title;
};
struct E_mem_Q_tab_Z *E_ui_Q_collection_S;
//==============================================================================
I
E_ui_Q_collection_M( Pc title
){  I id = E_mem_Q_tab_I_add( E_ui_Q_collection_S );
    if( (S)id < 0 )
        return id;
    struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    collection->object = E_mem_Q_tab_M( sizeof( struct E_ui_Q_object_Z ), 0 );
    if( !collection->object )
    {   N r = E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
        return r ? ~2 : ~0;
    }
    collection->title = title;
    return id;
}
N
E_ui_Q_collection_W( I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, id );
    N r = E_mem_Q_tab_W( collection->object );
    if(r)
        return ~2;
    return E_mem_Q_tab_I_remove( E_ui_Q_collection_S, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I
E_ui_Q_object_M( I collection_id
, I parent_id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    I id = E_mem_Q_tab_I_add( collection->object );
    if( (S)id < 0 )
        return id;
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    Mt_( object->child, 0 );
    if( !object->child )
    {   N r = E_mem_Q_tab_I_remove( collection->object, id );
        return r ? ~2 : ~0;
    }
    object->child_n = 0;
    if( ~parent_id )
    {   struct E_ui_Q_object_Z *parent = E_mem_Q_tab_R( collection->object, parent_id );
        N n_prepended;
        if( !E_mem_Q_blk_I_add( &parent->child, 1, &n_prepended, 0 ))
        {   N r = E_mem_Q_tab_I_remove( collection->object, id );
            return r ? ~2 : ~0;
        }
        parent->child[ n_prepended ? 0 : parent->child_n ] = id;
        parent->child_n++;
    }
    object->parent = parent_id;
    return id;
}
N
E_ui_Q_object_W( I collection_id
, I id
){  struct E_ui_Q_collection_Z *collection = E_mem_Q_tab_R( E_ui_Q_collection_S, collection_id );
    struct E_ui_Q_object_Z *object = E_mem_Q_tab_R( collection->object, id );
    struct E_ui_Q_object_Z *parent = E_mem_Q_tab_R( collection->object, object->parent );
    for_i( i, parent->child_n )
        if( parent->child[i] == id )
        {   if( !E_mem_Q_blk_I_remove( &parent->child, i, 1 ))
                return ~0;
            parent->child_n--;
            break;
        }
    N r = W( object->child );
    if(r)
        return ~2;
    return E_mem_Q_tab_I_remove( collection->object, id );
}
/******************************************************************************/
