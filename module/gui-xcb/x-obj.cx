//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   ‟X window” —high ‘cpu’
*         window objects manager
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒4‒28 *
*******************************************************************************/
// Są to obiekty wizualne.
// Każdy obiekt okna jest jednokrotny w konkretnym oknie.
// Obiekt o identyfikatorze 0 (zwykle typu “frame”) jest zasobnikiem obiektów automatycznie układanych w oknie.
//==============================================================================
typedef
void
(*draw_object_proc)(
  struct E_gui_xcb_Q_display_Z *
, struct E_gui_xcb_Q_screen_Z *
, struct E_gui_xcb_Q_window_Z *
, struct E_gui_xcb_Q_object_Z *
);
typedef
void
(*click_object_proc)(
  struct E_gui_xcb_Q_window_Z *
, struct E_gui_xcb_Q_object_Z *
, N8 // button
, N8 // sequence
);
struct E_gui_xcb_Q_object_Z
{ void // Ale obiekt zawiera punkty, które narysuje ta funkcja w czasie wywołania.
  (*draw)(
    struct E_gui_xcb_Q_display_Z *
  , struct E_gui_xcb_Q_screen_Z *
  , struct E_gui_xcb_Q_window_Z *
  , struct E_gui_xcb_Q_object_Z *
  );
  void
  (*click)(
    struct E_gui_xcb_Q_window_Z *
  , struct E_gui_xcb_Q_object_Z *
  , N8
  , N8
  );
  void
  (*clear_data)(P);
  N child_n;
  I *child;
  P data;
  S16 x, y;
  N16 width, height; // Prostokąt oczekiwanej widoczności obiektu.
  unsigned U_R( mode, lay_height )      :1;
  unsigned U_R( mode, draggable )       :1;
  unsigned U_R( state, drag_src )       :1;
};
struct E_gui_xcb_Q_object_Z_data_Z_entry
{ I font;
  Pc s;
  N text_start;
  N cursor_pos;
  unsigned U_R( state, cursor_visible_ ) :1;
};
struct E_gui_xcb_Q_object_Z_data_Z_select
{ Pc *select;
  N select_n;
};
struct E_gui_xcb_Q_object_Z_data_Z_select_list
{ N scroll;
  N selected;
};
//==============================================================================
S16 E_gui_xcb_Q_object_S_layout_dx = 4, E_gui_xcb_Q_object_S_layout_dy = 4;
//==============================================================================
I
E_gui_xcb_Q_object_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, N child_n
, S16 x
, S16 y
, N16 width
, N16 height
, void
  (*clear_data)(P)
, void
  (*draw)(
    struct E_gui_xcb_Q_display_Z *
  , struct E_gui_xcb_Q_screen_Z *
  , struct E_gui_xcb_Q_window_Z *
  , struct E_gui_xcb_Q_object_Z *
  )
, void
  (*click)(
    struct E_gui_xcb_Q_window_Z *
  , struct E_gui_xcb_Q_object_Z *
  , N8
  , N8
  )
, S8 set_window_dimensions
){  J_assert( x >= 0 && y >= 0 );
    I object_id = E_mem_Q_tab_I_add( window->object );
    if( !~object_id )
        return ~0;
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->draw = draw;
    object->click = click;
    object->clear_data = clear_data;
    object->child_n = child_n;
    Mt_( object->child, child_n );
    if( !object->child )
    {   E_mem_Q_tab_I_remove( window->object, object_id );
        return ~0;
    }
    object->data = 0;
    object->x = x;
    object->y = y;
    object->width = width;
    object->height = height;
    U_L( object->mode, lay_height );
    U_L( object->mode, draggable );
    U_L( object->state, drag_src );
    if( set_window_dimensions
    || ( !~set_window_dimensions
      && object_id
      && E_gui_xcb_Q_object_R_top( window, object_id )
    ))
        E_gui_xcb_Q_object_I_set_max_window_dimensions( display, window, object, no );
    return object_id;
}
void
E_gui_xcb_Q_object_W(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I id
){  struct E_gui_xcb_Q_window_Z *window_ = E_mem_Q_tab_R( display->window, display->pointer_button_S_hover_window_id );
    if( window_ == window
    && display->pointer_button_S_hover_object_id == id
    )
        display->pointer_button_S_hover_object_id = ~0;
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    E_gui_xcb_Q_object_I_set_max_window_dimensions( display, window, object, yes );
    if( object->data )
    {   if( object->clear_data )
            object->clear_data( object->data );
        W( object->data );
    }
    W( object->child );
    E_mem_Q_tab_I_remove( window->object, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I
E_gui_xcb_Q_object_R_parent( struct E_gui_xcb_Q_window_Z *window
, I id
){  J_assert( E_mem_Q_tab_T( window->object, id ));
    for_each( object_id, window->object, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
        for_n( child_i, object->child_n )
        {   if( object->child[ child_i ] == id )
                return object_id;
        }
    }
    return ~0;
}
B
E_gui_xcb_Q_object_R_top( struct E_gui_xcb_Q_window_Z *window
, I id
){  return !~E_gui_xcb_Q_object_R_parent( window, id );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
void
E_gui_xcb_Q_object_I_set_max_window_dimensions(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
, B add_remove
){  if( U_R( display->mode, drag )
    || U_R( display->mode, drag_stop )
    )
    {   for_each( screen_id, display->screen, E_mem_Q_tab )
        {   struct E_gui_xcb_Q_screen_Z *screen = E_mem_Q_tab_R( display->screen, screen_id );
            if( window == &screen->dnd_window )
                return;
        }
    }
    S16 x_min = 100, y_min = 50; //CONF
    for_each_out( 0, object_id, window->object, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_object_Z *object_ = E_mem_Q_tab_R( window->object, object_id );
        if( object_ == object
        || !E_gui_xcb_Q_object_R_top( window, object_id )
        )
            continue;
        S16 object_x_max = object_->x + object_->width, object_y_max = object_->y + object_->height;
        if( x_min < object_x_max )
            x_min = object_x_max;
        if( y_min < object_y_max )
            y_min = object_y_max;
    }
    S16 object_x_max = object->x + object->width, object_y_max = object->y + object->height;
    if( x_min < object_x_max
    || y_min < object_y_max
    )
        E_x_Z_property_P( display, window, WM_NORMAL_HINTS
        , WM_SIZE_HINTS
        , (( xcb_size_hints_t )
          { .flags = XCB_ICCCM_SIZE_HINT_P_MIN_SIZE
          , .min_width = add_remove ? x_min : object_x_max
          , .min_height = add_remove ? y_min : object_y_max
          })
        );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_gui_xcb_Q_object_I_add(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I id
, I child_id
){  J_assert( E_mem_Q_tab_T( window->object, child_id ));
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    if( !E_mem_Q_blk_I_append( &object->child, 1 ))
        return ~0;
    object->child[ object->child_n++ ] = child_id;
    return 0;
}
//------------------------------------------------------------------------------
N
E_gui_xcb_Q_object_I_remove_descendants(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I id
){  struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    N ids_n = object->child_n;
    I *Mt_( ids, ids_n );
    if( !ids )
        return ~0;
    E_mem_Q_blk_I_copy( &ids[0], &object->child[0], object->child_n * sizeof( *object->child ));
    object->child_n = 0;
    if( !E_mem_Q_blk_M_replace_tab( &object->child, sizeof( *object->child ), object->child_n ))
    {   W(ids);
        return ~0;
    }
    for_n( ids_i, ids_n )
    {   object = E_mem_Q_tab_R( window->object, ids[ ids_i ] );
        if( object->child_n )
        {   if( !E_mem_Q_blk_I_append( &ids, object->child_n ))
            {   W(ids);
                return ~0;
            }
            E_mem_Q_blk_I_copy( &ids[ ids_n ], &object->child[0], object->child_n * sizeof( *object->child ));
            ids_n += object->child_n;
        }
    }
    for_n_( ids_i, ids_n )
         E_gui_xcb_Q_object_W( display, window, ids[ ids_i ] );
    W(ids);
    return 0;
}
N
E_gui_xcb_Q_object_I_remove(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I id
){  E_gui_xcb_Q_object_I_remove_descendants( display, window, id );
    for_each( object_id, window->object, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
        for_n( child_i, object->child_n )
        {   if( object->child[ child_i ] == id )
            {   E_mem_Q_blk_I_remove( &object->child, child_i, 1 );
                object->child_n--;
                goto End;
            }
        }
    }
End:E_gui_xcb_Q_object_W( display, window, id );
    return 0;
}
//------------------------------------------------------------------------------
N
E_gui_xcb_Q_object_I_remove_drag_src( struct E_gui_xcb_Q_window_Z *window
, I id
){  struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
    U_L( object->state, drag_src );
    N ids_n = object->child_n;
    I *Mt_( ids, ids_n );
    if( !ids )
        return ~0;
    E_mem_Q_blk_I_copy( &ids[0], &object->child[0], object->child_n * sizeof( *object->child ));
    object->child_n = 0;
    if( !E_mem_Q_blk_M_replace_tab( &object->child, sizeof( *object->child ), object->child_n ))
    {   W(ids);
        return ~0;
    }
    for_n( ids_i, ids_n )
    {   object = E_mem_Q_tab_R( window->object, ids[ ids_i ] );
        if( object->child_n )
        {   if( !E_mem_Q_blk_I_append( &ids, object->child_n ))
            {   W(ids);
                return ~0;
            }
            E_mem_Q_blk_I_copy( &ids[ ids_n ], &object->child[0], object->child_n * sizeof( *object->child ));
            ids_n += object->child_n;
        }
    }
    for_n_( ids_i, ids_n )
    {   object = E_mem_Q_tab_R( window->object, ids[ ids_i ] );
        U_L( object->state, drag_src );
    }
    W(ids);
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I
E_gui_xcb_Q_object_Z_button_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
){  return E_gui_xcb_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 40
    , 10
    , 0
    , E_gui_xcb_Q_object_Z_button_I_draw
    , E_gui_xcb_Q_object_Z_button_I_click
    , ~0
    );
}
_internal
void
E_gui_xcb_Q_object_Z_button_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.object_bg );
    E_gui_xcb_Q_object_I_fill_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 2
        , .y = 2
        , .width = object->width - 4
        , .height = object->height - 4
        }
      }
    );
    B U_L( button, hover );
    if( ~display->focus_S_window_id
    && display->focus_S_window_id == display->pointer_button_S_hover_window_id
    && ~display->pointer_button_S_hover_object_id
    )
    {   struct E_gui_xcb_Q_window_Z *window_hover = E_mem_Q_tab_R( display->window, display->pointer_button_S_hover_window_id );
        if( window_hover == window )
        {   struct E_gui_xcb_Q_object_Z *object_hover = E_mem_Q_tab_R( window->object, display->pointer_button_S_hover_object_id );
            if( object_hover == object )
                U_F( button, hover );
        }
    }
    E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, U_R( button, hover ) ? E_gui_xcb_Q_theme.current_boundary : E_gui_xcb_Q_theme.line );
    E_gui_xcb_Q_object_I_draw_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width
        , .height = object->height
        }
      }
    , 2
    );
}
void
E_gui_xcb_Q_object_Z_button_I_click(
  struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
, N8 button
, N8 seq
){  if( button == 1 && seq == 2 )
    {   G();
    }
}
//------------------------------------------------------------------------------
_internal
void
E_gui_xcb_Q_object_Z_entry_I_clear_data( P data
){  if( !data )
        return;
    struct E_gui_xcb_Q_object_Z_data_Z_entry *object_data = data;
    W( object_data->s );
}
I
E_gui_xcb_Q_object_Z_entry_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I font_id
, Pc s
){  struct E_gui_xcb_Q_font_Z *font = E_mem_Q_tab_R( E_gui_xcb_Q_font_S, font_id );
    I object_id = E_gui_xcb_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 40
    , font->height
    , E_gui_xcb_Q_object_Z_font_I_clear_data
    , E_gui_xcb_Q_object_Z_entry_I_draw
    , 0
    , ~0
    );
    struct E_gui_xcb_Q_object_Z_data_Z_entry *M_( object_data );
    if( !object_data )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    object_data->font = font_id;
    object_data->s = M( E_text_Z_s0_R_l_0(s) );
    object_data->text_start = 0;
    if( !object_data->s )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    E_text_Z_s_P_copy_s0_0( object_data->s, s );
    U_L( object_data->state, cursor_visible_ );
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->data = object_data;
    return object_id;
}
_internal
void
E_gui_xcb_Q_object_Z_entry_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  struct E_gui_xcb_Q_object_Z_data_Z_entry *object_data = object->data;
    Pc s = object_data->s;
    for_n( i, object_data->text_start )
    {   U u = ~0;
        s = E_text_Z_su_R_u( s, &u );
        if( !~u )
        {   GV_(bad UTF-8 character); V();
        }
    }
    Pc s_ = s;
    struct E_gui_xcb_Q_font_Z *font = E_mem_Q_tab_R( E_gui_xcb_Q_font_S, object_data->font );
    S16 x = E_gui_xcb_Q_object_S_layout_dx; //NDFN Dlaczego tutaj nie ma być 0?
    while( *s )
    {   U u = ~0;
        s = E_text_Z_su_R_u( s, &u );
        if( !~u )
        {   GV_(bad UTF-8 character); V();
        }
        N min = 0;
        N max = font->bitmap_n;
        N i = max / 2;
        O{  if( font->bitmap[i].u == u )
                break;
            if( font->bitmap[i].u > u )
            {   if( i == min )
                {   i = 63;
                    break;
                }
                max = i - 1;
                i = max - ( i - min ) / 2;
            }else
            {   if( i == max )
                {   i = 63;
                    break;
                }
                min = i + 1;
                i = min + ( max - i ) / 2;
            }
        }
        x += ( x != E_gui_xcb_Q_object_S_layout_dx ? font->bitmap[63].width / 2 : 0 ) + font->bitmap[i].width;
        if( x >= object->width )
            break;
    }
    C c = *s;
    *s = '\0';
    E_gui_xcb_Q_object_I_draw_Z_font_Z_s( display, screen, window, object, 0, 0, E_gui_xcb_Q_theme.text, object_data->font, s_ );
    *s = c;
    if( U_R( object_data->state, cursor_visible_ ))
    {   Pc s = object_data->s;
        for_n( i, object_data->text_start )
        {   U u = ~0;
            s = E_text_Z_su_R_u( s, &u );
            if( !~u )
            {   GV_(bad UTF-8 character); V();
            }
        }
        struct E_gui_xcb_Q_font_Z *font = E_mem_Q_tab_R( E_gui_xcb_Q_font_S, object_data->font );
        S16 x = 0;
        N l = object_data->cursor_pos - object_data->text_start;
        while( l && *s )
        {   U u = ~0;
            s = E_text_Z_su_R_u( s, &u );
            if( !~u )
            {   GV_(bad UTF-8 character); V();
            }
            N min = 0;
            N max = font->bitmap_n;
            N i = max / 2;
            O{  if( font->bitmap[i].u == u )
                    break;
                if( font->bitmap[i].u > u )
                {   if( i == min )
                    {   i = 63;
                        break;
                    }
                    max = i - 1;
                    i = max - ( i - min ) / 2;
                }else
                {   if( i == max )
                    {   i = 63;
                        break;
                    }
                    min = i + 1;
                    i = min + ( max - i ) / 2;
                }
            }
            x += ( x != 0 ? font->bitmap[63].width / 2 : 0 ) + font->bitmap[i].width;
            l--;
        }
        E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.cursor );
        E_gui_xcb_Q_object_I_draw_Z_segments( display, screen, window, object, 1
        , ( xcb_segment_t[] ){
            x
          , 0
          , x
          , object->height - 1
          }
        , 0 );
    }
}
//------------------------------------------------------------------------------
_internal
void
E_gui_xcb_Q_object_Z_font_I_clear_data( P data
){  if( !data )
        return;
    struct E_gui_xcb_Q_object_Z_data_Z_font *object_data = data;
    W( object_data->label );
}
I
E_gui_xcb_Q_object_Z_font_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I font_id
, Pc label
){  struct E_gui_xcb_Q_font_Z *font = E_mem_Q_tab_R( E_gui_xcb_Q_font_S, font_id );
    N16 width = font->bitmap[63].width / 2, width_ = 0;
    N16 height = font->height;
    Pc s = label;
    while( *s )
    {   if( *s == '\n' )
        {   if( width < width_ )
                width = width_;
            width_ = 0;
            height += font->height / 2 + font->height;
            s++;
        }else
        {   U u = ~0;
            s = E_text_Z_su_R_u( s, &u );
            if( !~u )
                return ~0;
            N min = 0;
            N max = font->bitmap_n;
            N i = max / 2;
            O{  if( font->bitmap[i].u == u )
                {   width_ += ( width_ ? font->bitmap[63].width / 2 : 0 ) + font->bitmap[i].width;
                    break;
                }
                if( font->bitmap[i].u > u )
                {   if( i == min )
                        return ~0;
                    max = i - 1;
                    i = max - ( i - min ) / 2;
                }else
                {   if( i == max )
                        return ~0;
                    min = i + 1;
                    i = min + ( max - i ) / 2;
                }
            }
        }
    }
    if( width < width_ )
        width = width_;
    I object_id = E_gui_xcb_Q_object_M( display, window
    , 0
    , 0
    , 0
    , width
    , height
    , E_gui_xcb_Q_object_Z_font_I_clear_data
    , E_gui_xcb_Q_object_Z_font_I_draw
    , 0
    , ~0
    );
    struct E_gui_xcb_Q_object_Z_data_Z_font *M_( object_data );
    if( !object_data )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    object_data->font = font_id;
    object_data->label = M( E_text_Z_s0_R_l_0(label) );
    if( !object_data->label )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    E_text_Z_s_P_copy_s0_0( object_data->label, label );
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->data = object_data;
    return object_id;
}
_internal
void
E_gui_xcb_Q_object_Z_font_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  struct E_gui_xcb_Q_object_Z_data_Z_font *object_data = object->data;
    E_gui_xcb_Q_object_I_draw_Z_font_Z_s( display, screen, window, object, 0, 0, E_gui_xcb_Q_theme.text, object_data->font, object_data->label );
}
//------------------------------------------------------------------------------
I
E_gui_xcb_Q_object_Z_frame_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
){  return E_gui_xcb_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 40
    , 10
    , 0
    , E_gui_xcb_Q_object_Z_frame_I_draw
    , 0
    , ~0
    );
}
_internal
void
E_gui_xcb_Q_object_Z_frame_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.window_bg );
    E_gui_xcb_Q_object_I_fill_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 1
        , .y = 1
        , .width = object->width - 2
        , .height = object->height - 2
        }
      }
    );
    E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.line );
    E_gui_xcb_Q_object_I_draw_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width
        , .height = object->height
        }
      }
    , 1
    );
}
_internal
void
E_gui_xcb_Q_object_Z_select_I_clear_data( P data
){  if( !data )
        return;
    struct E_gui_xcb_Q_object_Z_data_Z_select *object_data = data;
    W( object_data->select );
}
I
E_gui_xcb_Q_object_Z_select_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
){  I object_id = E_gui_xcb_Q_object_M( display, window
    , 0
    , 0
    , 0
    , 8
    , 8
    , E_gui_xcb_Q_object_Z_select_I_clear_data
    , E_gui_xcb_Q_object_Z_select_I_draw
    , 0
    , ~0
    );
    if( !~object_id )
        return ~0;
    struct E_gui_xcb_Q_object_Z_data_Z_select *M_( object_data );
    if( !object_data )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    object_data->select_n = 0;
    Mt_( object_data->select, object_data->select_n );
    if( !object_data->select )
    {   W( object_data );
        E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->data = object_data;
    return object_id;
}
_internal
void
E_gui_xcb_Q_object_Z_select_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.window_bg );
    E_gui_xcb_Q_object_I_fill_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width - 1
        , .height = object->height - 1
        }
      }
    );
    E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.line );
    E_gui_xcb_Q_object_I_draw_Z_lines( display, screen, window, object, 2
    , ( xcb_point_t[] )
      { { object->width / 2
        , 0
        }
      , { object->width / 2
        , object->height - 1
        }
      }
    , object->width / 3
    );
    E_gui_xcb_Q_object_I_draw_Z_lines( display, screen, window, object, 3
    , ( xcb_point_t[] )
      { { 0
        , object->height / 2
        }
      , { object->width / 2
        , object->height - 1
        }
      , { object->width - 1
        , object->height / 2
        }
      }
    , 2
    );
}
I
E_gui_xcb_Q_object_Z_select_list_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, S16 x
, S16 y
, N16 width
, N16 height
){  I object_id = E_gui_xcb_Q_object_M( display, window
    , 0
    , x
    , y
    , width
    , height
    , 0
    , E_gui_xcb_Q_object_Z_select_list_I_draw
    , 0
    , no
    );
    if( !~object_id )
        return ~0;
    struct E_gui_xcb_Q_object_Z_data_Z_select_list *M_( object_data );
    if( !object_data )
    {   E_gui_xcb_Q_object_W( display, window, object_id );
        return ~0;
    }
    object_data->scroll = 0;
    object_data->selected = ~0;
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
    object->data = object_data;
    return object_id;
}
_internal
void
E_gui_xcb_Q_object_Z_select_list_I_draw(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_screen_Z *screen
, struct E_gui_xcb_Q_window_Z *window
, struct E_gui_xcb_Q_object_Z *object
){  E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.window_bg );
    E_gui_xcb_Q_object_I_fill_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 1
        , .y = 1
        , .width = object->width - 2
        , .height = object->height - 2
        }
      }
    );
    E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.line );
    E_gui_xcb_Q_object_I_draw_Z_rectangles( display, screen, window, object
    , 1
    , ( xcb_rectangle_t[] )
      { { .x = 0
        , .y = 0
        , .width = object->width
        , .height = object->height
        }
      }
    , 1
    );
    struct E_gui_xcb_Q_object_Z *select = E_mem_Q_tab_R( window->object, display->select_object );
    struct E_gui_xcb_Q_object_Z_data_Z_select *select_data = select->data;
    I parent_id = E_gui_xcb_Q_object_R_parent( window, display->select_object );
    struct E_gui_xcb_Q_object_Z *object_parent = E_mem_Q_tab_R( window->object, parent_id );
    struct E_gui_xcb_Q_object_Z *entry = E_mem_Q_tab_R( window->object, object_parent->child[1] );
    struct E_gui_xcb_Q_object_Z_data_Z_entry *entry_data = entry->data;
    struct E_gui_xcb_Q_font_Z *font = E_mem_Q_tab_R( E_gui_xcb_Q_font_S, entry_data->font );
    struct E_gui_xcb_Q_object_Z_data_Z_select_list *object_data = object->data;
    N y = 1;
    for( N i = object_data->scroll; i != select_data->select_n; i++ )
    {   if( i == object_data->selected )
        {   E_gui_xcb_Q_object_I_draw_P_color( display, screen, object, E_gui_xcb_Q_theme.line_selection_bg );
            E_gui_xcb_Q_object_I_fill_Z_rectangles( display, screen, window, object
            , 1
            , ( xcb_rectangle_t[] )
              { { .x = 1
                , .y = 1 + ( object_data->selected - object_data->scroll ) * font->height
                , .width = object->width - 2
                , .height = font->height
                }
              }
            );
        }
        if( !~E_gui_xcb_Q_object_I_draw_Z_font_Z_s( display, screen, window, object
        , 1
        , y
        , E_gui_xcb_Q_theme.text
        , entry_data->font
        , select_data->select[i]
        ))
            return;
        y += font->height;
        if( y == object->height - 1 )
            break;
    }
}
//------------------------------------------------------------------------------
I
E_gui_xcb_Q_object_Z_button_font_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I font_id
, Pc s
){  I button_id = E_gui_xcb_Q_object_Z_button_M( display, window );
    if( !~button_id )
        return ~0;
    I font_id_ = E_gui_xcb_Q_object_Z_font_M( display, window, font_id, s );
    if( !~font_id_ )
    {   E_gui_xcb_Q_object_W( display, window, button_id );
        return ~0;
    }
    E_gui_xcb_Q_object_I_add( display, window, button_id, font_id_ );
    return button_id;
}
I
E_gui_xcb_Q_object_Z_frame_entry_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I font_id
, Pc s
){  I frame_id = E_gui_xcb_Q_object_Z_frame_M( display, window );
    if( !~frame_id )
        return ~0;
    I entry_id = E_gui_xcb_Q_object_Z_entry_M( display, window, font_id, s );
    if( !~entry_id )
    {   E_gui_xcb_Q_object_W( display, window, frame_id );
        return ~0;
    }
    E_gui_xcb_Q_object_I_add( display, window, frame_id, entry_id );
    return frame_id;
}
I
E_gui_xcb_Q_object_Z_frame_select_M(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
, I font_id
, Pc s
){  I frame_id = E_gui_xcb_Q_object_Z_frame_M( display, window );
    if( !~frame_id )
        return ~0;
    I select_id = E_gui_xcb_Q_object_Z_select_M( display, window );
    if( !~select_id )
    {   E_gui_xcb_Q_object_W( display, window, frame_id );
        return ~0;
    }
    I entry_id = E_gui_xcb_Q_object_Z_entry_M( display, window, font_id, s );
    if( !~entry_id )
    {   E_gui_xcb_Q_object_W( display, window, select_id );
        E_gui_xcb_Q_object_W( display, window, frame_id );
        return ~0;
    }
    E_gui_xcb_Q_object_I_add( display, window, frame_id, select_id );
    E_gui_xcb_Q_object_I_add( display, window, frame_id, entry_id );
    return frame_id;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_gui_xcb_Q_layout_I_store( struct E_gui_xcb_Q_display_Z *display
, Pc path
){  I file_id = E_mem_Q_file_M( path, no, S_IRUSR | S_IWUSR );
    if( !~E_mem_Q_file_I_truncate( file_id ))
    {   E_mem_Q_file_W( file_id );
        return ~0;
    }
    struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, file_id );
    for_each( window_id, display->window, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_window_Z *window = E_mem_Q_tab_R( display->window, window_id );
        for_each( object_id, window->object, E_mem_Q_tab )
        {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
            if( object->draw == E_gui_xcb_Q_object_Z_entry_I_draw )
            {   struct E_gui_xcb_Q_object_Z_data_Z_entry *object_data = object->data;
                if( E_mem_Q_file_P_insert_s( file_id, object_data->s, E_text_Z_s0_R_l_0( object_data->s )))
                {   E_mem_Q_file_W( file_id );
                    return ~0;
                }
                E_mem_Q_file_P_pos( file_id, file->l );
            }
        }
    }
    E_mem_Q_file_W( file_id );
    return 0;
}
N
E_gui_xcb_Q_layout_I_restore( struct E_gui_xcb_Q_display_Z *display
, Pc path
){  I file_id = E_mem_Q_file_M( path, no, 0 );
    for_each( window_id, display->window, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_window_Z *window = E_mem_Q_tab_R( display->window, window_id );
        for_each( object_id, window->object, E_mem_Q_tab )
        {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
            if( object->draw == E_gui_xcb_Q_object_Z_entry_I_draw )
            {   struct E_gui_xcb_Q_object_Z_data_Z_entry *object_data = object->data;
                if( E_mem_Q_file_R_u_upto_0( file_id, &object_data->s ))
                {   E_mem_Q_file_W( file_id );
                    return ~0;
                }
            }
        }
    }
    C c;
    N ret = E_mem_Q_file_R_c( file_id, &c );
    E_mem_Q_file_W( file_id );
    return ret == S_eof ? 0 : ~0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_gui_xcb_Q_object_I_lay(
  struct E_gui_xcb_Q_display_Z *display
, struct E_gui_xcb_Q_window_Z *window
){  if( !E_mem_Q_tab_R_n( window->object ))
        return 0;
    if( ~display->select_window )
    {   struct E_gui_xcb_Q_window_Z *window = E_mem_Q_tab_R( display->window, display->select_window );
        E_gui_xcb_Q_object_W( display, window, display->select_list_object );
        display->select_window = ~0;
    }
    struct Z_stack
    { struct E_gui_xcb_Q_object_Z *object;
      N i;
    };
    struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, 0 );
    if( !object->child_n )
        return 0;
    for_each( id, window->object, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, id );
        U_L( object->mode, lay_height );
    }
Restart:;
    struct Z_stack *stack = Mt( sizeof( struct Z_stack ), 0 );
    if( !stack )
        return ~0;
    N stack_i = ~0;
    S16 next_x = E_gui_xcb_Q_object_S_layout_dx;
    S16 next_y = E_gui_xcb_Q_object_S_layout_dy;
    S16 after_x = E_gui_xcb_Q_object_S_layout_dx;
    S16 after_y = E_gui_xcb_Q_object_S_layout_dy;
    O{  if( object->child_n )
        {   if( ~stack_i )
                if( U_R( object->mode, lay_height ))
                {   next_x = stack[ stack_i ].object->x + E_gui_xcb_Q_object_S_layout_dx;
                    after_x = next_x + E_gui_xcb_Q_object_S_layout_dx;
                    next_y = after_y;
                    after_y += E_gui_xcb_Q_object_S_layout_dy;
                }else
                    after_y = next_y + E_gui_xcb_Q_object_S_layout_dy;
            struct Z_stack *stack_top = E_mem_Q_blk_I_append( &stack, 1 );
            if( !stack_top )
            {   W(stack);
                return ~0;
            }
            stack_i++;
            stack_top->object = object;
            stack_top->i = 0;
            object->x = next_x;
            object->y = next_y;
            object->width = E_gui_xcb_Q_object_S_layout_dx;
            object->height = E_gui_xcb_Q_object_S_layout_dy;
            next_x += E_gui_xcb_Q_object_S_layout_dx;
            if( next_x > window->width
            && !U_R( object->mode, lay_height )
            ){  U_F( object->mode, lay_height );
                do
                {   object = stack[ stack_i ].object;
                }while( ~--stack_i
                && !stack[ stack_i ].i
                );
                U_F( object->mode, lay_height );
                W(stack);
                object = E_mem_Q_tab_R( window->object, 0 );
                goto Restart;
            }
            next_y += E_gui_xcb_Q_object_S_layout_dy;
            object = E_mem_Q_tab_R( window->object, object->child[0] );
            continue;
        }
        if( stack[ stack_i ].i != stack[ stack_i ].object->child_n )
        {   stack[ stack_i ].i++;
            if( U_R( object->mode, lay_height )
            && stack[ stack_i ].i != 1
            ){  next_x = stack[ stack_i ].object->x + E_gui_xcb_Q_object_S_layout_dx;
                next_y = after_y;
            }
            object->x = next_x;
            object->y = next_y;
            if( after_x < next_x + object->width + E_gui_xcb_Q_object_S_layout_dx )
                after_x = next_x + object->width + E_gui_xcb_Q_object_S_layout_dx;
            if( after_y < next_y + object->height + E_gui_xcb_Q_object_S_layout_dy )
                after_y = next_y + object->height + E_gui_xcb_Q_object_S_layout_dy;
            struct E_gui_xcb_Q_object_Z *object_ = object;
            N stack_i_ = stack_i;
            N16 after_x_ = after_x;
            N16 after_y_ = after_y;
            do
            {   object_ = stack[ stack_i_ ].object;
                if( object_->width < after_x_ - object_->x )
                    object_->width = after_x_ - object_->x;
                if( object_->height < after_y_ - object_->y )
                    object_->height = after_y_ - object_->y;
                after_x_ += E_gui_xcb_Q_object_S_layout_dx;
                after_y_ += E_gui_xcb_Q_object_S_layout_dy;
            }while( ~--stack_i_ );
            next_x += object->width + E_gui_xcb_Q_object_S_layout_dx;
            if( next_x > window->width
            && !U_R( object->mode, lay_height )
            ){  U_F( object->mode, lay_height );
                if( stack[ stack_i ].i == 1 )
                {   do
                    {   object = stack[ stack_i ].object;
                    }while( ~--stack_i
                    && !stack[ stack_i ].i
                    );
                    U_F( object->mode, lay_height );
                }
                W(stack);
                object = E_mem_Q_tab_R( window->object, 0 );
                goto Restart;
            }
            if( stack[ stack_i ].i != stack[ stack_i ].object->child_n )
            {   object = E_mem_Q_tab_R( window->object, stack[ stack_i ].object->child[ stack[ stack_i ].i ] );
                continue;
            }
        }
        N stack_i_1 = stack_i;
        do
        {   next_x = stack[ stack_i ].object->x + stack[ stack_i ].object->width + E_gui_xcb_Q_object_S_layout_dx;
            if( next_x > window->width
            && !U_R( stack[ stack_i ].object->mode, lay_height )
            ){  U_F( stack[ stack_i ].object->mode, lay_height );
                N stack_i_ = stack_i;
                O{  if( object->child_n )
                    {   struct Z_stack *stack_top = E_mem_Q_blk_I_append( &stack, 1 );
                        if( !stack_top )
                        {   W(stack);
                            return ~0;
                        }
                        stack_i_++;
                        stack_top->object = object;
                        stack_top->i = object->child_n;
                        object = E_mem_Q_tab_R( window->object, object->child[ stack_top->i - 1 ] );
                        continue;
                    }
                    if( ~stack[ stack_i_ ].i )
                    {   stack[ stack_i_ ].i--;
                        U_L( object->mode, lay_height );
                        if( ~stack[ stack_i_ ].i )
                        {   object = E_mem_Q_tab_R( window->object, stack[ stack_i_ ].object->child[ stack[ stack_i_ ].i ] );
                            continue;
                        }
                    }
                    N stack_i_1 = stack_i_;
                    do
                    {   if( stack_i_ == stack_i )
                            goto Cont;
                        U_L( stack[ stack_i_ ].object->mode, lay_height );
                        stack_i_--;
                        if( ~stack[ stack_i_ ].i )
                            stack[ stack_i_ ].i--;
                    }while( !~stack[ stack_i_ ].i );
                    E_mem_Q_blk_I_remove( &stack, stack_i_ + 1, stack_i_1 - stack_i_ );
                    object = E_mem_Q_tab_R( window->object, stack[ stack_i_ ].object->child[ stack[ stack_i_ ].i ] );
                }
Cont:           do
                {   object = stack[ stack_i ].object;
                }while( ~--stack_i
                && !stack[ stack_i ].i
                );
                U_F( object->mode, lay_height );
                W(stack);
                object = E_mem_Q_tab_R( window->object, 0 );
                goto Restart;
            }
            next_y -= E_gui_xcb_Q_object_S_layout_dy;
            if( after_y < stack[ stack_i ].object->y + stack[ stack_i ].object->height + E_gui_xcb_Q_object_S_layout_dy )
                after_y = stack[ stack_i ].object->y + stack[ stack_i ].object->height + E_gui_xcb_Q_object_S_layout_dy;
        }while( ~--stack_i
        && ++stack[ stack_i ].i == stack[ stack_i ].object->child_n
        );
        if( !~stack_i )
            break;
        E_mem_Q_blk_I_remove( &stack, stack_i + 1, stack_i_1 - stack_i );
        object = E_mem_Q_tab_R( window->object, stack[ stack_i ].object->child[ stack[ stack_i ].i ] );
    }
    W(stack);
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_gui_xcb_Q_object_I_draw_Z_draw_proc( void (*draw_object_proc)( struct E_gui_xcb_Q_display_Z *, struct E_gui_xcb_Q_screen_Z *, struct E_gui_xcb_Q_window_Z *, struct E_gui_xcb_Q_object_Z * )
, B draw_simple
){  B U_L( x_window, draw );
    for_each( display_id, E_gui_xcb_Q_display_S, E_mem_Q_tab )
    {   struct E_gui_xcb_Q_display_Z *display = E_mem_Q_tab_R( E_gui_xcb_Q_display_S, display_id );
        if( draw_simple )
            U_F( display->mode, draw_simple );
        for_each( window_id, display->window, E_mem_Q_tab )
        {   struct E_gui_xcb_Q_window_Z *window = E_mem_Q_tab_R( display->window, window_id );
            for_each( object_id, window->object, E_mem_Q_tab )
            {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                if( object->draw == draw_object_proc )
                {   U_F( window->req, draw );
                    break;
                }
            }
            if( U_R( window->req, draw ))
                U_F( display->req, draw );
        }
        if( U_R( display->mode, drag ))
        {   struct E_gui_xcb_Q_screen_Z *screen = E_mem_Q_tab_R( display->screen, display->drag_S_dnd_window_screen_id );
            struct E_gui_xcb_Q_window_Z *window = &screen->dnd_window;
            for_each( object_id, window->object, E_mem_Q_tab )
            {   struct E_gui_xcb_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                if( object->draw == draw_object_proc )
                {   U_F( window->req, draw );
                    break;
                }
            }
            if( U_R( window->req, draw ))
                U_F( display->req, draw );
        }
        if( U_R( display->req, draw ))
            U_F( x_window, draw );
    }
        #ifdef C_pthreads
    if( U_R( x_window, draw ))
    {   Vr_( pthread_mutex_lock( &E_x_window_D_draw_S_mutex ));
        E_x_window_D_draw_S_b = yes;
        Vr_( pthread_cond_signal( &E_x_window_D_draw_S_cond ));
        Vr_( pthread_mutex_unlock( &E_x_window_D_draw_S_mutex ));
    }
        #endif
}
/******************************************************************************/
