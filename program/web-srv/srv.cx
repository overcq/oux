/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  server
*   ---   web server
*         server
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”             2020‒4‒11 P
*******************************************************************************/
#define S_server_name           "OUX/C+ web-srv"
#define S_php_index_file        "index.php"
#define S_html_index_file       "index.html"
#define S_listen_backlog        1024
#define S_request_buffer_l      4096
#define S_read_buffer_l         ( 64 * 1024 )
#define S_keepalive_timeout     5
#define S_system_idle_time      0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #ifndef __gnu_linux__
extern char **environ;
    #endif
    #ifdef __gnu_linux__
int E_srv_S_epoll_fd;
struct epoll_event *E_srv_S_ee_ready = 0;
N E_srv_S_ee_ready_n = 0;
    #else
struct pollfd *E_srv_S_poll_fd = 0;
N E_srv_S_poll_fd_n = 0;
    #endif
SSL_CTX *E_srv_S_ssl_ctx = 0;
int E_srv_S_ssl_ret;
struct E_srv_Z_srv
{ N virtualhost_i;
  Pc canonical;
  B ssl;
  int *sfd;
  N sfd_n;
} *E_srv_S_srv;
N E_srv_S_srv_n = 0;
struct E_srv_Z_accept
{ int poll_fd;
  int listen_sock;
  SSL *ssl;
  struct sockaddr peer_addr;
  int file;
  off_t file_size;
  Pc buf, buf_, buf_2;
  N buf_l;
  Z_clock_time keepalive_tv;
  off_t l, first_l;
  B stream;
  pid_t child;
} *E_srv_S_accept;
N E_srv_S_accept_n = 0;
int E_srv_S_poll_pipe[2] = { -1, -1 };
int E_srv_S_subprocess_pipe[2];
struct E_srv_Z_s
{ Pc start, end;
};
struct E_srv_Z_inheaders
{ struct E_srv_Z_s request, path, query, protocol, accept, accept_charset, accept_encoding, accept_language, connection, cookie, host, referrer, user_agent;
};
//==============================================================================
N
E_srv_M( void
){  B ssl = no;
    for_n( i, E_conf_S_virtualhost_n )
        if( E_conf_S_virtualhost[i].ssl )
        {   ssl = yes;
            break;
        }
    if(ssl)
    {   E_srv_S_ssl_ctx = SSL_CTX_new( TLS_server_method() );
        if( SSL_CTX_set_min_proto_version( E_srv_S_ssl_ctx, TLS1_VERSION ) != 1
        || SSL_CTX_use_certificate_file( E_srv_S_ssl_ctx, E_conf_S_virtualhost[i].certificate_path, SSL_FILETYPE_PEM ) != 1
        || SSL_CTX_use_PrivateKey_file( E_srv_S_ssl_ctx, E_conf_S_virtualhost[i].private_key_path, SSL_FILETYPE_PEM ) != 1
        )
        {   E_srv_W();
            return ~0;
        }
    }
    for_n_( i, E_conf_S_virtualhost_n )
    {   struct addrinfo ai_hints =
        { .ai_flags = AI_CANONNAME | AI_NUMERICSERV
        , .ai_family = 0
        , .ai_socktype = SOCK_STREAM
        , .ai_protocol = 0
        };
        struct addrinfo *ai;
        N l = E_text_Z_n_N_s_G( E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        C port[l];
        E_text_Z_n_N_s( &port[0] + l, E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        port[l] = '\0';
        V0( getaddrinfo( E_conf_S_virtualhost[i].ip, &port[0], &ai_hints, &ai ))
        {   E_srv_W();
            return ~0;
        }
        if( !E_mem_Q_blk_I_append( &E_srv_S_srv, 1 ))
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_srv_S_srv_n++;
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].virtualhost_i = i;
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].ssl = E_conf_S_virtualhost[i].ssl;
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n = 0;
        l = E_text_Z_s0_R_0_l( ai->ai_canonname );
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical = M(l);
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_text_Z_s_P_s0_copy_0( E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical, ai->ai_canonname );
        Mt_( E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 0 );
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        struct addrinfo *ai_1 = ai;
        do
        {   struct sockaddr_in *sa;
            struct sockaddr_in6 *sa6;
            if( ai_1->ai_family == AF_INET )
                sa = (P)ai_1->ai_addr;
            else
                sa6 = (P)ai_1->ai_addr;
            int sfd;
            V1( sfd = socket( ai_1->ai_family, SOCK_STREAM, 0 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            if( !E_mem_Q_blk_I_append( &E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 1 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n++;
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd[ E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n - 1 ] = sfd;
            V0( bind( sfd, ai_1->ai_addr, ai_1->ai_family == AF_INET ? sizeof( *sa ) : sizeof( *sa6 )))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            V0( listen( sfd, S_listen_backlog ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            ai_1 = ai_1->ai_next;
        }while( ai_1 );
        freeaddrinfo(ai);
            #ifdef __gnu_linux__
        V1( E_srv_S_epoll_fd = epoll_create1(0) )
        {   E_srv_W();
            return ~0;
        }
        struct epoll_event ee;
        ee.events = EPOLLIN;
        for_n( j, E_srv_S_srv_n )
        {   for_n( k, E_srv_S_srv[j].sfd_n )
            {   ee.data.fd = E_srv_S_srv[j].sfd[k];
                V0( epoll_ctl( E_srv_S_epoll_fd, EPOLL_CTL_ADD, E_srv_S_srv[j].sfd[k], &ee ))
                {   E_srv_W();
                    return ~0;
                }
                E_srv_S_ee_ready_n++;
            }
        }
            #else
        for_n( j, E_srv_S_srv_n )
        {   for_n( k, E_srv_S_srv[j].sfd_n )
                E_srv_S_poll_fd_n++;
        }
        Mt_( E_srv_S_poll_fd, E_srv_S_poll_fd_n + 1 );
        if( !E_srv_S_poll_fd )
        {   E_srv_W();
            return ~0;
        }
        E_srv_S_poll_fd_n = 0;
        for_n_( j, E_srv_S_srv_n )
        {   for_n( k, E_srv_S_srv[j].sfd_n )
            {   E_srv_S_poll_fd[ E_srv_S_poll_fd_n ].fd = E_srv_S_srv[j].sfd[k];
                E_srv_S_poll_fd[ E_srv_S_poll_fd_n ].events = POLLIN;
                E_srv_S_poll_fd_n++;
            }
        }
            #endif
        V0( pipe( &E_srv_S_poll_pipe[0] ))
        {   E_srv_W();
            return ~0;
        }
            #ifdef __gnu_linux__
        ee.data.fd = E_srv_S_poll_pipe[0];
        V0( epoll_ctl( E_srv_S_epoll_fd, EPOLL_CTL_ADD, E_srv_S_poll_pipe[0], &ee ))
        {   V0( close( E_srv_S_poll_pipe[0] )){}
            V0( close( E_srv_S_poll_pipe[1] )){}
            E_srv_W();
            return ~0;
        }
        E_srv_S_ee_ready_n++;
        Mt_( E_srv_S_ee_ready, E_srv_S_ee_ready_n );
        if( !E_srv_S_ee_ready )
        {   V0( close( E_srv_S_poll_pipe[0] )){}
            V0( close( E_srv_S_poll_pipe[1] )){}
            E_srv_W();
            return ~0;
        }
            #else
        E_srv_S_poll_fd[ E_srv_S_poll_fd_n ].fd = E_srv_S_poll_pipe[0];
        E_srv_S_poll_fd[ E_srv_S_poll_fd_n ].events = POLLIN;
        E_srv_S_poll_fd_n++;
            #endif
    }
    return 0;
}
void
E_srv_W( void
){
        #ifdef __gnu_linux__
    W( E_srv_S_ee_ready );
    V0( close( E_srv_S_epoll_fd )){}
        #else
    W( E_srv_S_poll_fd );
        #endif
    if( E_srv_S_ssl_ctx )
        SSL_CTX_free( E_srv_S_ssl_ctx );
    for_n( i, E_srv_S_srv_n )
    {   W( E_srv_S_srv[i].canonical );
        for_n( j, E_srv_S_srv[i].sfd_n )
        {   V0( close( E_srv_S_srv[i].sfd[j] )){}
        }
        W( E_srv_S_srv[i].sfd );
    }
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N
E_srv_Q_reply_I_s0_add_header_1( Pc *headers
, N *headers_l
, Pc s
){  N l;
    if( !( l = E_text_Z_s_I_s0_append( headers, s )))
        return 0;
    *headers_l += l;
    return l;
}
N
E_srv_Q_reply_I_s_add_header_1( Pc *headers
, N *headers_l
, Pc s
, Pc s_end
){  N l;
    if( !( l = E_text_Z_s_I_s_append( headers, s, s_end )))
        return 0;
    *headers_l += l;
    return l;
}
N
E_srv_Q_reply_I_add_header_2( Pc *headers
, N *headers_l
){  N l;
    if( !( l = E_text_Z_s_I_s0_append( headers, "\r\n" )))
        return 0;
    *headers_l += l;
    return l;
}
N
E_srv_Q_reply_I_s0_add_header( Pc *headers
, N *headers_l
, Pc s
){  N headers_l_ = *headers_l;
    if( !E_srv_Q_reply_I_s0_add_header_1( headers, headers_l, s ))
        return 0;
    if( !E_srv_Q_reply_I_add_header_2( headers, headers_l ))
    {   E_mem_Q_blk_I_rem( headers, headers_l_, *headers_l - headers_l_ );
        *headers_l = headers_l_;
        return 0;
    }
    return *headers_l - headers_l_;
}
N
E_srv_Q_reply_I_s_add_header( Pc *headers
, N *headers_l
, Pc s
, Pc s_end
){  N headers_l_ = *headers_l;
    if( !E_srv_Q_reply_I_s_add_header_1( headers, headers_l, s, s_end ))
        return 0;
    if( !E_srv_Q_reply_I_add_header_2( headers, headers_l ))
    {   E_mem_Q_blk_I_rem( headers, headers_l_, *headers_l - headers_l_ );
        *headers_l = headers_l_;
        return 0;
    }
    return *headers_l - headers_l_;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_srv_D_srv_I_unblock( P p
){  C c;
    VO1_( write( E_srv_S_poll_pipe[1], &c, sizeof(C) ));
}
D( srv, srv )
{   Xh_A( E_srv_D_srv_I_unblock );
    I_D
    {   N n;
        Xh_B_();
            #ifdef __gnu_linux__
        VO1_( n = epoll_wait( E_srv_S_epoll_fd, E_srv_S_ee_ready, E_srv_S_ee_ready_n, E_srv_S_accept_n ? S_system_idle_time : -1 ));
            #else
        VO1_( n = poll( E_srv_S_poll_fd, E_srv_S_poll_fd_n, E_srv_S_accept_n ? S_system_idle_time : -1 ));
            #endif
        Xh_B()
        {   for_n( i, E_srv_S_accept_n )
            {   if( E_srv_S_accept[i].file != -1 )
                {   V0( close( E_srv_S_accept[i].file )){}
                }
                if( E_srv_S_accept[i].ssl )
                {   SSL_shutdown( E_srv_S_accept[i].ssl );
                    SSL_free( E_srv_S_accept[i].ssl );
                }
                if( E_srv_S_accept[i].buf_2 )
                    W( E_srv_S_accept[i].buf_2 );
                if( E_srv_S_accept[i].child != -1 )
                {   V0( kill( E_srv_S_accept[i].child, SIGTERM )){}
                }
                W( E_srv_S_accept[i].buf );
                V0( close( E_srv_S_accept[i].listen_sock )){}
            }
            break;
        }
            #ifdef __gnu_linux__
        for_n( i, n )
        {
            #else
        for_n( i, E_srv_S_poll_fd_n )
        {   if( !E_srv_S_poll_fd[i].revents )
                continue;
            #endif
            for_n( j, E_srv_S_srv_n )
            {   for_n( k, E_srv_S_srv[j].sfd_n )
                        #ifdef __gnu_linux__
                    if( E_srv_S_srv[j].sfd[k] == E_srv_S_ee_ready[i].data.fd )
                        #else
                    if( E_srv_S_srv[j].sfd[k] == E_srv_S_poll_fd[i].fd )
                        #endif
                        goto End_4;
            }
End_4:      ;
            struct sockaddr peer_addr;
            int listen_sock;
            socklen_t sock_l = sizeof( peer_addr );
                #ifdef __gnu_linux__
            VO1( listen_sock = accept( E_srv_S_ee_ready[i].data.fd, &peer_addr, &sock_l ))
                #else
            VO1( listen_sock = accept( E_srv_S_poll_fd[i].fd, &peer_addr, &sock_l ))
                #endif
            {   E_srv_W();
                V();
            }
            if( !E_mem_Q_blk_I_append( &E_srv_S_accept, 1 ))
            {   V0( close( listen_sock )){}
                continue;
            }
            E_srv_S_accept_n++;
            if( E_srv_S_srv[j].ssl )
            {   E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl = SSL_new( E_srv_S_ssl_ctx );
                if( !E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl )
                {   E_mem_Q_blk_I_rem( &E_srv_S_accept, --E_srv_S_accept_n, 1 );
                    V0( close( listen_sock )){}
                    continue;
                }
                if( SSL_set_fd( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl, listen_sock ) != 1 )
                {   SSL_free( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                    E_mem_Q_blk_I_rem( &E_srv_S_accept, --E_srv_S_accept_n, 1 );
                    V0( close( listen_sock )){}
                    continue;
                }
                int e = SSL_accept( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                if( !e )
                {   SSL_free( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                    E_mem_Q_blk_I_rem( &E_srv_S_accept, --E_srv_S_accept_n, 1 );
                    V0( close( listen_sock )){}
                    continue;
                }
                if( e < 0 )
                {   e = SSL_get_error( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl, e );
                    if( e != SSL_ERROR_SYSCALL
                    || e != SSL_ERROR_SSL
                    )
                        SSL_shutdown( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                    SSL_free( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                    E_mem_Q_blk_I_rem( &E_srv_S_accept, --E_srv_S_accept_n, 1 );
                    V0( close( listen_sock )){}
                    continue;
                }
            }else
                E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl = 0;
                #ifdef __gnu_linux__
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].poll_fd = E_srv_S_ee_ready[i].data.fd;
                #else
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].poll_fd = E_srv_S_poll_fd[i].fd;
                #endif
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].listen_sock = listen_sock;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].peer_addr = peer_addr;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].file = -1;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf = M( S_request_buffer_l );
            if( !E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf )
            {   E_reply_I_code( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl, listen_sock, 500, yes, no );
                if( E_srv_S_srv[j].ssl )
                {   SSL_shutdown( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                    SSL_free( E_srv_S_accept[ E_srv_S_accept_n - 1 ].ssl );
                }
                E_mem_Q_blk_I_rem( &E_srv_S_accept, --E_srv_S_accept_n, 1 );
                V0( close( listen_sock )){}
                continue;
            }
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf_2 = 0;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf_l = 0;
            _gettime( &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv );
            Z_clock_time tv;
            tv.tv_sec = S_keepalive_timeout;
            tv.Z_clock_time_minor_field = 0;
            _timeradd( &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv, &tv, &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv );
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].child = -1;
            G_(); Gd(j); Gs0_( "połączenie przyjęte" );
        }
        for_n_( i, E_srv_S_accept_n )
        {   if( E_srv_S_accept[i].file == -1 )
            {   if( !E_srv_S_accept[i].buf_l )
                {   fd_set readfds;
Next:               FD_ZERO( &readfds );
                    FD_SET( E_srv_S_accept[i].listen_sock, &readfds );
                    struct timeval tv = { 0, 0 };
                    int e;
                    V1e( select( E_srv_S_accept[i].listen_sock + 1, &readfds, 0, 0, &tv ), e )
                    {   if( e == EINTR || e == EAGAIN )
                            goto Next;
                        goto End_1;
                    }
                    if( !FD_ISSET( E_srv_S_accept[i].listen_sock, &readfds ))
                    {   Z_clock_time tv;
                        _gettime( &tv );
                        if( _timercmp( &tv, <, &E_srv_S_accept[i].keepalive_tv ))
                            continue;
                        goto End_1;
                    }
                    if( E_srv_S_accept[i].ssl )
                    {   if(( E_srv_S_ssl_ret = SSL_read_ex( E_srv_S_accept[i].ssl, E_srv_S_accept[i].buf, S_request_buffer_l, &E_srv_S_accept[i].buf_l )) != 1 )
                            goto End_1;
                    }else
                    {   VO1( E_srv_S_accept[i].buf_l = read( E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf, S_request_buffer_l ))
                        {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, no );
                            goto End_1;
                        }
                    }
                    if( !E_srv_S_accept[i].buf_l )
                        goto End_1;
                    G_(); Gd(i); Gs0_( "odczytano nagłówek" ); Gd( E_srv_S_accept[i].buf_l );
                    //G_(); Gd(i); Gs_l( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf_l );
                }else
                {   fd_set readfds;
Next_1:             FD_ZERO( &readfds );
                    FD_SET( E_srv_S_accept[i].listen_sock, &readfds );
                    struct timeval tv = { 0, 0 };
                    int e;
                    V1e( select( E_srv_S_accept[i].listen_sock + 1, &readfds, 0, 0, &tv ), e )
                    {   if( e == EINTR || e == EAGAIN )
                            goto Next_1;
                        goto End_1;
                    }
                    if( FD_ISSET( E_srv_S_accept[i].listen_sock, &readfds ))
                    {   if( E_srv_S_accept[i].buf != E_srv_S_accept[i].buf_ ) ///Jeżeli nie przeskoczono z post.
                            E_mem_Q_blk_I_copy( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf_, E_srv_S_accept[i].buf_l );
                        N l;
                        if( E_srv_S_accept[i].ssl )
                        {   if(( E_srv_S_ssl_ret = SSL_read_ex( E_srv_S_accept[i].ssl, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, S_request_buffer_l - E_srv_S_accept[i].buf_l, &l )) != 1 )
                                goto End_1;
                        }else
                        {   VO1( l = read( E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, S_request_buffer_l - E_srv_S_accept[i].buf_l ))
                            {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, no );
                                goto End_1;
                            }
                        }
                        G_(); Gd(i); Gs0_( "doczytano nagłówek" ); Gd(l);
                        //G_(); Gd(i); Gs_l( E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, l );
                        E_srv_S_accept[i].buf_l += l;
                    }
                }
                G_(); Gd(i); Gs0_( "parsowanie nagłówka" );
                Pc s = E_text_Z_s_R_c_search( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                if( s == E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l
                || s == E_srv_S_accept[i].buf
                || *( s - 1 ) != '\r'
                ){  E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, no );
                    goto End_1;
                }
                struct E_srv_Z_inheaders inheader;
                inheader.protocol.end = s - 1;
                s = E_text_Z_s_R_c_search( E_srv_S_accept[i].buf, inheader.protocol.end, ' ' );
                if( s == inheader.protocol.end )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, no );
                    goto End_1;
                }
                inheader.request.start = E_srv_S_accept[i].buf;
                inheader.request.end = s;
                inheader.path.start = s + 1;
                B post = E_text_Z_s_T_s0_eq( inheader.request.start, inheader.request.end, "POST" );
                if( !post
                && !E_text_Z_s_T_s0_eq( inheader.request.start, inheader.request.end, "GET" )
                ){  E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, no );
                    goto End_1;
                }
                Pc s_1 = E_text_Z_s_R_c_search_last( inheader.path.start, inheader.protocol.end, ' ' );
                inheader.protocol.start = s_1 + 1;
                B http_1 = E_text_Z_s_T_s0_eq( inheader.protocol.start, inheader.protocol.end, "HTTP/1.1" );
                if( !http_1
                && !E_text_Z_s_T_s0_eq( inheader.protocol.start, inheader.protocol.end, "HTTP/1.0" )
                )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                    goto End_1;
                }
                inheader.path.end = inheader.protocol.start - 1;
                inheader.query.start = E_text_Z_s_R_c_search( inheader.path.start, inheader.path.end, '?' );
                if( inheader.query.start != inheader.path.end )
                {   inheader.query.end = inheader.path.end;
                    inheader.path.end = inheader.query.start;
                    inheader.query.start++;
                }else
                    inheader.query.start = 0;
                ///Unescape.
                for( Pc s_1 = inheader.path.start, s; ( s = E_text_Z_s_R_c_search( s_1, inheader.path.end, '+' )) != inheader.path.end; s_1 = s + 1 )
                    *s_1 = ' ';
                for( Pc s_1 = inheader.path.start, s; ( s = E_text_Z_s_R_c_search( s_1, inheader.path.end, '%' )) != inheader.path.end; s_1 = s + 1 )
                {   if( !*( s + 1 )
                    || !*( s + 2 )
                    )
                    {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                        goto End_1;
                    }
                    C c = E_text_Z_s_N_n( s + 1, s + 3, &s_1, 16 );
                    if( s_1 != s + 3 )
                    {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                        goto End_1;
                    }
                    if( !E_mem_Q_blk_I_rem( &E_srv_S_accept[i].buf, s + 1 - E_srv_S_accept[i].buf, 2 ))
                    {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    if( !E_mem_Q_blk_I_append( &E_srv_S_accept[i].buf, 2 ))
                    {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    *s = c;
                }
                if( *( s + 1 ) != '/' )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                    goto End_1;
                }
                for_n( j, E_srv_S_srv_n )
                {   for_n( k, E_srv_S_srv[j].sfd_n )
                        if( E_srv_S_srv[j].sfd[k] == E_srv_S_accept[i].poll_fd )
                            goto End;
                }
End:            ;
                N l = E_text_Z_s0_R_0_l( E_conf_S_virtualhost[ E_srv_S_srv[j].virtualhost_i ].root_path ) + 1;
                Pc path = M(l);
                if( !path )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                    goto End_1;
                }
                Pc path_end = E_text_Z_s_P_s0_copy( path, E_conf_S_virtualhost[ E_srv_S_srv[j].virtualhost_i ].root_path );
                *path_end = '/';
                N path_uri_i = path_end - path;
                path_end++;
                ///Normalizacja ścieżki żądania: eliminacja powtórzonych separatorów, sprawdzenie, czy nie wychodzi poza root_path.
                N path_uri_end_i = path_uri_i + 1;
                s = path;
                N path_n = 0;
                while(( s = E_text_Z_s_R_c_search( s + 1, path_end, '/' )) != path_end )
                    path_n++;
                N path_n_0 = path_n;
                s = inheader.path.start;
                O{  s_1 = E_text_Z_s_R_c_search( s + 1, inheader.path.end, '/' );
                    if( s_1 == inheader.path.end )
                        break;
                    if( s_1 == s + 1 )
                    {   s = s_1;
                        continue;
                    }
                    Pc s_2;
                    for( s_2 = s + 1; s_2 != s_1; s_2++ )
                        if( *s_2 != '.' )
                            break;
                    if( s_2 == s_1 )
                    {   if( path_n < path_n_0 + ( s_1 - ( s + 1 ) - 1 ))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                            goto End_1;
                        }
                        if( s_1 - ( s + 1 ) - 1 > 1 )
                        {   path_n -= s_1 - ( s + 1 ) - 1;
                            s_2 = path;
                            for_n( k, path_n )
                                s_2 = E_text_Z_s_R_c_search( s_2 + 1, path_end, '/' );
                            N s_2_i = s_2 - path;
                            if( !E_mem_Q_blk_I_rem( &path, s_2 + 1 - path, path_end - ( s_2 + 1 )))
                            {   W(path);
                                E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                                goto End_1;
                            }
                            s_2 = path + s_2_i;
                            path_uri_end_i -= path_end - ( s_2 + 1 );
                            path_end = s_2 + 1;
                        }
                    }else
                    {   N path_i = path_end - path;
                        if( !E_mem_Q_blk_I_append( &path, s_1 + 1 - ( s + 1 )))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                            goto End_1;
                        }
                        path_end = path + path_i;
                        path_uri_end_i += s_1 + 1 - ( s + 1 );
                        path_end = E_text_Z_s_P_s_copy( path_end, s + 1, s_1 + 1 );
                        path_n++;
                    }
                    s = s_1;
                }
                ///Dodanie ostatniego wpisu na ścieżce lub pliku index.
                if( s_1 - ( s + 1 ))
                {   N path_end_i = path_end - path;
                    if( !E_mem_Q_blk_I_append( &path, s_1 - ( s + 1 )))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    path_end = path + path_end_i;
                    path_end = E_text_Z_s_P_s_copy( path_end, s + 1, s_1 );
                    *path_end = '\0';
                    path_uri_end_i = path_end - path;
                }else
                {   N path_end_i = path_end - path;
                    if( !E_mem_Q_blk_I_append( &path, E_text_Z_s0_R_l( S_php_index_file )))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    path_end = path + path_end_i;
                    path_end = E_text_Z_s_P_s0_copy( path_end, S_php_index_file );
                    *path_end = '\0';
                    V0( access( path, F_OK ))
                    {   if( !E_mem_Q_blk_I_rem( &path, path_end_i, E_text_Z_s0_R_l( S_php_index_file )))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                            goto End_1;
                        }
                        if( !E_mem_Q_blk_I_append( &path, E_text_Z_s0_R_l( S_html_index_file )))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                            goto End_1;
                        }
                        path_end = path + path_end_i;
                        path_end = E_text_Z_s_P_s0_copy( path_end, S_html_index_file );
                        *path_end = '\0';
                    }
                }
                G_(); Gd(i); Gs0(path);
                B gz = no;
                B keep_alive = http_1;
                N post_l = 0;
                ///Przetworzenie przychodzących nagłówków.
                inheader.accept.start = 0;
                inheader.accept_charset.start = 0;
                inheader.accept_encoding.start = 0;
                inheader.accept_language.start = 0;
                inheader.connection.start = 0;
                inheader.cookie.start = 0;
                inheader.host.start = 0;
                inheader.referrer.start = 0;
                inheader.user_agent.start = 0;
                s = E_text_Z_s_R_c_search( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                O{  s_1 = E_text_Z_s_R_c_search( s + 1, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                    if( s_1 == E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l )
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    if( s_1 == s + 1
                    || *( s_1 - 1 ) != '\r'
                    )
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                        goto End_1;
                    }
                    if( s_1 == s + 1 + 1 )
                    {   E_srv_S_accept[i].buf_l -= s_1 + 1 - E_srv_S_accept[i].buf;
                        E_srv_S_accept[i].buf_ = s_1 + 1;
                        break;
                    }
                    Pc line_start = s + 1;
                    Pc line_end = s_1 - 1;
                    Pc s_2 = E_text_Z_s_R_c_search( line_start, line_end, ':' );
                    if( s_2 == line_end )
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                        goto End_1;
                    }
                    Pc content_start = s_2 + 1;
                    while( *content_start == ' ' )
                        content_start++;
                    if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Accept" ))
                    {   inheader.accept.start = content_start;
                        inheader.accept.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Accept-Charset" ))
                    {   inheader.accept_charset.start = content_start;
                        inheader.accept_charset.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Accept-Encoding" ))
                    {   inheader.accept_encoding.start = content_start;
                        inheader.accept_encoding.end = line_end;
                        E_text_Z_s_P_lower( inheader.accept_encoding.start, inheader.accept_encoding.end );
                        Pc s = E_text_Z_s_R_s0_search( inheader.accept_encoding.start, inheader.accept_encoding.end, "gzip" );
                        if( s != inheader.accept_encoding.end )
                            gz = yes;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Accept-Language" ))
                    {   inheader.accept_language.start = content_start;
                        inheader.accept_language.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Connection" ))
                    {   inheader.connection.start = content_start;
                        inheader.connection.end = line_end;
                        E_text_Z_s_P_lower( inheader.connection.start, inheader.connection.end );
                        if( http_1 )
                        {   Pc s = E_text_Z_s_R_s0_search( content_start, line_end, "close" );
                            if( s != inheader.connection.end )
                                keep_alive = no;
                        }else
                        {   Pc s = E_text_Z_s_R_s0_search( content_start, line_end, "keep-alive" );
                            if( s != inheader.connection.end )
                                keep_alive = yes;
                        }
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Content-Type" ))
                    {   if(post)
                        {   Pc s = E_text_Z_s_R_s0_search( content_start, line_end, "application/x-www-form-urlencoded" );
                            if( s == line_end )
                            {   s = E_text_Z_s_R_s0_search( content_start, line_end, "multipart/form-data" );
                                if( s == line_end )
                                {   W(path);
                                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                                    goto End_1;
                                }
                            }
                        }
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Content-Length" ))
                    {   if(post)
                        {   Pc s;
                            post_l = E_text_Z_s_N_n10( content_start, line_end, &s );
                            if( s != line_end )
                            {   W(path);
                                E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                                goto End_1;
                            }
                        }
                        if( !post && post_l )
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 400, yes, http_1 );
                            goto End_1;
                        }
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Cookie" ))
                    {   inheader.cookie.start = content_start;
                        inheader.cookie.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Host" ))
                    {   inheader.host.start = content_start;
                        inheader.host.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "Referer" ))
                    {   inheader.referrer.start = content_start;
                        inheader.referrer.end = line_end;
                    }else if( E_text_Z_s_T_s0_eq_case( line_start, s_2, "User-Agent" ))
                    {   inheader.user_agent.start = content_start;
                        inheader.user_agent.end = line_end;
                    }
                    s = s_1;
                }
                Pc body = s_1 + 1;
                ///Przesunięcie o dane wysłane w formularzu.
                if(post)
                {   if( post_l > S_request_buffer_l - ( body - E_srv_S_accept[i].buf ))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    if( E_srv_S_accept[i].buf_l < post_l )
                    {   W(path);
                        Z_clock_time tv;
                        _gettime( &tv );
                        if( _timercmp( &tv, <, &E_srv_S_accept[i].keepalive_tv ))
                        {   E_srv_S_accept[i].buf_l += E_srv_S_accept[i].buf_ - E_srv_S_accept[i].buf;
                            E_srv_S_accept[i].buf_ = E_srv_S_accept[i].buf;
                            goto Next_1;
                        }
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, yes, http_1 );
                        goto End_1;
                    }
                    E_srv_S_accept[i].buf_ += post_l;
                    E_srv_S_accept[i].buf_l -= post_l;
                }
                B php = E_text_Z_s0_T_s0_ends( path, ".php" );
                if(php)
                {   gz = no; ///Nie obsługuje kompresji strumienia PHP.
                    V0( access( path, F_OK ))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 404, no, http_1 );
                        goto End_3;
                    }
                    N args_n = 1;
                    struct E_flow_Z_args *Mt_( args, args_n );
                    if( !args )
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    V0( pipe( &E_srv_S_subprocess_pipe[0] ))
                    {   W(args);
                        W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    E_srv_S_accept[i].file = E_srv_S_subprocess_pipe[0];
                    pid_t pid = E_flow_I_fork_I_begin();
                    if( !pid )
                    {   E_flow_I_fork_I_start();
                        {   for_n( i, E_srv_S_accept_n )
                            {   V0( close( E_srv_S_accept[i].listen_sock )){}
                            }
                                #ifdef __gnu_linux__
                            V0( close( E_srv_S_epoll_fd )){}
                                #endif
                            for_n_( i, E_srv_S_srv_n )
                            {   for_n( j, E_srv_S_srv[i].sfd_n )
                                {   V0( close( E_srv_S_srv[i].sfd[j] )){}
                                }
                            }
                        }
                        VO1_( dup2( E_srv_S_subprocess_pipe[1], STDOUT_FILENO ));
                        V0_( close( E_srv_S_subprocess_pipe[1] ));
                        N environ_n = 27 + ( post ? 2 : 0 );
                        N environ_i = 0;
                        environ = Mt( sizeof( Pc ), environ_n );
                        if( !environ )
                        {   G_(); V();
                        }
                        environ[ environ_i++ ] = "GATEWAY_INTERFACE=CGI/1.1";
                        environ[ environ_i++ ] = E_srv_S_accept[i].ssl ? "SERVER_PORT=443" : "SERVER_PORT=80"; //TODO Rzeczywiste porty.
                        l = E_text_Z_s0_R_l( "SERVER_NAME=" ) + E_text_Z_s0_R_l( E_srv_S_srv[j].canonical ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "SERVER_NAME=" ), E_srv_S_srv[j].canonical );
                        environ[ environ_i++ ] = s;
                        environ[ environ_i++ ] = "SERVER_SOFTWARE=" S_server_name;
                        environ[ environ_i++ ] = "SERVER_PROTOCOL=HTTP/1.1";
                        l = E_text_Z_s0_R_l( "REQUEST_METHOD=" ) + inheader.request.end - inheader.request.start + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s_copy_0( E_text_Z_s_P_s0_copy( s, "REQUEST_METHOD=" ), inheader.request.start, inheader.request.end );
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "QUERY_STRING=" ) + ( inheader.query.start ? inheader.query.end - inheader.query.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "QUERY_STRING=" );
                        if( inheader.query.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.query.start, inheader.query.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_ACCEPT=" ) + ( inheader.accept.start ? inheader.accept.end - inheader.accept.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_ACCEPT=" );
                        if( inheader.accept.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.accept.start, inheader.accept.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_ACCEPT_CHARSET=" ) + ( inheader.accept_charset.start ? inheader.accept_charset.end - inheader.accept_charset.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_ACCEPT_CHARSET=" );
                        if( inheader.accept_charset.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.accept_charset.start, inheader.accept_charset.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_ACCEPT_ENCODING=" ) + ( inheader.accept_encoding.start ? inheader.accept_encoding.end - inheader.accept_encoding.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_ACCEPT_ENCODING=" );
                        if( inheader.accept_encoding.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.accept_encoding.start, inheader.accept_encoding.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_ACCEPT_LANGUAGE=" ) + ( inheader.accept_language.start ? inheader.accept_language.end - inheader.accept_language.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_ACCEPT_LANGUAGE=" );
                        if( inheader.accept_language.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.accept_language.start, inheader.accept_language.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_CONNECTION=" ) + ( inheader.connection.start ? inheader.connection.end - inheader.connection.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_CONNECTION=" );
                        if( inheader.connection.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.connection.start, inheader.connection.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_COOKIE=" ) + ( inheader.cookie.start ? inheader.cookie.end - inheader.cookie.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_COOKIE=" );
                        if( inheader.cookie.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.cookie.start, inheader.cookie.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_HOST=" ) + ( inheader.host.start ? inheader.host.end - inheader.host.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_HOST=" );
                        if( inheader.host.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.host.start, inheader.host.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_REFERER=" ) + ( inheader.referrer.start ? inheader.referrer.end - inheader.referrer.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_REFERER=" );
                        if( inheader.referrer.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.referrer.start, inheader.referrer.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTP_USER_AGENT=" ) + ( inheader.user_agent.start ? inheader.user_agent.end - inheader.user_agent.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s0_copy( s, "HTTP_USER_AGENT=" );
                        if( inheader.user_agent.start )
                            E_text_Z_s_P_s_copy_0( s_1, inheader.user_agent.start, inheader.user_agent.end );
                        else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "HTTPS=" ) + ( E_srv_S_accept[i].ssl ? 1 : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "HTTPS=" ),  E_srv_S_accept[i].ssl ? "1" : "" );
                        environ[ environ_i++ ] = s;
                        Pc ip;
                        N16 port;
                        if( E_srv_S_accept[i].peer_addr.sa_family == AF_INET )
                        {   ip = M( INET_ADDRSTRLEN + 1 );
                            if( !ip )
                            {   G_(); V();
                            }
                            E_mem_Q_blk_P_fill_c( ip, INET_ADDRSTRLEN + 1, 0 );
                            struct sockaddr_in *sa = (P)&E_srv_S_accept[i].peer_addr;
                            Vp_( inet_ntop( E_srv_S_accept[i].peer_addr.sa_family, &sa->sin_addr, ip, INET_ADDRSTRLEN ));
                            port = ntohs( sa->sin_port );
                        }else
                        {   ip = M( INET6_ADDRSTRLEN + 1 );
                            if( !ip )
                            {   G_(); V();
                            }
                            E_mem_Q_blk_P_fill_c( ip, INET6_ADDRSTRLEN + 1, 0 );
                            struct sockaddr_in6 *sa = (P)&E_srv_S_accept[i].peer_addr;
                            Vp_( inet_ntop( E_srv_S_accept[i].peer_addr.sa_family, &sa->sin6_addr, ip, INET6_ADDRSTRLEN ));
                            port = ntohs( sa->sin6_port );
                        }
                        G_(); Gd(i); Gs0(ip);
                        l = E_text_Z_s0_R_l( "REMOTE_ADDR=" ) + E_text_Z_s0_R_l(ip) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "REMOTE_ADDR=" ), ip );
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "REMOTE_HOST=" ) + E_text_Z_s0_R_l(ip) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "REMOTE_HOST=" ), ip );
                        environ[ environ_i++ ] = s;
                        environ[ environ_i++ ] = "AUTH_TYPE=";
                        environ[ environ_i++ ] = "PATH_INFO=";
                        N port_l = E_text_Z_n_N_s_G( port, sizeof(port), 10 );
                        l = E_text_Z_s0_R_l( "REMOTE_PORT=" ) + port_l + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy( s, "REMOTE_PORT=" );
                        E_text_Z_n_N_s( s + E_text_Z_s0_R_l( "REMOTE_PORT=" ) + port_l, port, sizeof(port), 10 );
                        *( s + E_text_Z_s0_R_l( "REMOTE_PORT=" ) + port_l ) = '\0';
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "REQUEST_URI=" ) + E_text_Z_s0_R_l( path + path_uri_i ) - E_text_Z_s0_R_l( path + path_uri_end_i ) + 1 + ( inheader.query.start ? inheader.query.end - inheader.query.start : 0 ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        s_1 = E_text_Z_s_P_s_copy( E_text_Z_s_P_s0_copy( s, "REQUEST_URI=" ), path + path_uri_i, path + path_uri_end_i );
                        if( inheader.query.start )
                        {   *s_1++ = '?';
                            E_text_Z_s_P_s_copy_0( s_1, inheader.query.start, inheader.query.end );
                        }else
                            *s_1 = '\0';
                        environ[ environ_i++ ] = s;
                        environ[ environ_i++ ] = "REDIRECT_STATUS=200";
                        l = E_text_Z_s0_R_l( "SCRIPT_FILENAME=" ) + E_text_Z_s0_R_l(path) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "SCRIPT_FILENAME=" ), path );
                        environ[ environ_i++ ] = s;
                        l = E_text_Z_s0_R_l( "SCRIPT_NAME=" ) + E_text_Z_s0_R_l( path + path_uri_i ) + 1;
                        s = M(l);
                        if( !s )
                        {   G_(); V();
                        }
                        E_text_Z_s_P_s0_copy_0( E_text_Z_s_P_s0_copy( s, "SCRIPT_NAME=" ), path + path_uri_i );
                        environ[ environ_i++ ] = s;
                        if(post)
                        {   environ[ environ_i++ ] = "CONTENT_TYPE=application/x-www-form-urlencoded";
                            N l_1 = E_text_Z_n_N_s_G( post_l, sizeof( post_l ), 10 );
                            l = E_text_Z_s0_R_l( "CONTENT_LENGTH=" ) + l_1 + 1;
                            s = M(l);
                            if( !s )
                            {   G_(); V();
                            }
                            E_text_Z_s_P_s0_copy( s, "CONTENT_LENGTH=" );
                            E_text_Z_n_N_s( s + E_text_Z_s0_R_l( "CONTENT_LENGTH=" ) + l_1, post_l, sizeof( post_l ), 10 );
                            *( s + E_text_Z_s0_R_l( "CONTENT_LENGTH=" ) + l_1 ) = '\0';
                            environ[ environ_i++ ] = s;
                            int tmp_pipe[2];
                            V0_( pipe( &tmp_pipe[0] ));
                            VO1_( dup2( tmp_pipe[0], STDIN_FILENO ));
                            V0_( close( tmp_pipe[0] ));
                            E_reply_I_data( 0, tmp_pipe[1], body, post_l );
                            V0_( close( tmp_pipe[1] ));
                        }else
                        {   V0_( close( STDIN_FILENO ));
                        }
                        environ[ environ_i ] = 0;
                        J_assert( environ_i == environ_n - 1 );
                        args[0].argc = 1;
                        args[0].argv = ( Pc[] ){ "php-cgi", 0 };
                        E_flow_I_fork_I_exec( 0, args, args_n );
                    }
                    E_flow_I_fork_I_end(pid);
                    E_srv_S_accept[i].child = pid;
                    W(args);
                    V0( close( E_srv_S_subprocess_pipe[1] )){}
                }else if( !gz
                || E_text_Z_s0_T_s0_ends( path, ".gz" )
                )
                {   gz = no;
                    V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                    {   *path_end = '\0';
                        W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 404, no, http_1 );
                        goto End_3;
                    }
                }else
                {   N path_i = path_end - path;
                    if( !E_mem_Q_blk_I_append( &path, 3 ))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    path_end = path + path_i;
                    E_text_Z_s_P_s0_copy_0( path_end, ".gz" );
                    V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                    {   gz = no;
                        *path_end = '\0';
                        V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 404, no, http_1 );
                            goto End_3;
                        }
                    }
                }
                W(path);
                if( post
                && !php
                )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 403, no, http_1 );
                    goto End_3;
                }
                E_srv_S_accept[i].stream = http_1 ? php : no;
                Pc headers = M(0);
                if( !headers )
                {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                N headers_l = 0;
                if( !E_srv_Q_reply_I_s0_add_header_1( &headers, &headers_l, "Host: " ))
                {   W(headers);
                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                if( !E_srv_Q_reply_I_s0_add_header_1( &headers, &headers_l, E_srv_S_srv[j].canonical ))
                {   W(headers);
                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                if( !E_srv_Q_reply_I_add_header_2( &headers, &headers_l ))
                {   W(headers);
                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Server: " S_server_name ))
                {   W(headers);
                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                E_srv_S_accept[i].l = 0;
                if( E_srv_S_accept[i].stream )
                {   if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Transfer-Encoding: chunked" ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                }else if( http_1 )
                {   struct stat stat;
                    V0( fstat( E_srv_S_accept[i].file, &stat ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    E_srv_S_accept[i].file_size = stat.st_size;
                    if( !E_srv_Q_reply_I_s0_add_header_1( &headers, &headers_l, "Content-Length: " ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    l = E_text_Z_n_N_s_G( stat.st_size, sizeof( stat.st_size ), 10 );
                    s = M(l);
                    if( !s )
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    E_text_Z_n_N_s( s + l, stat.st_size, sizeof( stat.st_size ), 10 );
                    if( !E_srv_Q_reply_I_s_add_header( &headers, &headers_l, s, s + l ))
                    {   W(s);
                        W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    W(s);
                }
                if(gz)
                {   if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Content-Encoding: gzip" ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                }
                if( keep_alive )
                {   if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Connection: keep-alive" )) //NDFN Czy ten nagłówek jest wymagany dla HTTP/1.1?
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Keep-alive: timeout=" J_s( S_keepalive_timeout ) ", max=1000" ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                }else
                    if( !E_srv_Q_reply_I_s0_add_header( &headers, &headers_l, "Connection: close" ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                if( inheader.cookie.start )
                {   if( !E_srv_Q_reply_I_s0_add_header_1( &headers, &headers_l, "Cookie: " ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    if( !E_srv_Q_reply_I_s_add_header( &headers, &headers_l, inheader.cookie.start, inheader.cookie.end ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                }
                if( !E_srv_S_accept[i].buf_2 )
                {   E_srv_S_accept[i].buf_2 = M( S_read_buffer_l );
                    if( !E_srv_S_accept[i].buf_2 )
                    {   E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                }
                N status = 200;
                if(php)
                {   N l;
                    VO1( l = read( E_srv_S_accept[i].file, E_srv_S_accept[i].buf_2, S_read_buffer_l ))
                    {   W(headers);
                        E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                        goto End_3;
                    }
                    Pc s;
                    O{  s = E_text_Z_s_R_s0_search( E_srv_S_accept[i].buf_2, E_srv_S_accept[i].buf_2 + l, "\r\n\r\n" );
                        if( s == E_srv_S_accept[i].buf_2 )
                        {   W(headers);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                            goto End_3;
                        }
                        if( s != E_srv_S_accept[i].buf_2 + l )
                            break;
                        if( l == S_read_buffer_l )
                        {   W(headers);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                            goto End_3;
                        }
                        N l_1;
                        VO1( l_1 = read( E_srv_S_accept[i].file, E_srv_S_accept[i].buf_2 + l, S_read_buffer_l - l ))
                        {   W(headers);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                            goto End_3;
                        }
                        l += l_1;
                    }
                    Pc s_1 = E_srv_S_accept[i].buf_2;
                    if( E_text_Z_s_T_s0_eq_case( E_srv_S_accept[i].buf_2, E_srv_S_accept[i].buf_2 + 8, "Status: " ))
                    {   s_1 = E_text_Z_s_R_s0_search( E_srv_S_accept[i].buf_2 + 8, E_srv_S_accept[i].buf_2 + l, "\r\n" );
                        //G_(); Gd(i); Gs_l( E_srv_S_accept[i].buf_2, s_1 - E_srv_S_accept[i].buf_2 );
                        Pc s = E_text_Z_s_R_c_search( E_srv_S_accept[i].buf_2 + 8, s_1, ' ' );
                        status = E_text_Z_s_N_n( E_srv_S_accept[i].buf_2 + 8, s, &s, 10 );
                        s_1 += 2;
                    }
                    O{  s = E_text_Z_s_R_s0_search( s_1, E_srv_S_accept[i].buf_2 + l, "\r\n" );
                        if( s == s_1 )
                            break;
                        if( !E_srv_Q_reply_I_s_add_header( &headers, &headers_l, s_1, s ))
                        {   W(headers);
                            E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                            goto End_3;
                        }
                        s_1 = s + 2;
                    }
                    E_srv_S_accept[i].first_l = l - ( s + 2 - E_srv_S_accept[i].buf_2 );
                    E_mem_Q_blk_I_copy( E_srv_S_accept[i].buf_2, s + 2, E_srv_S_accept[i].first_l );
                }else
                    E_srv_S_accept[i].first_l = 0;
                if( !E_srv_Q_reply_I_add_header_2( &headers, &headers_l ))
                {   W(headers);
                    E_reply_I_code( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, 500, no, http_1 );
                    goto End_3;
                }
                if( !~E_reply_I_code_( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, status, no, no, http_1 ))
                {   W(headers);
                    goto End_2;
                }
                //G_(); Gd(i); Gs_l( headers, headers_l - 4 );
                if( !~E_reply_I_data( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, headers, headers_l ))
                {   W(headers);
                    goto End_2;
                }
                W(headers);
            }else
            {   N l;
                if( E_srv_S_accept[i].first_l )
                {   l = E_srv_S_accept[i].first_l;
                    E_srv_S_accept[i].first_l = 0;
                }else
                {   VO1( l = read( E_srv_S_accept[i].file, E_srv_S_accept[i].buf_2, S_read_buffer_l ))
                        goto End_2;
                }
                if( !E_srv_S_accept[i].stream )
                {   if( !l )
                        goto End_2;
                    if( E_srv_S_accept[i].l + l > E_srv_S_accept[i].file_size )
                        l = E_srv_S_accept[i].file_size - E_srv_S_accept[i].l;
                }
                if( E_srv_S_accept[i].stream )
                {   N l_1 = E_text_Z_n_N_s_G( l, sizeof(l), 16 ) + 2;
                    C s[ l_1 ];
                    E_text_Z_n_N_s( &s[ l_1 - 2 ], l, sizeof(l), 16 );
                    s[ l_1 - 2 ] = '\r';
                    s[ l_1 - 1 ] = '\n';
                    if( !~E_reply_I_data( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, &s[0], l_1 ))
                        goto End_2;
                }
                E_srv_S_accept[i].l += l;
                G_(); Gd(i); Gd(l);
                if( !~E_reply_I_data( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf_2, l ))
                    goto End_2;
                if( E_srv_S_accept[i].stream )
                {   Pc s = "\r\n";
                    if( !~E_reply_I_data( E_srv_S_accept[i].ssl, E_srv_S_accept[i].listen_sock, s, 2 ))
                        goto End_2;
                }
                if(( E_srv_S_accept[i].stream
                  && l
                )
                || ( !E_srv_S_accept[i].stream
                  && E_srv_S_accept[i].l < E_srv_S_accept[i].file_size
                ))
                    continue;
End_3:          if( E_srv_S_accept[i].file != -1 )
                {   V0( close( E_srv_S_accept[i].file )){}
                    E_srv_S_accept[i].file = -1;
                }
                if( E_srv_S_accept[i].child != -1 )
                {   V0( kill( E_srv_S_accept[i].child, SIGTERM )){}
                    E_srv_S_accept[i].child = -1;
                }
                _gettime( &E_srv_S_accept[i].keepalive_tv );
                Z_clock_time tv;
                tv.tv_sec = S_keepalive_timeout;
                tv.Z_clock_time_minor_field = 0;
                _timeradd( &E_srv_S_accept[i].keepalive_tv, &tv, &E_srv_S_accept[i].keepalive_tv );
                G_(); Gd(i); Gs0_( "koniec transmisji" );
            }
            continue;
End_2:      ;
            V0( close( E_srv_S_accept[i].file )){}
            if( E_srv_S_accept[i].child != -1 )
            {   V0( kill( E_srv_S_accept[i].child, SIGTERM )){}
            }
End_1:      if( E_srv_S_accept[i].ssl )
            {   int e = SSL_get_error( E_srv_S_accept[i].ssl, E_srv_S_ssl_ret );
                if( e != SSL_ERROR_SYSCALL
                || e != SSL_ERROR_SSL
                )
                    SSL_shutdown( E_srv_S_accept[i].ssl );
                SSL_free( E_srv_S_accept[i].ssl );
            }
            W( E_srv_S_accept[i].buf_2 );
            W( E_srv_S_accept[i].buf );
            V0( close( E_srv_S_accept[i].listen_sock )){}
            if( !E_mem_Q_blk_I_rem( &E_srv_S_accept, i, 1 ))
            {   E_srv_W();
                V();
            }
            E_srv_S_accept_n--;
            G_(); Gd(i); Gs0_( "koniec połączenia" );
            i--;
        }
    }
    E_srv_W();
}
/******************************************************************************/
