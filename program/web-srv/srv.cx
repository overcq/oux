/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  server
*   ---   web server
*         server
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”             2020‒4‒11 P
*******************************************************************************/
#define S_listen_backlog 1024
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int E_srv_S_epoll_fd;
struct epoll_event *E_srv_S_ee_ready = 0;
N E_srv_S_ee_ready_n = 0;
struct E_srv_Z_srv
{ Pc canonical;
  int *sfd;
  N sfd_n;
} *E_srv_S_srv;
N E_srv_S_srv_n = 0;
//==============================================================================
N
E_srv_M( void
){ for_n( i, E_conf_S_virtualhost_n )
    {   struct addrinfo ai_hints =
        { .ai_flags = AI_CANONNAME | AI_NUMERICSERV
        , .ai_family = AF_INET
        , .ai_socktype = SOCK_STREAM
        , .ai_protocol = 0
        };
        struct addrinfo *ai;
        N l = E_text_Z_n_N_s_G( E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        C port[l];
        E_text_Z_n_N_s( &port[0] + l, E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        port[l] = '\0';
        V0( getaddrinfo( E_conf_S_virtualhost[i].ip, &port[0], &ai_hints, &ai ))
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        if( !E_mem_Q_blk_I_append( &E_srv_S_srv, 1 ))
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_srv_S_srv_n++;
        l = E_text_Z_s0_R_0_l( ai->ai_canonname );
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical = M(l);
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_text_Z_s0_P_copy_0( E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical, ai->ai_canonname );
        Mt_( E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 0 );
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n = 0;
        struct addrinfo *ai_1 = ai;
        do
        {   int sfd;
            V1( sfd = socket( AF_INET, SOCK_STREAM, 0 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            if( !E_mem_Q_blk_I_append( &E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 1 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n++;
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd[ E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n - 1 ] = sfd;
            ai_1->ai_addr->sa_family = ai_1->ai_family;
            V0( bind( sfd, ai_1->ai_addr, sizeof( *ai_1->ai_addr )))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            V0( listen( sfd, S_listen_backlog ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            ai_1 = ai_1->ai_next;
        }while( ai_1 );
        freeaddrinfo(ai);
        V1( E_srv_S_epoll_fd = epoll_create1(0) )
        {   E_srv_W();
            return ~0;
        }
        struct epoll_event ee;
        ee.events = EPOLLIN;
        for_n( i, E_srv_S_srv_n )
        {   for_n( j, E_srv_S_srv[i].sfd_n )
            {   ee.data.fd = E_srv_S_srv[i].sfd[j];
                V0( epoll_ctl( E_srv_S_epoll_fd, EPOLL_CTL_ADD, E_srv_S_srv[i].sfd[j], &ee ))
                {   E_srv_W();
                    return ~0;
                }
                E_srv_S_ee_ready_n++;
            }
        }
        Mt_( E_srv_S_ee_ready, E_srv_S_ee_ready_n );
        if( !E_srv_S_ee_ready )
        {   E_srv_W();
            return ~0;
        }
    }
    return 0;
}
void
E_srv_W( void
){  for_n( i, E_srv_S_srv_n )
    {   W( E_srv_S_srv[i].canonical );
        for_n( j, E_srv_S_srv[i].sfd_n )
        {   V1( close( E_srv_S_srv[i].sfd[j] )){}
        }
        W( E_srv_S_srv[i].sfd );
    }
    W( E_srv_S_srv );
}
D( srv, srv )
{   I timer = Y_M(182999);
    I_D
    {   N n;
        V1( n = epoll_wait( E_srv_S_epoll_fd, E_srv_S_ee_ready, E_srv_S_ee_ready_n, 0 ))
        {   E_srv_W();
            V();
        }
        if(n)
        {   
        }
        Y_B( timer, 0 )
            break;
    }
    Y_W(timer);
}
/******************************************************************************/
