/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  server
*   ---   web server
*         server
* ©overcq                on ‟Gentoo Linux 17.1” “x86_64”             2020‒4‒11 P
*******************************************************************************/
#define S_listen_backlog    1024
#define S_request_buffer_l  4096
#define S_read_buffer_l     ( 4096 * 64 )
#define S_index_file        "index.html"
#define S_keepalive_timeout 5
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int E_srv_S_epoll_fd;
struct epoll_event *E_srv_S_ee_ready = 0;
N E_srv_S_ee_ready_n = 0;
struct E_srv_Z_srv
{ N virtualhost_i;
  Pc canonical;
  int *sfd;
  N sfd_n;
} *E_srv_S_srv;
N E_srv_S_srv_n = 0;
struct E_srv_Z_accept
{ int epoll_fd;
  int listen_sock;
  int file;
  off_t file_size;
  Pc buf, buf_, buf_2;
  N buf_l;
  Z_clock_time keepalive_tv;
  off_t l;
} *E_srv_S_accept;
N E_srv_S_accept_n = 0;
//==============================================================================
N
E_srv_M( void
){ for_n( i, E_conf_S_virtualhost_n )
    {   struct addrinfo ai_hints =
        { .ai_flags = AI_CANONNAME | AI_NUMERICSERV
        , .ai_family = AF_INET
        , .ai_socktype = SOCK_STREAM
        , .ai_protocol = 0
        };
        struct addrinfo *ai;
        N l = E_text_Z_n_N_s_G( E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        C port[l];
        E_text_Z_n_N_s( &port[0] + l, E_conf_S_virtualhost[i].port, sizeof( E_conf_S_virtualhost[i].port ), 10 );
        port[l] = '\0';
        V0( getaddrinfo( E_conf_S_virtualhost[i].ip, &port[0], &ai_hints, &ai ))
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        if( !E_mem_Q_blk_I_append( &E_srv_S_srv, 1 ))
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_srv_S_srv_n++;
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].virtualhost_i = i;
        l = E_text_Z_s0_R_0_l( ai->ai_canonname );
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical = M(l);
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_text_Z_s0_P_copy_0( E_srv_S_srv[ E_srv_S_srv_n - 1 ].canonical, ai->ai_canonname );
        Mt_( E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 0 );
        if( !E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd )
        {   freeaddrinfo(ai);
            E_srv_W();
            return ~0;
        }
        E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n = 0;
        struct addrinfo *ai_1 = ai;
        do
        {   int sfd;
            V1( sfd = socket( AF_INET, SOCK_STREAM, 0 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            if( !E_mem_Q_blk_I_append( &E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd, 1 ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n++;
            E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd[ E_srv_S_srv[ E_srv_S_srv_n - 1 ].sfd_n - 1 ] = sfd;
            ai_1->ai_addr->sa_family = ai_1->ai_family;
            V0( bind( sfd, ai_1->ai_addr, sizeof( *ai_1->ai_addr )))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            V0( listen( sfd, S_listen_backlog ))
            {   freeaddrinfo(ai);
                E_srv_W();
                return ~0;
            }
            ai_1 = ai_1->ai_next;
        }while( ai_1 );
        freeaddrinfo(ai);
        V1( E_srv_S_epoll_fd = epoll_create1(0) )
        {   E_srv_W();
            return ~0;
        }
        struct epoll_event ee;
        ee.events = EPOLLIN;
        for_n( i, E_srv_S_srv_n )
        {   for_n( j, E_srv_S_srv[i].sfd_n )
            {   ee.data.fd = E_srv_S_srv[i].sfd[j];
                V0( epoll_ctl( E_srv_S_epoll_fd, EPOLL_CTL_ADD, E_srv_S_srv[i].sfd[j], &ee ))
                {   E_srv_W();
                    return ~0;
                }
                E_srv_S_ee_ready_n++;
            }
        }
        Mt_( E_srv_S_ee_ready, E_srv_S_ee_ready_n );
        if( !E_srv_S_ee_ready )
        {   E_srv_W();
            return ~0;
        }
    }
    return 0;
}
void
E_srv_W( void
){  for_n( i, E_srv_S_srv_n )
    {   W( E_srv_S_srv[i].canonical );
        for_n( j, E_srv_S_srv[i].sfd_n )
        {   V0( close( E_srv_S_srv[i].sfd[j] )){}
        }
        W( E_srv_S_srv[i].sfd );
    }
    W( E_srv_S_srv );
}
D( srv, srv )
{   I_D
    {   N n;
        V1( n = epoll_wait( E_srv_S_epoll_fd, E_srv_S_ee_ready, E_srv_S_ee_ready_n, E_srv_S_accept_n ? 0 : 1000 ))
        {   E_srv_W();
            V();
        }
        for_n( i, n )
        {   for_n( j, E_srv_S_accept_n )
                if( E_srv_S_accept[j].epoll_fd == E_srv_S_ee_ready[i].data.fd )
                    break;
            if( j != E_srv_S_accept_n )
                continue;
            int listen_sock;
            struct sockaddr peer_addr;
            socklen_t sock_l = sizeof( peer_addr );
            VO1( listen_sock = accept( E_srv_S_ee_ready[i].data.fd, &peer_addr, &sock_l ))
            {   E_srv_W();
                V();
            }
            if( !E_mem_Q_blk_I_append( &E_srv_S_accept, 1 ))
            {   E_reply_I_code( listen_sock, 500 );
                continue;
            }
            E_srv_S_accept_n++;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].epoll_fd = E_srv_S_ee_ready[i].data.fd;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].listen_sock = listen_sock;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].file = -1;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf = M( S_request_buffer_l );
            if( !E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf )
            {   E_reply_I_code( listen_sock, 500 );
                continue;
            }
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf_2 = 0;
            E_srv_S_accept[ E_srv_S_accept_n - 1 ].buf_l = 0;
            _gettime( &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv );
            Z_clock_time tv = { S_keepalive_timeout, 0 };
            _timeradd( &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv, &tv, &E_srv_S_accept[ E_srv_S_accept_n - 1 ].keepalive_tv );
        }
        for_n_( i, E_srv_S_accept_n )
        {   if( E_srv_S_accept[i].file == -1 )
            {   if( !E_srv_S_accept[i].buf_l )
                {   fd_set readfds;
                    O{  int e;
                        FD_ZERO( &readfds );
                        FD_SET( E_srv_S_accept[i].listen_sock, &readfds );
                        struct timeval tv = { 0, 0 };
                        V1e( select( E_srv_S_accept[i].listen_sock + 1, &readfds, 0, 0, &tv ), e )
                        {   if( e == EINTR || e == EAGAIN )
                                continue;
                            goto End_1;
                        }
                        break;
                    }
                    if( !FD_ISSET( E_srv_S_accept[i].listen_sock, &readfds ))
                    {   Z_clock_time tv;
                        _gettime( &tv );
                        if( _timercmp( &tv, <, &E_srv_S_accept[i].keepalive_tv ))
                            continue;
                        goto End_1;
                    }
                    VO1( E_srv_S_accept[i].buf_l = read( E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf, S_request_buffer_l ))
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    if( !E_srv_S_accept[i].buf_l )
                        goto End_1;
                }else
                {   fd_set readfds;
                    O{  int e;
                        FD_ZERO( &readfds );
                        FD_SET( E_srv_S_accept[i].listen_sock, &readfds );
                        struct timeval tv = { 0, 0 };
                        V1e( select( E_srv_S_accept[i].listen_sock + 1, &readfds, 0, 0, &tv ), e )
                        {   if( e == EINTR || e == EAGAIN )
                                continue;
                            goto End_1;
                        }
                        break;
                    }
                    if( FD_ISSET( E_srv_S_accept[i].listen_sock, &readfds ))
                    {   E_text_Z_s_P_copy_( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf_, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l );
                        N l;
                        VO1( l = read( E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, S_request_buffer_l - E_srv_S_accept[i].buf_l ))
                        {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                            goto End_1;
                        }
                        E_srv_S_accept[i].buf_l += l;
                    }
                }
                B keep_alive = yes;
                Pc s = E_text_Z_s_R_search_c( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                if( s == E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l
                || s == E_srv_S_accept[i].buf
                || *( s - 1 ) != '\r'
                ){  E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                    goto End_1;
                }
                G_(); Gd( E_srv_S_accept[i].buf_l ); Gs_l( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf_l );
                *( s - 1 ) = '\0';
                s = E_text_Z_s0_R_search_c( E_srv_S_accept[i].buf, ' ' );
                if( !*s )
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                    goto End_1;
                }
                *s = '\0';
                if( !E_text_Z_s0_T_eq( E_srv_S_accept[i].buf, "GET" ))
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                    goto End_1;
                }
                if( !E_text_Z_s0_T_ends( s + 1, " HTTP/1.1" )
                //&& !E_text_Z_s0_T_ends( s + 1, " HTTP/1.0" )
                )
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                    goto End_1;
                }
                Pc s_1 = E_text_Z_s0_R_search_last_c( s + 1, ' ' );
                *s_1 = '\0';
                if( *( s + 1 ) != '/' )
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                    goto End_1;
                }
                for( Pc s_1 = s + 1, s; *( s = E_text_Z_s0_R_search_c( s_1, '+' )); s_1 = s + 1 )
                    *s_1 = ' ';
                for( Pc s_1 = s + 1, s; *( s = E_text_Z_s0_R_search_c( s_1, '%' )); s_1 = s + 1 )
                {   if( !*( s + 1 )
                    || !*( s + 2 )
                    )
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                        goto End_1;
                    }
                    C c = E_text_Z_s_R_n( s + 1, s + 3, &s_1, 16 );
                    if( s_1 != s + 3 )
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                        goto End_1;
                    }
                    if( !E_mem_Q_blk_I_rem( &E_srv_S_accept[i].buf, s + 1 - E_srv_S_accept[i].buf, 2 ))
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    if( !E_mem_Q_blk_I_append( &E_srv_S_accept[i].buf, 2 ))
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    *s = c;
                }
                for_n( j, E_srv_S_srv_n )
                {   for_n( k, E_srv_S_srv[j].sfd_n )
                        if( E_srv_S_srv[j].sfd[k] == E_srv_S_ee_ready[i].data.fd )
                            goto End;
                }
End:            ;
                N l = E_text_Z_s0_R_0_l( E_conf_S_virtualhost[ E_srv_S_srv[j].virtualhost_i ].root_path ) + 1;
                Pc path = M(l);
                if( !path )
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                    goto End_1;
                }
                Pc path_ = E_text_Z_s0_P_copy( path, E_conf_S_virtualhost[ E_srv_S_srv[j].virtualhost_i ].root_path );
                *path_ = '/';
                path_++;
                Pc s_2 = path;
                N path_n = 0;
                while(( s_2 = E_text_Z_s_R_search_c( s_2 + 1, path_, '/' )) != path_ )
                    path_n++;
                N path_n_0 = path_n;
                O{  s_1 = E_text_Z_s0_R_search_c( s + 1, '/' );
                    if( !*s_1 )
                        break;
                    if( s_1 == s + 1 )
                    {   s = s_1;
                        continue;
                    }
                    for( s_2 = s + 1; s_2 != s_1; s_2++ )
                        if( *s_2 != '.' )
                            break;
                    if( s_2 == s_1 )
                    {   if( path_n < path_n_0 + ( s_1 - ( s + 1 ) - 1 ))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                            goto End_1;
                        }
                        if( s_1 - ( s + 1 ) - 1 > 1 )
                        {   path_n -= s_1 - ( s + 1 ) - 1;
                            s_2 = path;
                            for_n( k, path_n )
                                s_2 = E_text_Z_s_R_search_c( s_2 + 1, path_, '/' );
                            if( !E_mem_Q_blk_I_rem( &path, s_2 + 1 - path, path_ - ( s_2 + 1 )))
                            {   W(path);
                                E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                                goto End_1;
                            }
                            path_ = s_2 + 1;
                        }
                    }else
                    {   N path_i = path_ - path;
                        if( !E_mem_Q_blk_I_append( &path, s_1 + 1 - ( s + 1 )))
                        {   W(path);
                            E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                            goto End_1;
                        }
                        path_ = path + path_i;
                        path_ = E_text_Z_s_P_copy_( path_, s + 1, s_1 + 1 );
                        path_n++;
                    }
                    s = s_1;
                }
                if( s_1 - ( s + 1 ))
                {   N path_i = path_ - path;
                    if( !E_mem_Q_blk_I_append( &path, s_1 - ( s + 1 )))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    path_ = path + path_i;
                    path_ = E_text_Z_s_P_copy_( path_, s + 1, s_1 );
                }else
                {   N path_i = path_ - path;
                    if( !E_mem_Q_blk_I_append( &path, E_text_Z_s0_R_l( S_index_file )))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    path_ = path + path_i;
                    path_ = E_text_Z_s0_P_copy( path_, S_index_file );
                }
                *path_ = '\0';
                B gz = no;
                s = E_text_Z_s_R_search_c( E_srv_S_accept[i].buf, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                O{  s_1 = E_text_Z_s_R_search_c( s + 1, E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l, '\n' );
                    if( s_1 == E_srv_S_accept[i].buf + E_srv_S_accept[i].buf_l
                    || *( s_1 - 1 ) != '\r'
                    ){  E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                        goto End_1;
                    }
                    if( s + 1 + 1 == s_1 )
                    {   E_srv_S_accept[i].buf_l -= s_1 + 1 - E_srv_S_accept[i].buf;
                        E_srv_S_accept[i].buf_ = s_1 + 1;
                        break;
                    }
                    s_2 = E_text_Z_s_R_search_c( s + 1, s_1, ':' );
                    if( s_2 == s_1 )
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 400 );
                        goto End_1;
                    }
                    if( E_text_Z_s_T_eq( s + 1, s_2, "Accept-Encoding" ))
                    {   s_2 = E_text_Z_s_R_search_s0( s_2 + 1, s_1 - 1, "gzip" );
                        if( s_2 != s_1 - 1 )
                            gz = yes;
                    }else if( E_text_Z_s_T_eq( s + 1, s_2, "Connection" ))
                    {   s_2 = E_text_Z_s_R_search_s0( s_2 + 1, s_1 - 1, "close" );
                        if( s_2 != s_1 - 1 )
                            keep_alive = no;
                    }
                    s = s_1;
                }
                G_(); Gs(path);
                if( !gz
                || E_text_Z_s0_T_ends( path, ".gz" )
                ){  gz = no;
                    V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                    {   *path_ = '\0';
                        W(path);
                        E_reply_I_code( E_srv_S_accept[i].listen_sock, 404 );
                        goto End_1;
                    }
                }else
                {   N path_i = path_ - path;
                    if( !E_mem_Q_blk_I_append( &path, 3 ))
                    {   W(path);
                        E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_1;
                    }
                    path_ = path + path_i;
                    E_text_Z_s0_P_copy_0( path_, ".gz" );
                    V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                    {   gz = no;
                        *path_ = '\0';
                        V1( E_srv_S_accept[i].file = open( path, O_RDONLY ))
                        {   *path_ = '\0';
                            W(path);
                            E_reply_I_code( E_srv_S_accept[i].listen_sock, 404 );
                            goto End_1;
                        }
                    }
                }
                W(path);
                struct stat stat;
                V0( fstat( E_srv_S_accept[i].file, &stat ))
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                    goto End_2;
                }
                E_srv_S_accept[i].file_size = stat.st_size;
                E_srv_S_accept[i].l = 0;
                l = E_text_Z_s0_R_l( "Content-Length: " );
                N l_1 = E_text_Z_n_N_s_G( stat.st_size, sizeof( stat.st_size ), 10 );
                N l_2;
                if(gz)
                    l_2 = E_text_Z_s0_R_l( "\r\nContent-Encoding: gzip" );
                else
                    l_2 = 0;
                N l_3;
                if( keep_alive )
                    l_3 = E_text_Z_s0_R_l( "\r\nConnection: keep-alive\r\nKeep-alive: timeout=" J_s( S_keepalive_timeout ) ", max=1000" );
                else
                    l_3 = E_text_Z_s0_R_l( "\r\nConnection: close" );
                N l_4 = E_text_Z_s0_R_l( "\r\nHost: " ) + E_text_Z_s0_R_l( E_srv_S_srv[j].canonical );
                s = M( l + l_1 + l_2 + l_3 + l_4 + 4 );
                if( !s )
                {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                    goto End_2;
                }
                E_text_Z_s0_P_copy( s, "Content-Length: " );
                E_text_Z_n_N_s( s + l + l_1, stat.st_size, sizeof( stat.st_size ), 10 );
                if(gz)
                    E_text_Z_s0_P_copy( s + l + l_1, "\r\nContent-Encoding: gzip" );
                if( keep_alive )
                    E_text_Z_s0_P_copy( s + l + l_1 + l_2, "\r\nConnection: keep-alive\r\nKeep-alive: timeout=" J_s( S_keepalive_timeout ) ", max=1000" );
                else
                    E_text_Z_s0_P_copy( s + l + l_1 + l_2, "\r\nConnection: close" );
                E_text_Z_s0_P_copy( E_text_Z_s0_P_copy( s + l + l_1 + l_2 + l_3, "\r\nHost: " ), E_srv_S_srv[j].canonical );
                E_text_Z_s0_P_copy( s + l + l_1 + l_2 + l_3 + l_4, "\r\n\r\n" );
                E_reply_I_code( E_srv_S_accept[i].listen_sock, 200 );
                G_(); Gd( l + l_1 + l_2 + l_3 + l_4 + 4 ); Gs_l( s, l + l_1 + l_2 + l_3 + l_4 + 4 );
                if( !~E_reply_I_data( E_srv_S_accept[i].listen_sock, s, l + l_1 + l_2 + l_3 + l_4 + 4 ))
                    goto End_2;
            }else
            {   if( !E_srv_S_accept[i].buf_2 )
                {   E_srv_S_accept[i].buf_2 = M( S_read_buffer_l );
                    if( !E_srv_S_accept[i].buf_2 )
                    {   E_reply_I_code( E_srv_S_accept[i].listen_sock, 500 );
                        goto End_2;
                    }
                }
                N l;
                VO1( l = read( E_srv_S_accept[i].file, E_srv_S_accept[i].buf_2, S_read_buffer_l ))
                    goto End_2;
                if( !l )
                    goto End_2;
                if( E_srv_S_accept[i].l + l > E_srv_S_accept[i].file_size )
                    l = E_srv_S_accept[i].file_size - E_srv_S_accept[i].l;
                E_srv_S_accept[i].l += l;
                if( !~E_reply_I_data( E_srv_S_accept[i].listen_sock, E_srv_S_accept[i].buf_2, l ))
                    goto End_2;
                if( E_srv_S_accept[i].l < E_srv_S_accept[i].file_size )
                    continue;
                V0( close( E_srv_S_accept[i].file )){}
                E_srv_S_accept[i].file = -1;
                _gettime( &E_srv_S_accept[i].keepalive_tv );
                Z_clock_time tv = { S_keepalive_timeout, 0 };
                _timeradd( &E_srv_S_accept[i].keepalive_tv, &tv, &E_srv_S_accept[i].keepalive_tv );
            }
            continue;
End_2:      ;
            V0( close( E_srv_S_accept[i].file )){}
End_1:      W( E_srv_S_accept[i].buf_2 );
            W( E_srv_S_accept[i].buf );
            V0( close( E_srv_S_accept[i].listen_sock )){}
            if( !E_mem_Q_blk_I_rem( &E_srv_S_accept, i, 1 ))
            {   E_srv_W();
                V();
            }
            E_srv_S_accept_n--;
            i--;
        }
        I_B()
            break;
    }
}
/******************************************************************************/
