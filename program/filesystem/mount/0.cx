/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  C+
*  ¦/C+¦  filesystem
*   ---   mount
*         main
* ©overcq                on ‟Gentoo Linux 17.0” “x86_64”             2019‒3‒10 b
*******************************************************************************/
#define Z_inode_flags_1_S_directory     0x1000
#define Z_inode_flags_1_S_persistent    0x4000
#define Z_inode_flags_1_S_empty         0x8000
#define S_size_of_cluster               4096
#define Q_filesystem_S_buffer_size      ( 256 * 1024 )
//==============================================================================
struct E_main_Z_file_handle
{ N64 inode;
};
struct E_mem_Q_tab_Z *file_handles;
//------------------------------------------------------------------------------
struct E_main_Z_sort_free_blocks_range
{ N nodeid;
  N begin, end;
};
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C device_n_size;
N table_of_files_offset;
//==============================================================================
_internal
int
E_main_I_sort_free_blocks_cmp(
  const void *a_
, const void *b_
){  struct E_main_Z_sort_free_blocks_range *a = a_, *b = b_;
    return a->begin == b->begin ? 0 : ( a->begin > b->begin ? 1 : -1 );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
S32
E_main_Q_filesystem_I_move_data( N device_file_id
, N dst
, N src
, N l
){  J_assert( dst != src );
    J_assert(l);
    N buf_l = l > Q_filesystem_S_buffer_size ? Q_filesystem_S_buffer_size : l;
    Pc buf = M( buf_l );
    if( !buf )
        return -ENOMEM;
    if( dst < src )
    {   while(l)
        {   if( l < buf_l )
                buf_l = l;
            E_mem_Q_file_P_pos( device_file_id, src );
            if( E_mem_Q_file_R_s( device_file_id, buf, buf_l ))
                return 1;
            E_mem_Q_file_P_pos( device_file_id, dst );
            if( E_mem_Q_file_P_s( device_file_id, buf, buf_l ))
                return 1;
            src += buf_l;
            dst += buf_l;
            l -= buf_l;
        }
    }else
    {   src = src + l - buf_l;
        dst = dst + l - buf_l;
        while(l)
        {   if( l < buf_l )
                buf_l = l;
            E_mem_Q_file_P_pos( device_file_id, src );
            if( E_mem_Q_file_R_s( device_file_id, buf, buf_l ))
                return 1;
            E_mem_Q_file_P_pos( device_file_id, dst );
            if( E_mem_Q_file_P_s( device_file_id, buf, buf_l ))
                return 1;
            src -= buf_l;
            dst -= buf_l;
            l -= buf_l;
        }
    }
    W(buf);
    return 0;
}
//------------------------------------------------------------------------------
S32
E_main_Q_filesystem_R_allocated_blocks( N device_file_id
, struct E_main_Z_sort_free_blocks_range **free_blocks
, N *free_blocks_n
){  Mt_( *free_blocks, 0 );
    if( !*free_blocks )
        return -ENOMEM;
    *free_blocks_n = 0;
    N inode = FUSE_ROOT_ID;
    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
    O{  if( device->pos == device->l )
            break;
        inode++;
        N parent_dir_inode;
        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
        {   W( *free_blocks );
            return 1;
        }
        N file_size_in_last_cluster;
        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
        {   W( *free_blocks );
            return 1;
        }
        N16 flags_1 = file_size_in_last_cluster & 0xf000;
        N file_pos_in_the_only_cluster;
        N file_pos_cluster;
        N file_size_clusters;
        if( !( flags_1 & Z_inode_flags_1_S_directory ))
        {   file_size_in_last_cluster &= 0xfff;
            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
            {   W( *free_blocks );
                return 1;
            }
            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
            {   W( *free_blocks );
                return 1;
            }
            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
            {   W( *free_blocks );
                return 1;
            }
        }
        N i = 0;
        O{  C c;
            if( E_mem_Q_file_R_c( device_file_id, &c ))
            {   W( *free_blocks );
                return 1;
            }
            i++;
            if( !c )
                break;
        }
        if( flags_1 & Z_inode_flags_1_S_empty )
            continue;
        if( !( flags_1 & Z_inode_flags_1_S_directory )
        && file_size_clusters * S_size_of_cluster + file_size_in_last_cluster
        ){  if( !E_mem_Q_blk_I_append( free_blocks, 1 ))
            {   W( *free_blocks );
                return -ENOMEM;
            }
            (*free_blocks)[ *free_blocks_n ].nodeid = inode;
            (*free_blocks)[ *free_blocks_n ].begin = file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster;
            (*free_blocks)[ *free_blocks_n ].end = file_pos_cluster * S_size_of_cluster + file_size_clusters * S_size_of_cluster + file_pos_in_the_only_cluster + file_size_in_last_cluster; /// “file_size_clusters” albo “file_pos_in_the_only_cluster” jest 0.
            (*free_blocks_n)++;
        }
    }
    qsort( &(*free_blocks)[0], *free_blocks_n, sizeof( (*free_blocks)[0] ), &E_main_I_sort_free_blocks_cmp );
    return 0;
}
S32
E_main_Q_filesystem_I_allocate( N device_file_id
, struct E_main_Z_sort_free_blocks_range **free_blocks
, N free_blocks_n
, N file_size
, N *file_size_in_last_cluster
, N *file_pos_in_the_only_cluster
, N *file_pos_cluster
, N *file_size_clusters
){  N free_blocks_i;
    if( file_size >= S_size_of_cluster )
    {   for_n_( free_blocks_i, free_blocks_n )
        {   N begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, S_size_of_cluster );
            if( begin > (*free_blocks)[ free_blocks_i ].end )
                continue;
            if( (*free_blocks)[ free_blocks_i ].end - begin >= file_size )
            {   *file_size_in_last_cluster = file_size % S_size_of_cluster;
                *file_pos_in_the_only_cluster = 0;
                *file_pos_cluster = begin / S_size_of_cluster;
                *file_size_clusters = file_size / S_size_of_cluster;
                break;
            }
        }
    }else
    {   for_n_( free_blocks_i, free_blocks_n )
        {   N end = J_min( (*free_blocks)[ free_blocks_i ].end, E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, S_size_of_cluster ));
            if( end - (*free_blocks)[ free_blocks_i ].begin >= file_size )
            {   *file_size_in_last_cluster = file_size;
                *file_pos_in_the_only_cluster = (*free_blocks)[ free_blocks_i ].begin % S_size_of_cluster;
                *file_pos_cluster = (*free_blocks)[ free_blocks_i ].begin / S_size_of_cluster;
                *file_size_clusters = 0;
                break;
            }
        }
    }
    if( free_blocks_i == free_blocks_n ) /// Nie znalazł wolnego bloku, więc trzeba poprzesuwać pliki.
    {   return 1; // TODO Poprzesuwać pliki zamiast błędu.
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int
main(
  int argc
, char *argv[]
){  E_base_M( argc, argv );
    Pc device = 0;
    Pc directory = 0;
    B option = no;
    for( int i = 1; i != argc; i++ )
    {   if( option )
        {   option = no;
            continue;
        }
        if( *argv[i] == '-' )
        {   if( E_text_Z_s0_T_s0_eq( argv[i] + 1, "o" ))
            {   option = yes;
                continue;
            }
            E_base_W();
            return 1;
        }
        if(directory)
        {   E_base_W();
            return 1;
        }
        if(device)
            directory = argv[i];
        else
            device = argv[i];
    }
    if( !device
    || !directory
    || option
    ){  E_base_W();
        return 1;
    }
    I device_file_id;
    if( !~( device_file_id = E_mem_Q_file_M( device, no )))
    {   E_base_W();
        return 1;
    }
    E_mem_Q_file_P_pos( device_file_id, 439 );
    C filesystem_version;
    if( E_mem_Q_file_R_c( device_file_id, &filesystem_version )
    || filesystem_version != 1
    ){  E_base_W();
        return 1;
    }
    E_mem_Q_file_P_pos( device_file_id, 439 - 1 );
    C cluster_address_size_power_bit;
    if( E_mem_Q_file_R_c( device_file_id, &cluster_address_size_power_bit )
    || !cluster_address_size_power_bit
    || cluster_address_size_power_bit > 6
    ){  E_base_W();
        return 1;
    }
    device_n_size = ( 1 << cluster_address_size_power_bit ) / 8;
    E_mem_Q_file_P_pos( device_file_id, 439 - 1 - 2 - device_n_size );
    if( E_mem_Q_file_R_N( device_file_id, &table_of_files_offset, device_n_size ))
    {   E_base_W();
        return 1;
    }
    N table_of_files_pos_in_cluster;
    if( E_mem_Q_file_R_16( device_file_id, &table_of_files_pos_in_cluster ))
    {   E_base_W();
        return 1;
    }
    table_of_files_offset *= S_size_of_cluster;
    table_of_files_offset += table_of_files_pos_in_cluster;
    int fuse_fd;
    VO1( fuse_fd = open( "/dev/fuse", O_RDWR ))
    {   E_base_W();
        return 1;
    }
        #if defined( __gnu_linux__ )
    cap_t cap;
    Vp( cap = cap_get_proc() )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    cap_value_t cap_list[1] = { CAP_SYS_ADMIN };
    V1( cap_set_flag( cap, CAP_EFFECTIVE, 1, &cap_list[0], CAP_CLEAR ))
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=%u,allow_other", fuse_fd, 040000, getuid(), getgid(), S_size_of_cluster );
    V1( mount( device, directory, "fuseblk", 0, s_2 ))
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
    V1( cap_set_proc(cap) )
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    V1( cap_free(cap) )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
        #else
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=%u,allow_other", fuse_fd, 040000, getuid(), getgid(), S_size_of_cluster );
    V1( mount( device, directory, 0, s_2 ))
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
        #endif
    N buffer_size, buffer_read;
    P buffer = M( buffer_size = 256 * 1024 );
    if( !buffer )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N fuse_major;
    N fuse_minor;
    file_handles = E_mem_Q_tab_M( sizeof( struct E_main_Z_file_handle ), 0 );
    O{  int error;
        VO1e( buffer_read = read( fuse_fd, buffer, buffer_size ), error )
        {   if( error == ENODEV )
                goto End;
            goto Error;
        }
        struct fuse_in_header *in_buf = buffer;
        O{  if( buffer_read < sizeof( *in_buf ))
                goto Error;
            buffer_read -= sizeof( *in_buf );
            struct fuse_out_header out_buf;
            out_buf.len = sizeof( out_buf );
            out_buf.error = 0;
            out_buf.unique = in_buf->unique;
            G_(); Gd( in_buf->opcode );
            switch( in_buf->opcode )
            { default:
                    goto Error;
              case FUSE_INTERRUPT:
                {   struct fuse_interrupt_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FORGET:
                {   struct fuse_forget_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_BATCH_FORGET:
                {   struct fuse_batch_forget_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( buffer_read < in_buf_2->count * sizeof( struct fuse_forget_one ))
                        goto Error;
                    buffer_read -= in_buf_2->count * sizeof( struct fuse_forget_one );
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ) + in_buf_2->count * sizeof( struct fuse_forget_one ));
                    break;
                }
              case FUSE_INIT:
                {   struct fuse_init_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->major ); Gd( in_buf_2->minor );
                    if( in_buf_2->major > 7 )
                    {   fuse_major = 7;
                        fuse_minor = 0;
                    }else
                    {   fuse_major = in_buf_2->major;
                        if( in_buf_2->major == 7 )
                            fuse_minor = 26;
                        else
                        {   V();
                        }
                    }
                    G_(); Gd( fuse_major ); Gd( fuse_minor );
                    struct fuse_init_out out_buf_2;
                    out_buf.len += sizeof( out_buf_2 );
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.major = fuse_major;
                    out_buf_2.minor = fuse_minor;
                    if( fuse_major > 7
                    || ( fuse_major == 7 && fuse_minor >= 5
                    ))
                        out_buf_2.max_write = in_buf_2->max_readahead; //NDFN
                    out_buf_2.flags = FUSE_BIG_WRITES;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_DESTROY:
                    goto End;
              case FUSE_FLUSH:
                {   struct fuse_flush_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FSYNC:
                {   struct fuse_fsync_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_ACCESS:
                {   struct fuse_access_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf->nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        N16 flags_1;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == in_buf->nodeid )
                                break;
                        }
                        if( inode != in_buf->nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                            out_buf.error = -ENOENT;
                    }
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_LOOKUP:
                {   //TODO "." i ".."
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    N inode = FUSE_ROOT_ID;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        N file_size_clusters;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N inode_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            E_mem_Q_file_P_pos( device_file_id, inode_pos );
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                out_buf_2.nodeid = out_buf_2.attr.ino = inode;
                                out_buf_2.attr.nlink = 1;
                                if( flags_1 & Z_inode_flags_1_S_directory )
                                {   out_buf_2.attr.mode = S_IFDIR | 0777;
                                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                                    O{  if( device->pos == device->l )
                                            break;
                                        N i = 0;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        N file_size_in_last_cluster;
                                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                            goto Error;
                                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                                        if( parent_dir_inode == in_buf->nodeid
                                        && !( flags_1 & Z_inode_flags_1_S_empty )
                                        )
                                        {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                                            out_buf_2.attr.nlink++;
                                        }
                                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                                        {   N file_pos_in_the_only_cluster;
                                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                                goto Error;
                                            N file_pos_cluster;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                                goto Error;
                                            N file_size_clusters;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                                goto Error;
                                        }
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            i++;
                                            if( !c )
                                                break;
                                        }
                                    }
                                }else
                                {   out_buf_2.attr.size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                                    out_buf_2.attr.mode = S_IFREG | 0666;
                                }
                                out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( out_buf_2.attr.size, S_size_of_cluster ) / S_size_of_cluster;
                                out_buf.len += sizeof( out_buf_2 );
                                struct iovec bufs[2] =
                                { { &out_buf, sizeof( out_buf ) }
                                , { &out_buf_2, sizeof( out_buf_2 ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            W(s);
                        }
                    }
                    out_buf.error = -ENOENT;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_lookup:         in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_GETATTR:
                {   struct fuse_getattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = 1;
                    if( in_buf_2->getattr_flags & FUSE_GETATTR_FH )
                    {   if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                        struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                        out_buf_2.attr.ino = file_handle->inode;
                    }else
                    {   out_buf_2.attr.ino = in_buf->nodeid;
                    }
                    N file_size_in_last_cluster;
                    N file_size_clusters;
                    N16 flags_1;
                    if( out_buf_2.attr.ino != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == out_buf_2.attr.ino )
                                break;
                        }
                        if( inode != out_buf_2.attr.ino
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                    }else
                        flags_1 |= Z_inode_flags_1_S_directory;
                    if( flags_1 & Z_inode_flags_1_S_directory )
                    {   out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 2;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_1 & Z_inode_flags_1_S_empty )
                            )
                            {   out_buf_2.attr.size += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   out_buf_2.attr.size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                        out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( out_buf_2.attr.size, S_size_of_cluster ) / S_size_of_cluster;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_GETXATTR:
                {   struct fuse_getxattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LISTXATTR:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_SETATTR:
                {   struct fuse_setattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    N nodeid;
                    if( in_buf_2->valid & FATTR_FH )
                    {   if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_setattr;
                        }
                        struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                        nodeid = file_handle->inode;
                    }else
                        nodeid = in_buf->nodeid;
                    N rec_pos;
                    N file_size_in_last_cluster;
                    N16 flags_1;
                    N file_size_clusters;
                    if( nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            rec_pos = device->pos;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                        if( inode != nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {  out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_setattr;
                        }
                    }else
                        flags_1 |= Z_inode_flags_1_S_directory;
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = 1;
                    if( nodeid == FUSE_ROOT_ID
                    || flags_1 & Z_inode_flags_1_S_directory
                    ){  out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 1;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_1 & Z_inode_flags_1_S_empty )
                            )
                            {   out_buf_2.attr.size += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   N file_size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                        if( in_buf_2->valid & FATTR_SIZE
                        && in_buf_2->size != file_size
                        )
                        {   if( in_buf_2->size < file_size )
                            {   E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                                if( E_mem_Q_file_P_16( device_file_id, flags_1 | ( in_buf_2->size % S_size_of_cluster )))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 + device_n_size );
                                if( E_mem_Q_file_P_N( device_file_id, in_buf_2->size / S_size_of_cluster, device_n_size ))
                                    goto Error;
                            }else
                                goto Error; // TODO Przydzielić miejsce i wypełnić dodaną zawartość zerami.
                        }
                        out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_setattr:        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_OPEN:
              case FUSE_OPENDIR:
                {   struct fuse_open_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf->nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        N16 flags_1;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == in_buf->nodeid )
                                break;
                        }
                        if( inode != in_buf->nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_open;
                        }
                    }
                    struct fuse_open_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_2.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_open;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_2.fh );
                    file_handle->inode = in_buf->nodeid;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_open:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_READ:
              case FUSE_READDIR:
                {   struct fuse_read_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    N parent_dir_inode;
                    N file_size_in_last_cluster;
                    N16 flags_1;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    if( file_handle->inode != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  inode++;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   file_size_in_last_cluster &= 0xfff;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == file_handle->inode )
                                break;
                        }
                    }else
                    {   flags_1 |= Z_inode_flags_1_S_directory;
                        parent_dir_inode = file_handle->inode;
                    }
                    N len;
                    P out_buf_2;
                    if( flags_1 & Z_inode_flags_1_S_directory )
                    {   out_buf_2 = M( len = 0 );
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        N node_offset = 0;
                        N node_size = in_buf_2->size;
                        N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N inode_pos = device->pos;
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( flags_1 & Z_inode_flags_1_S_empty )
                                continue;
                            if( parent_dir_inode == file_handle->inode )
                            {   Pc s = M(i);
                                if( !s )
                                {   out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                E_mem_Q_file_P_pos( device_file_id, inode_pos );
                                if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                    goto Error;
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_offset >= in_buf_2->offset )
                                {   if( node_size < size )
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOBUFS;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    node_size -= size;
                                    len += size;
                                    if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                    *d = ( struct fuse_dirent )
                                    { inode
                                    , node_offset + size
                                    , i - 1
                                    , ( flags_1 & Z_inode_flags_1_S_directory ? S_IFDIR : S_IFREG ) >> 12
                                    };
                                    E_text_Z_s_P_s0_copy_0( d->name, s );
                                    E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                }
                                W(s);
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                            if( inode == file_handle->inode
                            && node_offset >= in_buf_2->offset
                            ){  N i = 2;
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_size < size )
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOBUFS;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                node_size -= size;
                                len += size;
                                if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                *d = ( struct fuse_dirent )
                                { inode
                                , node_offset + size
                                , i - 1
                                , S_IFDIR >> 12
                                };
                                E_text_Z_s_P_s0_copy_0( d->name, "." );
                                E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                        }
                        if( file_handle->inode == FUSE_ROOT_ID
                        && node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 2;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            node_size -= size;
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { file_handle->inode
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, "." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                            node_offset += size;
                        }
                        if( node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 3;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { parent_dir_inode
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, ".." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                        }
                    }else
                    {   N file_size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                        if( in_buf_2->offset >= file_size )
                            len = 0;
                        else if( in_buf_2->offset + in_buf_2->size >= file_size )
                            len = file_size - in_buf_2->offset;
                        else
                            len = in_buf_2->size;
                        out_buf_2 = M(len);
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        if(len)
                        {   if( E_mem_Q_file_P_pos( device_file_id, file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster + in_buf_2->offset ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, out_buf_2, len ))
                                goto Error;
                        }
                    }
                    out_buf.len += len;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { out_buf_2, len }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    W( out_buf_2 );
End_read:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_RELEASE:
              case FUSE_RELEASEDIR:
                {   struct fuse_release_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->release_flags );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                    {   E_mem_Q_tab_I_remove( file_handles, in_buf_2->fh );
                        if( in_buf_2->flags & FUSE_RELEASE_FLUSH )
                            E_mem_Q_file_I_save( device_file_id );
                    }
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_CREATE:
                {   struct fuse_create_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->mode );
                    N inode = FUSE_ROOT_ID;
                    N inode_empty = ~0;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N inode_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                        {   inode_empty = inode;
                            continue;
                        }
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            E_mem_Q_file_P_pos( device_file_id, inode_pos );
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            W(s);
                        }
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    struct E_main_Z_sort_free_blocks_range *free_blocks;
                    N free_blocks_n;
                    S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                    if( error == 1 )
                        goto Error;
                    if(error)
                    {   out_buf.error = error;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    /// Przydzielenie miejsca na wpis w tablicy plików.
                    N inode_pos;
                    if( !~inode_empty )
                    {   N req_free_space = device_n_size + 2 * 2 + 2 * device_n_size + i;
                        if( table_of_files_offset < req_free_space )
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        if( free_blocks_n
                        && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                        ) // TODO Scalenie plików od ostatniego zamiast błędu.
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        table_of_files_offset -= req_free_space;
                        inode_pos = table_of_files_offset;
                        inode_empty = FUSE_ROOT_ID + 1;
                        for_each( file_handle_id, file_handles, E_mem_Q_tab )
                        {   struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, file_handle_id );
                            file_handle->inode++;
                        }
                    }else
                    {   N i_ = i;
                        N i_old;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  inode_pos = device->pos;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            i_old = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i_old++;
                                if( !c )
                                    break;
                            }
                            if( inode == inode_empty )
                            {   if( flags_1 & Z_inode_flags_1_S_directory )
                                    i_ += 2 + 2 * device_n_size;
                                break;
                            }
                        }
                        if( i_ > i_old )
                        {   N req_free_space = i_ - i_old;
                            if( table_of_files_offset < req_free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            if( free_blocks_n
                            && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, table_of_files_offset - req_free_space, table_of_files_offset, inode_pos - table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            table_of_files_offset -= req_free_space;
                            inode_pos -= req_free_space;
                        }else if( i_ < i_old )
                        {   N avail_free_space = i_old - i_;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, table_of_files_offset + avail_free_space, table_of_files_offset, inode_pos - table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            table_of_files_offset += avail_free_space;
                            inode_pos += avail_free_space;
                        }
                    }
                    W( free_blocks );
                    /// Wpisanie do tablicy plików.
                    E_mem_Q_file_P_pos( device_file_id, inode_pos );
                    if( E_mem_Q_file_P_N( device_file_id, in_buf->nodeid, device_n_size )
                    || E_mem_Q_file_P_16( device_file_id, 0 )
                    || E_mem_Q_file_P_16( device_file_id, 0 )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    )
                        goto Error;
                    if( inode_pos == table_of_files_offset )
                    {   E_mem_Q_file_P_pos( device_file_id, 439 - 1 - 2 - device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, table_of_files_offset / S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, table_of_files_offset % S_size_of_cluster ))
                            goto Error;
                    }
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = inode;
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    out_buf_2.attr.mode = S_IFREG | 0666;
                    out_buf_2.attr.nlink = 1;
                    struct fuse_open_out out_buf_3;
                    E_mem_Q_blk_P_fill_c( &out_buf_3, sizeof( out_buf_3 ), 0 );
                    out_buf_3.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_3.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_3.fh );
                    file_handle->inode = inode_empty;
                    out_buf.len += sizeof( out_buf_2 ) + sizeof( out_buf_3 );
                    struct iovec bufs[3] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    , { &out_buf_3, sizeof( out_buf_3 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_create:         in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_MKDIR:
                {   struct fuse_mkdir_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->mode );
                    N inode = FUSE_ROOT_ID;
                    N inode_empty = ~0;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N inode_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                        {   inode_empty = inode;
                            continue;
                        }
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            E_mem_Q_file_P_pos( device_file_id, inode_pos );
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            W(s);
                        }
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    N rec_pos = device->pos;
                    struct E_main_Z_sort_free_blocks_range *free_blocks;
                    N free_blocks_n;
                    S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                    if( error == 1 )
                        goto Error;
                    if(error)
                    {   out_buf.error = error;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_mkdir;
                    }
                    /// Przydzielenie miejsca na wpis w tablicy plików.
                    N inode_pos;
                    if( !~inode_empty )
                    {   N req_free_space = device_n_size + 2 * 2 + 2 * device_n_size + i;
                        if( table_of_files_offset < req_free_space )
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_mkdir;
                        }
                        if( free_blocks_n
                        && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                        ) // TODO Scalenie plików od ostatniego zamiast błędu.
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_mkdir;
                        }
                        table_of_files_offset -= req_free_space;
                        inode_pos = table_of_files_offset;
                        inode_empty = 2;
                        for_each( file_handle_id, file_handles, E_mem_Q_tab )
                        {   struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, file_handle_id );
                            file_handle->inode++;
                        }
                    }else
                    {   N i_ = i;
                        N i_old;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  inode_pos = device->pos;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            i_old = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i_old++;
                                if( !c )
                                    break;
                            }
                            if( inode == inode_empty )
                            {   if( flags_1 & Z_inode_flags_1_S_directory )
                                    i_ += 2 + 2 * device_n_size;
                                break;
                            }
                        }
                        if( i_ > i_old )
                        {   N req_free_space = i_ - i_old;
                            if( table_of_files_offset < req_free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            if( free_blocks_n
                            && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, table_of_files_offset - req_free_space, table_of_files_offset, inode_pos - table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            table_of_files_offset -= req_free_space;
                            inode_pos -= req_free_space;
                        }else if( i_ < i_old )
                        {   N avail_free_space = i_old - i_;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, table_of_files_offset + avail_free_space, table_of_files_offset, inode_pos - table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            table_of_files_offset += avail_free_space;
                            inode_pos += avail_free_space;
                        }
                    }
                    W( free_blocks );
                    /// Wpisanie do tablicy plików.
                    E_mem_Q_file_P_pos( device_file_id, rec_pos );
                    if( E_mem_Q_file_P_N( device_file_id, in_buf->nodeid, device_n_size )
                    || E_mem_Q_file_P_16( device_file_id, Z_inode_flags_1_S_directory )
                    || E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    )
                        goto Error;
                    if( rec_pos == table_of_files_offset )
                    {   E_mem_Q_file_P_pos( device_file_id, 439 - 1 - 2 - device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, table_of_files_offset / S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, table_of_files_offset % S_size_of_cluster ))
                            goto Error;
                    }
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = inode;
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    out_buf_2.attr.mode = S_IFDIR | 0777;
                    out_buf_2.attr.nlink = 1;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_mkdir:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_UNLINK:
              case FUSE_RMDIR:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                        {   out_buf.error = -ENOENT;
                            break;
                        }
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N rec_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                goto Write_unlink;
                            }
                            E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                if( flags_1 & Z_inode_flags_1_S_persistent )
                                {   out_buf.error = -EPERM;
                                    goto Write_unlink;
                                }
                                rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                                if( rec_pos != table_of_files_offset )
                                {   E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                    if( E_mem_Q_file_P_16( device_file_id, file_size_in_last_cluster | Z_inode_flags_1_S_empty ))
                                        goto Error;
                                }else
                                {   table_of_files_offset += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                    E_mem_Q_file_P_pos( device_file_id, 439 - 1 - 2 - device_n_size );
                                    if( E_mem_Q_file_P_N( device_file_id, table_of_files_offset / S_size_of_cluster, device_n_size ))
                                        goto Error;
                                    if( E_mem_Q_file_P_16( device_file_id, table_of_files_offset % S_size_of_cluster ))
                                        goto Error;
                                }
                                for_each( id, file_handles, E_mem_Q_tab )
                                {   struct E_main_Z_file_handle *fh = E_mem_Q_tab_R( file_handles, id );
                                    if( fh->inode == in_buf->nodeid )
                                    {   if( !~E_mem_Q_tab_I_remove( file_handles, id ))
                                            goto Error;
                                        break;
                                    }
                                }
                                break;
                            }
                            W(s);
                        }
                    }
Write_unlink:       ;struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_WRITE:
                {   struct fuse_write_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->offset ); Gd( in_buf_2->size ); Gh( in_buf_2->flags ); Gh( in_buf_2->write_flags );
                    struct fuse_write_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    out_buf_2.size = in_buf_2->size;
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    N inode = FUSE_ROOT_ID;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    N16 flags_1;
                    N file_size_in_last_cluster;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    N rec_pos;
                    O{  inode++;
                        rec_pos = device->pos;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        if( inode == file_handle->inode )
                            break;
                    }
                    if( flags_1 & Z_inode_flags_1_S_persistent )
                    {   out_buf.error = -EPERM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    N l = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    N file_pos = file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster;
                    N file_size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                    if( !l && in_buf_2->offset <= file_size )
                        goto Send_write;
                    N req_free_space = 0;
                    if( file_size
                    && in_buf_2->offset + l > file_size /// Zapis poza końcem pliku, więc trzeba wyszukać wolny blok.
                    ){  struct E_main_Z_sort_free_blocks_range *free_blocks;
                        N free_blocks_n;
                        S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        N free_blocks_i;
                        for_n_( free_blocks_i, free_blocks_n )
                            if( free_blocks[ free_blocks_i ].nodeid == inode )
                                break;
                        req_free_space = in_buf_2->offset + l - file_size;
                        if(( free_blocks_i + 1 != free_blocks_n && file_size + req_free_space <= free_blocks[ free_blocks_i + 1 ].begin ) /// Mieści się przed zawartością następnego pliku.
                        || ( free_blocks_i + 1 == free_blocks_n && file_size + req_free_space <= table_of_files_offset ) /// Mieści się przed listą opisów plików.
                        )
                        {   W( free_blocks );
                            E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                            if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                goto Error;
                            if( req_free_space )
                            {   E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                                file_size += req_free_space;
                                if( E_mem_Q_file_P_16( device_file_id, flags_1 | ( file_size % S_size_of_cluster )))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 * 2 + device_n_size );
                                if( E_mem_Q_file_P_N( device_file_id, file_size / S_size_of_cluster, device_n_size ))
                                    goto Error;
                            }
                            goto Send_write;
                        }
                        /// Przeliczenie na ‘free blocks’.
                        N free_blocks_i_file = free_blocks_i;
                        free_blocks_i = free_blocks_n - 1;
                        if( free_blocks_i != free_blocks_i_file
                        && free_blocks[ free_blocks_i ].end != table_of_files_offset
                        )
                        {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n++;
                            free_blocks[ free_blocks_n - 1 ].end = table_of_files_offset;
                            free_blocks[ free_blocks_n - 1 ].begin = free_blocks[ free_blocks_n - 2 ].end;
                        }else if( free_blocks_i == free_blocks_i_file
                        && free_blocks_i
                        )
                        {   free_blocks[ free_blocks_i ].end = table_of_files_offset;
                            free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                            free_blocks_i--;
                        }
                        for( ; free_blocks_i; free_blocks_i-- )
                        {   if( free_blocks[ free_blocks_i - 1 ].end != free_blocks[ free_blocks_i ].begin )
                            {   free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                                if( free_blocks_i != free_blocks_i_file )
                                    free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i ].begin;
                                else
                                {   free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].end;
                                    if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i + 1, 1 ))
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                }
                            }else
                                if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                        }
                        if( free_blocks[0].begin )
                        {   free_blocks[0].end = free_blocks[0].begin;
                            free_blocks[0].begin = 0;
                        }else
                            if( !E_mem_Q_blk_I_remove( &free_blocks, 0, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                        error = E_main_Q_filesystem_I_allocate( device_file_id, &free_blocks, free_blocks_n, in_buf_2->offset + l, &file_size_in_last_cluster, &file_pos_in_the_only_cluster, &file_pos_cluster, &file_size_clusters );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
/// Tutaj kontynuacja edycji.
                        W( free_blocks );
                        N file_pos_new = file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster;
                        error = E_main_Q_filesystem_I_move_data( device_file_id, file_pos_new, file_pos, in_buf_2->offset );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        E_mem_Q_file_P_pos( device_file_id, file_pos_new + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                        if( E_mem_Q_file_P_16( device_file_id, flags_1 | file_size_in_last_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                            goto Error;
                    }else if( !file_size ) /// Zapis do nowego bloku, więc trzeba go wyszukać.
                    {   struct E_main_Z_sort_free_blocks_range *free_blocks;
                        N free_blocks_n;
                        S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   out_buf.error = error;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        /// Przeliczenie na ‘free blocks’.
                        N free_blocks_i = free_blocks_n - 1;
                        if( free_blocks[ free_blocks_i ].end != table_of_files_offset )
                        {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n++;
                            free_blocks[ free_blocks_n - 1 ].end = table_of_files_offset;
                            free_blocks[ free_blocks_n - 1 ].begin = free_blocks[ free_blocks_n - 2 ].end;
                        }
                        for( ; free_blocks_i; free_blocks_i-- )
                        {   if( free_blocks[ free_blocks_i - 1 ].end != free_blocks[ free_blocks_i ].begin )
                            {   free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                                free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].end;
                                if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i + 1, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                            }else
                                if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                        }
                        if( free_blocks[0].begin )
                        {   free_blocks[0].end = free_blocks[0].begin;
                            free_blocks[0].begin = 0;
                        }else
                            if( !E_mem_Q_blk_I_remove( &free_blocks, 0, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                        error = E_main_Q_filesystem_I_allocate( device_file_id, &free_blocks, free_blocks_n, in_buf_2->offset + l, &file_size_in_last_cluster, &file_pos_in_the_only_cluster, &file_pos_cluster, &file_size_clusters );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        W( free_blocks );
                        file_pos = file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster;
                        /// TODO Wypełnić zerami początek pliku.
                        if( in_buf_2->offset )
                        {
                        }
                        E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                        if( E_mem_Q_file_P_16( device_file_id, flags_1 | file_size_in_last_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                            goto Error;
                    }else
                    {   E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                    }
/*
                        N free_blocks_i_nodeid = free_blocks_i;
                        if( free_blocks_i != free_blocks_n )
                            for( free_blocks_i++; free_blocks_i != free_blocks_n; free_blocks_i++ )
                            {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                                req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                            }
                        if( free_blocks_i == free_blocks_n )
                        {   struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( req_free_space > file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   N req_free_space = in_buf_2->offset + l - file_size;
                                for( N free_blocks_i = free_blocks_i_nodeid + 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                req_free_space -= file->l - free_blocks[ free_blocks_n - 1 ].end;
                                for( free_blocks_i = free_blocks_i_nodeid; free_blocks_i; free_blocks_i-- )
                                {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                        break;
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                }
                                if( !free_blocks_i )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                	if( req_free_space > free_blocks[0].begin - table_end )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOSPC;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                }
                                N free_blocks_i_start = free_blocks_i;
                                Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                                if( free_blocks_n > 1 )
                                    for( N free_blocks_i = free_blocks_n - 2; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                                    {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                        if( !buf )
                                        {   W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[1] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        {   W(buf);
                                            W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[1] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                                        free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                            goto Error;
                                        W(buf);
                                        N nodeid = FUSE_ROOT_ID + 1;
                                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                        O{  N rec_pos = device->pos;
                                            if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                            {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                    goto Error;
                                                break;
                                            }
                                            E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                            O{  C c;
                                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                    goto Error;
                                                if( !c )
                                                    break;
                                            }
                                            nodeid++;
                                        }
                                    }
                                for( N free_blocks_i = free_blocks_i_start; free_blocks_i != free_blocks_i_nodeid + 1; free_blocks_i++ )
                                {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[ free_blocks_i ].end -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                    free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                if( !free_blocks_i_start )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                    Pc buf = M( free_blocks[0].begin - table_end );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[0].end -= free_blocks[0].begin - table_end;
                                    free_blocks[0].begin = table_end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                W( free_blocks );
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                goto Write_write;
                            }
                            free_blocks_i--;
                            if( free_blocks_i != free_blocks_i_nodeid )
                            {   Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                            }
                        }
                        for( ; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                        {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                            if( !buf )
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                            {   W(buf);
                                W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                            free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                goto Error;
                            W(buf);
                            N nodeid = FUSE_ROOT_ID + 1;
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N rec_pos = device->pos;
                                if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                        goto Error;
                                    break;
                                }
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                                nodeid++;
                            }
                        }
                        W( free_blocks );
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        goto Write_write;
                    }
                    if( !file_size )
                    {   struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                        if( !free_blocks )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N free_blocks_n = 0;
                        N nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( file_pos != file_pos_S_directory
                            && file_size
                            ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n ].nodeid = nodeid;
                                free_blocks[ free_blocks_n ].begin = file_pos;
                                free_blocks[ free_blocks_n ].end = file_pos + file_size;
                                free_blocks_n++;
                            }
                            nodeid++;
                        }
                        if( free_blocks_n )
                        {   qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                            N free_blocks_i;
                            for( free_blocks_i = 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                if( l <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                            if( free_blocks_i != free_blocks_n )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( l <= file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( !file_pos )
                                    break;
                                N file_size;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                    goto Error;
                                N parent_dir_inode;
                                if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                    goto Error;
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                            }
                            N table_end = device->pos;
                            if( l > free_blocks[0].begin - table_end )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            W( free_blocks );
                            if( in_buf_2->offset > file_size )
                                for( N i = file_size; i != in_buf_2->offset; i++ )
                                    if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                        goto Error;
                            E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                            if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                goto Error;
                            E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                                goto Error;
                            goto Write_write;
                        }
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        W( free_blocks );
                        N table_end = device->pos;
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, table_end + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, rec_pos );
                        if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                            goto Error;
                        goto Write_write;
                    }
                    E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                    if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                        goto Error;
Write_write:        if( in_buf_2->offset + l > file_size )
                    {   E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, in_buf_2->offset + l, device_n_size ))
                            goto Error;
                    }
*/
Send_write:         out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_write:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_SYMLINK:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LINK:
                {   struct fuse_link_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_STATFS:
                {   out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_MKNOD:
                {   struct fuse_mknod_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME:
                {   struct fuse_rename_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME2:
                {   struct fuse_rename2_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags );
                    N16 flags_1;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    if( in_buf_2->newdir != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        if( inode != in_buf_2->newdir
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            goto Write_rename2;
                        }
                    }
                    N inode = FUSE_ROOT_ID;
                    N parent_dir_inode;
                    N file_size_in_last_cluster;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    N i_old;
                    N rec_pos;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        rec_pos = device->pos;
                        i_old = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i_old++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M( i_old );
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                goto Write_rename2;
                            }
                            E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_R_s( device_file_id, s, i_old ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                break;
                            }
                            W(s);
                        }
                    }
                    if( flags_1 & Z_inode_flags_1_S_persistent )
                    {   out_buf.error = -EPERM;
                        goto Write_rename2;
                    }
                    Pc s = E_text_Z_s0_R_0_end( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    N i = E_text_Z_s0_R_0_l(s);
                    if( i != i_old )
                    {   N free_space;
                        if( i > i_old )
                        {   free_space = i - i_old;
                            struct E_main_Z_sort_free_blocks_range *free_blocks;
                            N free_blocks_n;
                            S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   out_buf.error = error;
                                goto Write_rename2;
                            }
                            if( table_of_files_offset < free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                goto Write_rename2;
                            }
                            if( free_blocks_n
                            && table_of_files_offset - free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                goto Write_rename2;
                            }
                            W( free_blocks );
                        }else
                            free_space = i_old - i;
                        rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                        if( rec_pos != table_of_files_offset )
                        {   N dst;
                            if( i > i_old )
                                dst = table_of_files_offset - free_space;
                            else
                                dst = table_of_files_offset + free_space;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, dst, table_of_files_offset, rec_pos - table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   out_buf.error = error;
                                goto Write_rename2;
                            }
                            table_of_files_offset = dst;
                        }else
                        {   if( i > i_old )
                                table_of_files_offset -= free_space;
                            else
                                table_of_files_offset += free_space;
                            E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        }
                        if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, file_size_in_last_cluster ))
                            goto Error;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        if( E_mem_Q_file_P_s( device_file_id, s, i ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, 439 - 1 - 2 - device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, table_of_files_offset / S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, table_of_files_offset % S_size_of_cluster ))
                            goto Error;
                    }else
                    {   rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                        if( parent_dir_inode != in_buf_2->newdir )
                        {   E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode, device_n_size ))
                                goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ));
                        if( E_mem_Q_file_P_s( device_file_id, s, i ))
                            goto Error;
                    }
Write_rename2:      ;struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_IOCTL:
                {   struct fuse_ioctl_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
            }
            G_(); Gd( buffer_read );
            if( !buffer_read )
                break;
        }
    }
End:E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    if( E_mem_Q_file_W( device_file_id ))
    {   E_base_W();
        return 1;
    }
    E_base_W();
    return 0;
Error:
    E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    E_mem_Q_file_W( device_file_id );
    E_base_W();
    return 1;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
