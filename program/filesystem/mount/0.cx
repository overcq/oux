/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  C+
*  ¦/C+¦  filesystem
*   ---   mount
*         main
* ©overcq                on ‟Gentoo Linux 17.0” “x86_64”             2019‒3‒10 b
*******************************************************************************/
#define Z_inode_flags_2_S_directory 0x1000
#define Z_inode_flags_2_S_empty     0x8000
#define S_size_of_cluster           4096
//==============================================================================
struct E_main_Z_file_handle
{ N64 inode;
};
struct E_mem_Q_tab_Z *file_handles;
//------------------------------------------------------------------------------
struct E_main_Z_sort_free_blocks_range
{ N nodeid;
  N begin, end;
};
//==============================================================================
_internal
int
E_main_I_sort_free_blocks_cmp(
  const void *a_
, const void *b_
){  struct E_main_Z_sort_free_blocks_range *a = a_, *b = b_;
    return a->begin == b->begin ? 0 : ( a->begin > b->begin ? 1 : -1 );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int
main(
  int argc
, char *argv[]
){  E_base_M( argc, argv );
    Pc device = 0;
    Pc directory = 0;
    B option = no;
    for( int i = 1; i != argc; i++ )
    {   if( option )
        {   option = no;
            continue;
        }
        if( *argv[i] == '-' )
        {   if( E_text_Z_s0_T_s0_eq( argv[i] + 1, "o" ))
            {   option = yes;
                continue;
            }
            E_base_W();
            return 1;
        }
        if(directory)
        {   E_base_W();
            return 1;
        }
        if(device)
            directory = argv[i];
        else
            device = argv[i];
    }
    if( !device
    || !directory
    || option
    ){  E_base_W();
        return 1;
    }
    I device_file_id;
    if( !~( device_file_id = E_mem_Q_file_M( device, no )))
    {   E_base_W();
        return 1;
    }
    E_mem_Q_file_P_pos( device_file_id, 500 );
    N table_of_files_offset;
    if( E_mem_Q_file_R_64( device_file_id, &table_of_files_offset ))
    {   E_base_W();
        return 1;
    }
    C cluster_address_size_power_bit;
    if( E_mem_Q_file_R_c( device_file_id, &cluster_address_size_power_bit )
    || !cluster_address_size_power_bit
    || cluster_address_size_power_bit > 6
    ){  E_base_W();
        return 1;
    }
    C device_n_size = ( 1 << cluster_address_size_power_bit ) / 8;
    C filesystem_version;
    if( E_mem_Q_file_R_c( device_file_id, &filesystem_version )
    || filesystem_version != 1
    ){  E_base_W();
        return 1;
    }
    int fuse_fd;
    VO1( fuse_fd = open( "/dev/fuse", O_RDWR ))
    {   E_base_W();
        return 1;
    }
        #if defined( __gnu_linux__ )
    cap_t cap;
    Vp( cap = cap_get_proc() )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    cap_value_t cap_list[1] = { CAP_SYS_ADMIN };
    V1( cap_set_flag( cap, CAP_EFFECTIVE, 1, &cap_list[0], CAP_CLEAR ))
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=" J_s( S_size_of_cluster ) ",allow_other", fuse_fd, 040000, getuid(), getgid() );
    V1( mount( device, directory, "fuseblk", 0, s_2 ))
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
    V1( cap_set_proc(cap) )
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    V1( cap_free(cap) )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
        #else
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=" J_s( S_size_of_cluster ) ",allow_other", fuse_fd, 040000, getuid(), getgid() );
    V1( mount( device, directory, 0, s_2 ))
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
        #endif
    N buffer_size, buffer_read;
    P buffer = M( buffer_size = 4096 );
    if( !buffer )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N fuse_major;
    N fuse_minor;
    file_handles = E_mem_Q_tab_M( sizeof( struct E_main_Z_file_handle ), 0 );
    O{  int error;
        VO1e( buffer_read = read( fuse_fd, buffer, buffer_size ), error )
        {   if( error == ENODEV )
                goto End;
            else
            {   E_flow_Z_line_report_Z_line_I_error( &__FILE__[0], __LINE__ );
                goto Error;
            }
        }
        struct fuse_in_header *in_buf = buffer;
        O{  if( buffer_read < sizeof( *in_buf ))
                goto Error;
            buffer_read -= sizeof( *in_buf );
            struct fuse_out_header out_buf;
            out_buf.len = sizeof( out_buf );
            out_buf.error = 0;
            out_buf.unique = in_buf->unique;
            G_(); Gd( in_buf->opcode );
            switch( in_buf->opcode )
            { default:
                    goto Error;
              case FUSE_INTERRUPT:
                {   struct fuse_interrupt_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FORGET:
                {   struct fuse_forget_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_BATCH_FORGET:
                {   struct fuse_batch_forget_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( buffer_read < in_buf_2->count * sizeof( struct fuse_forget_one ))
                        goto Error;
                    buffer_read -= in_buf_2->count * sizeof( struct fuse_forget_one );
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ) + in_buf_2->count * sizeof( struct fuse_forget_one ));
                    break;
                }
              case FUSE_INIT:
                {   struct fuse_init_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->major ); Gd( in_buf_2->minor );
                    if( in_buf_2->major > 7 )
                    {   fuse_major = 7;
                        fuse_minor = 0;
                    }else
                    {   fuse_major = in_buf_2->major;
                        if( in_buf_2->major == 7 )
                            fuse_minor = 26;
                        else
                        {   V();
                        }
                    }
                    G_(); Gd( fuse_major ); Gd( fuse_minor );
                    struct fuse_init_out out_buf_2;
                    out_buf.len += sizeof( out_buf_2 );
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.major = fuse_major;
                    out_buf_2.minor = fuse_minor;
                    if( fuse_major > 7
                    || ( fuse_major == 7 && fuse_minor >= 5
                    ))
                        out_buf_2.max_write = in_buf_2->max_readahead; //NDFN
                    out_buf_2.flags = FUSE_BIG_WRITES;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_DESTROY:
                    goto End;
              case FUSE_FLUSH:
                {   struct fuse_flush_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FSYNC:
                {   struct fuse_fsync_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_ACCESS:
                {   struct fuse_access_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf->nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        N16 flags_2;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_2 = file_size_in_last_cluster & 0xf000;
                            if( inode == in_buf->nodeid )
                                break;
                        }
                        if( inode != in_buf->nodeid
                        || flags_2 & Z_inode_flags_2_S_empty
                        )
                            out_buf.error = -ENOENT;
                    }
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_LOOKUP:
                {   //TODO "." i ".."
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    N inode = FUSE_ROOT_ID;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N inode_pos = device->pos;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_pos_cluster;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                            goto Error;
                        N file_size_clusters;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                            goto Error;
                        N file_pos_in_the_only_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_2 = file_size_in_last_cluster & 0xf000;
                        if( flags_2 & Z_inode_flags_2_S_empty )
                            continue;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(0);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            E_mem_Q_file_P_pos( device_file_id, inode_pos );
                            N i = 0;
                            O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                {   W(s);
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_lookup;
                                }
                                C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                s[i] = c;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                out_buf_2.nodeid = out_buf_2.attr.ino = inode;
                                out_buf_2.attr.nlink = 1;
                                if( flags_2 & Z_inode_flags_2_S_directory )
                                {   out_buf_2.attr.mode = S_IFDIR | 0777;
                                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                                    O{  if( device->pos == device->l )
                                            break;
                                        N i = 0;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            i++;
                                            if( !c )
                                                break;
                                        }
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        N file_pos_cluster;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                            goto Error;
                                        N file_size_clusters;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                            goto Error;
                                        N file_pos_in_the_only_cluster;
                                        if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                            goto Error;
                                        N file_size_in_last_cluster;
                                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                            goto Error;
                                        N16 flags_2 = file_size_in_last_cluster & 0xf000;
                                        if( parent_dir_inode == in_buf->nodeid
                                        && !( flags_2 & Z_inode_flags_2_S_empty )
                                        )
                                        {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                                            out_buf_2.attr.nlink++;
                                        }
                                    }
                                }else
                                {   out_buf_2.attr.size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                                    out_buf_2.attr.mode = S_IFREG | 0666;
                                }
                                out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( file_size_clusters * S_size_of_cluster + file_size_in_last_cluster, 512 ) / 512;
                                out_buf.len += sizeof( out_buf_2 );
                                struct iovec bufs[2] =
                                { { &out_buf, sizeof( out_buf ) }
                                , { &out_buf_2, sizeof( out_buf_2 ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            W(s);
                            E_mem_Q_file_P_pos( device_file_id, device->pos + i + 3 * device_n_size + 2 * 2 );
                        }
                    }
End_lookup:         in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_GETATTR:
                {   struct fuse_getattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = 1;
                    if( in_buf_2->getattr_flags & FUSE_GETATTR_FH )
                    {   if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                        struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                        out_buf_2.attr.ino = file_handle->inode;
                    }else
                    {   out_buf_2.attr.ino = in_buf->nodeid;
                    }
                    N file_size_clusters;
                    N file_size_in_last_cluster;
                    N16 flags_2;
                    if( out_buf_2.attr.ino != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_2 = file_size_in_last_cluster & 0xf000;
                            if( inode == out_buf_2.attr.ino )
                                break;
                        }
                        if( inode != out_buf_2.attr.ino
                        || flags_2 & Z_inode_flags_2_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                    }else
                        flags_2 |= Z_inode_flags_2_S_directory;
                    if( flags_2 & Z_inode_flags_2_S_directory )
                    {   out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 2;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_2 = file_size_in_last_cluster & 0xf000;
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_2 & Z_inode_flags_2_S_empty )
                            )
                            {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   out_buf_2.attr.size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                        out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( file_size_clusters * S_size_of_cluster + file_size_in_last_cluster, 512 ) / 512;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_GETXATTR:
                {   struct fuse_getxattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LISTXATTR:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_SETATTR:
                {   struct fuse_setattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    N16 flags_2 = 0;
                    if( in_buf->nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_2 = file_size_in_last_cluster & 0xf000;
                            if( inode == in_buf->nodeid )
                                break;
                        }
                        if( inode != in_buf->nodeid
                        || flags_2 & Z_inode_flags_2_S_empty
                        )
                        {  out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_setattr;
                        }
                    }
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = 1;
                    if( in_buf->nodeid == FUSE_ROOT_ID
                    || flags_2 & Z_inode_flags_2_S_directory
                    ){  out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 1;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_2 = file_size_in_last_cluster & 0xf000;
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_2 & Z_inode_flags_2_S_empty )
                            )
                            {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_setattr:        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_OPEN:
              case FUSE_OPENDIR:
                {   struct fuse_open_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf->nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        N16 flags_2;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_2 = file_size_in_last_cluster & 0xf000;
                            if( inode == in_buf->nodeid )
                                break;
                        }
                        if( inode != in_buf->nodeid
                        || flags_2 & Z_inode_flags_2_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_open;
                        }
                    }
                    struct fuse_open_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_2.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_open;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_2.fh );
                    file_handle->inode = in_buf->nodeid;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_open:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_READ:
              case FUSE_READDIR:
                {   struct fuse_read_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    N parent_dir_inode;
                    N file_pos_cluster;
                    N file_size_clusters;
                    N file_pos_in_the_only_cluster;
                    N file_size_in_last_cluster;
                    N16 flags_2;
                    if( file_handle->inode != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( inode == in_buf->nodeid )
                                break;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_2 = file_size_in_last_cluster & 0xf000;
                            file_size_in_last_cluster &= 0xfff;
                            if( inode == file_handle->inode )
                                break;
                        }
                        if( inode != file_handle->inode
                        || flags_2 & Z_inode_flags_2_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                    }else
                    {   flags_2 |= Z_inode_flags_2_S_directory;
                        parent_dir_inode = file_handle->inode;
                    }
                    N len;
                    P out_buf_2;
                    if( flags_2 & Z_inode_flags_2_S_directory )
                    {   out_buf_2 = M( len = 0 );
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        N node_offset = 0;
                        N node_size = in_buf_2->size;
                        N nodeid = FUSE_ROOT_ID;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            nodeid++;
                            N inode_pos = device->pos;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_2 = file_size_in_last_cluster & 0xf000;
                            if( flags_2 & Z_inode_flags_2_S_empty )
                                continue;
                            if( parent_dir_inode == file_handle->inode )
                            {   Pc s = M(0);
                                if( !s )
                                {   out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                E_mem_Q_file_P_pos( device_file_id, inode_pos );
                                N i = 0;
                                O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    s[i] = c;
                                    i++;
                                    if( !c )
                                        break;
                                }
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_offset >= in_buf_2->offset )
                                {   if( node_size < size )
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOBUFS;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    node_size -= size;
                                    len += size;
                                    if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                    *d = ( struct fuse_dirent )
                                    { nodeid
                                    , node_offset + size
                                    , i - 1
                                    , ( flags_2 & Z_inode_flags_2_S_directory ? S_IFDIR : S_IFREG ) >> 12
                                    };
                                    E_text_Z_s_P_s0_copy_0( d->name, s );
                                    E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                }
                                W(s);
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                            if( nodeid == file_handle->inode
                            && node_offset >= in_buf_2->offset
                            ){  N i = 2;
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_size < size )
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOBUFS;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                node_size -= size;
                                len += size;
                                if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                *d = ( struct fuse_dirent )
                                { nodeid
                                , node_offset + size
                                , i - 1
                                , S_IFDIR >> 12
                                };
                                E_text_Z_s_P_s0_copy_0( d->name, "." );
                                E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                        }
                        if( file_handle->inode == FUSE_ROOT_ID
                        && node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 2;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            node_size -= size;
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { file_handle->inode
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, "." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                            node_offset += size;
                        }
                        if( node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 3;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { parent_dir_inode
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, ".." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                        }
                    }else
                    {   N file_size = file_size_clusters * S_size_of_cluster + file_size_in_last_cluster;
                        if( in_buf_2->offset >= file_size )
                            len = 0;
                        else if( in_buf_2->offset + in_buf_2->size >= file_size )
                            len = file_size - in_buf_2->offset;
                        else
                            len = in_buf_2->size;
                        out_buf_2 = M(len);
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        if(len)
                        {   if( E_mem_Q_file_P_pos( device_file_id, file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster + in_buf_2->offset ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, out_buf_2, len ))
                                goto Error;
                        }
                    }
                    out_buf.len += len;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { out_buf_2, len }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    W( out_buf_2 );
End_read:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_RELEASE:
              case FUSE_RELEASEDIR:
                {   struct fuse_release_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->release_flags );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                    {   E_mem_Q_tab_I_remove( file_handles, in_buf_2->fh );
                        if( in_buf_2->flags & FUSE_RELEASE_FLUSH )
                            E_mem_Q_file_I_save( device_file_id );
                    }
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_CREATE:
                {   struct fuse_create_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->mode );
                    N nodeid = FUSE_ROOT_ID;
                    N nodeid_empty = ~0;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        N inode_pos = device->pos;
                        nodeid++;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_pos_cluster;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                            goto Error;
                        N file_size_clusters;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                            goto Error;
                        N file_pos_in_the_only_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_2 = file_size_in_last_cluster & 0xf000;
                        if( flags_2 & Z_inode_flags_2_S_empty )
                        {   nodeid_empty = nodeid;
                            continue;
                        }
                        if( parent_dir_inode == in_buf->nodeid )
                        {   Pc s = M(0);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            N i = 0;
                            E_mem_Q_file_P_pos( device_file_id, inode_pos );
                            O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                {   W(s);
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_create;
                                }
                                C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                s[i] = c;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            W(s);
                            E_mem_Q_file_P_pos( device_file_id, inode_pos + i + 3 * device_n_size + 2 * 2 );
                        }
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    N rec_pos = device->pos;
                    struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                    if( !free_blocks )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    N free_blocks_n = 0;
                    nodeid = FUSE_ROOT_ID;
                    E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                    O{  if( device->pos == device->l )
                            break;
                        nodeid++;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_pos_cluster;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                            goto Error;
                        N file_size_clusters;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                            goto Error;
                        N file_pos_in_the_only_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_2 = file_size_in_last_cluster & 0xf000;
                        if( flags_2 & Z_inode_flags_2_S_empty )
                            continue;
                        file_size_in_last_cluster &= 0xfff;
                        if( !( flags_2 & Z_inode_flags_2_S_directory )
                        && file_size_clusters * S_size_of_cluster + file_size_in_last_cluster
                        )
                        {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            free_blocks[ free_blocks_n ].nodeid = nodeid;
                            free_blocks[ free_blocks_n ].begin = file_pos_cluster * S_size_of_cluster + file_pos_in_the_only_cluster;
                            free_blocks[ free_blocks_n ].end = file_pos_cluster * S_size_of_cluster + file_size_clusters * S_size_of_cluster + file_pos_in_the_only_cluster + file_size_in_last_cluster; /// “file_size_clusters” albo “file_pos_in_the_only_cluster” jest 0.
                            free_blocks_n++;
                        }
                    }
                    qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                    /// Przydzielenie miejsca na wpis w tablicy plików.
                    N inode_pos;
                    if( !~nodeid_empty )
                    {   N req_free_space = i + 3 * device_n_size + 2 * 2;
                        if( table_of_files_offset < req_free_space )
                        {   out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        if( free_blocks_n
                        && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                        ) // TODO Scalenie plików od ostatniego zamiast błędu.
                        {   out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        table_of_files_offset -= req_free_space;
                        inode_pos = table_of_files_offset;
                    }else
                    {   N i_old;
                        E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                        O{  inode_pos = device->pos;
                            nodeid++;
                            i_old = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i_old++;
                                if( !c )
                                    break;
                            }
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            if( nodeid == nodeid_empty )
                                break;
                        }
                        if( i > i_old )
                        {   N req_free_space = i - i_old;
                            if( table_of_files_offset < req_free_space )
                            {   out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            if( free_blocks_n
                            && table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            Pc data = M( inode_pos - table_of_files_offset );
                            if( !data )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                            if( E_mem_Q_file_R_s( device_file_id, data, inode_pos - table_of_files_offset ))
                                goto Error;
                            table_of_files_offset -= req_free_space;
                            inode_pos -= req_free_space;
                            E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                            if( E_mem_Q_file_P_s( device_file_id, data, inode_pos - table_of_files_offset ))
                                goto Error;
                            W(data);
                        }else if( i < i_old )
                        {   N avail_free_space = i_old - i;
                            Pc data = M( inode_pos - table_of_files_offset );
                            if( !data )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                            if( E_mem_Q_file_R_s( device_file_id, data, inode_pos - table_of_files_offset ))
                                goto Error;
                            table_of_files_offset += avail_free_space;
                            inode_pos += avail_free_space;
                            E_mem_Q_file_P_pos( device_file_id, table_of_files_offset );
                            if( E_mem_Q_file_P_s( device_file_id, data, inode_pos - table_of_files_offset ))
                                goto Error;
                            W(data);
                        }
                    }
                    W( free_blocks );
                    /// Wpisanie do tablicy plików.
                    E_mem_Q_file_P_pos( device_file_id, rec_pos );
                    if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    || E_mem_Q_file_P_N( device_file_id, in_buf->nodeid, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, ~0, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_16( device_file_id, 0 )
                    || E_mem_Q_file_P_16( device_file_id, Z_inode_flags_2_S_directory )
                    ){  if( rec_pos != table_of_files_offset )
                        {   E_mem_Q_file_P_pos( device_file_id, rec_pos + i + 3 * device_n_size + 2 );
                            E_mem_Q_file_P_16( device_file_id, Z_inode_flags_2_S_empty );
                        }
                        goto Error;
                    }
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = nodeid;
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    out_buf_2.attr.mode = S_IFREG | 0666;
                    out_buf_2.attr.nlink = 1;
                    struct fuse_open_out out_buf_3;
                    E_mem_Q_blk_P_fill_c( &out_buf_3, sizeof( out_buf_3 ), 0 );
                    out_buf_3.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_3.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_3.fh );
                    file_handle->inode = in_buf->nodeid;
                    out_buf.len += sizeof( out_buf_2 ) + sizeof( out_buf_3 );
                    struct iovec bufs[3] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    , { &out_buf_3, sizeof( out_buf_3 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_create:         in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
/// Tutaj kontynuacja edycji.
              case FUSE_MKDIR:
                {   struct fuse_mkdir_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->mode );
                    N nodeid = FUSE_ROOT_ID;
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  if( device->pos == device->l )
                            break;
                        nodeid++;
                        N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                            break;
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   N i = 0;
                            Pc s = M(0);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                {   W(s);
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_mkdir;
                                }
                                C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                s[i] = c;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            W(s);
                        }else
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    N rec_pos = device->pos;
                    struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                    if( !free_blocks )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    N free_blocks_n = 0;
                    nodeid = FUSE_ROOT_ID + 1;
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                            break;
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        if( file_pos != file_pos_S_directory
                        && file_size
                        ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            free_blocks[ free_blocks_n ].nodeid = nodeid;
                            free_blocks[ free_blocks_n ].begin = file_pos;
                            free_blocks[ free_blocks_n ].end = file_pos + file_size;
                            free_blocks_n++;
                        }
                        nodeid++;
                    }
                    if( free_blocks_n )
                    {   qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                        N req_free_space = i + 3 * device_n_size + 2 * 2;
                        N free_blocks_i = 0;
                        if( req_free_space > free_blocks[ free_blocks_i ].begin - rec_pos )
                        {   req_free_space -= free_blocks[0].begin - rec_pos;
                            for( free_blocks_i++; free_blocks_i != free_blocks_n; free_blocks_i++ )
                            {   if( req_free_space < free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                                req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                            }
                        }
                        if( free_blocks_i == free_blocks_n )
                        {   struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( req_free_space > file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                            if( !buf )
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                            if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                            {   W(buf);
                                W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                            free_blocks[ free_blocks_n - 1 ].end = file->l;
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                            if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                goto Error;
                            W(buf);
                            N nodeid = FUSE_ROOT_ID + 1;
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N rec_pos = device->pos;
                                if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                        goto Error;
                                    break;
                                }
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                                nodeid++;
                            }
                            free_blocks_i--;
                        }
                        for( ; free_blocks_i; free_blocks_i-- )
                        {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                            if( !buf )
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                            {   W(buf);
                                W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                            free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                goto Error;
                            W(buf);
                            N nodeid = FUSE_ROOT_ID + 1;
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N rec_pos = device->pos;
                                if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                        goto Error;
                                    break;
                                }
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                                nodeid++;
                            }
                        }
                    }
                    W( free_blocks );
                    rec_pos -= device_n_size;
                    E_mem_Q_file_P_pos( device_file_id, rec_pos );
                    if( E_mem_Q_file_P_N( device_file_id, file_pos_S_directory, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, in_buf->nodeid, device_n_size )
                    || E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    ){  E_mem_Q_file_P_pos( device_file_id, rec_pos );
                        if( E_mem_Q_file_P_N( device_file_id, 0, device_n_size ))
                            goto Error;
                        out_buf.error = -ENOSPC;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_mkdir;
                    }
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = nodeid;
                    out_buf_2.generation = time(0);
                    out_buf_2.entry_valid = out_buf_2.attr_valid = 1;
                    out_buf_2.attr.mode = S_IFDIR | 0777;
                    out_buf_2.attr.nlink = 1;
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                            break;
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( parent_dir_inode == out_buf_2.attr.ino )
                        {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                            out_buf_2.attr.nlink++;
                        }
                    }
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_mkdir:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_UNLINK:
              case FUSE_RMDIR:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                        {   out_buf.error = -ENOENT;
                            goto End_unlink;
                        }
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   N i = 0;
                            Pc s = M(0);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                goto End_unlink;
                            }
                            O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                {   W(s);
                                    out_buf.error = -ENOMEM;
                                    goto End_unlink;
                                }
                                C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                s[i] = c;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                N file_pos = device->pos;
                                N len = 0;
                                O{  N file_pos;
                                    if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                        goto Error;
                                    if( !file_pos )
                                        break;
                                    N file_size;
                                    if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                        goto Error;
                                    N parent_dir_inode;
                                    if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                        goto Error;
                                    N i = 0;
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        i++;
                                        if( !c )
                                            break;
                                    }
                                    len += i + 3 * device_n_size + 2 * 2;
                                }
                                len += device_n_size;
                                E_mem_Q_file_P_pos( device_file_id, file_pos );
                                Pc buf = M(len);
                                if( !buf )
                                {   out_buf.error = -ENOMEM;
                                    goto End_unlink;
                                }
                                if( E_mem_Q_file_R_s( device_file_id, buf, len ))
                                {   W(buf);
                                    out_buf.error = -ENOMEM;
                                    goto End_unlink;
                                }
                                E_mem_Q_file_P_pos( device_file_id, file_pos - ( i + 3 * device_n_size + 2 * 2 ));
                                if( E_mem_Q_file_P_s( device_file_id, buf, len ))
                                    goto Error;
                                W(buf);
                                break;
                            }
                            W(s);
                        }else
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                    }
End_unlink:         ;struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_WRITE:
                {   struct fuse_write_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->offset ); Gd( in_buf_2->size ); Gh( in_buf_2->flags ); Gh( in_buf_2->write_flags );
                    struct fuse_write_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    out_buf_2.size = in_buf_2->size;
                    N inode = FUSE_ROOT_ID + 1;
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  if( inode == in_buf->nodeid )
                            break;
                        N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                            break;
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        inode++;
                    }
                    if( inode != in_buf->nodeid )
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    N file_pos;
                    if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                        goto Error;
                    if( !file_pos )
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    N file_size;
                    if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                        goto Error;
                    N rec_pos = device->pos - 2 * device_n_size;
                    N l = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    if( !l && in_buf_2->offset <= file_size )
                        goto Send_write;
                    if( file_size
                    && in_buf_2->offset + l > file_size
                    ){  struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                        if( !free_blocks )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N free_blocks_n = 0;
                        N nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( file_pos != file_pos_S_directory
                            && file_size
                            ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n ].nodeid = nodeid;
                                free_blocks[ free_blocks_n ].begin = file_pos;
                                free_blocks[ free_blocks_n ].end = file_pos + file_size;
                                free_blocks_n++;
                            }
                            nodeid++;
                        }
                        qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                        N free_blocks_i;
                        for( free_blocks_i = 0; free_blocks_i != free_blocks_n; free_blocks_i++ )
                            if( free_blocks[ free_blocks_i ].nodeid == inode )
                                break;
                        N req_free_space = in_buf_2->offset + l - file_size;
                        N free_blocks_i_nodeid = free_blocks_i;
                        if( free_blocks_i != free_blocks_n )
                            for( free_blocks_i++; free_blocks_i != free_blocks_n; free_blocks_i++ )
                            {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                                req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                            }
                        if( free_blocks_i == free_blocks_n )
                        {   struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( req_free_space > file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   N req_free_space = in_buf_2->offset + l - file_size;
                                for( N free_blocks_i = free_blocks_i_nodeid + 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                req_free_space -= file->l - free_blocks[ free_blocks_n - 1 ].end;
                                for( free_blocks_i = free_blocks_i_nodeid; free_blocks_i; free_blocks_i-- )
                                {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                        break;
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                }
                                if( !free_blocks_i )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                	if( req_free_space > free_blocks[0].begin - table_end )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOSPC;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                }
                                N free_blocks_i_start = free_blocks_i;
                                Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                                if( free_blocks_n > 1 )
                                    for( N free_blocks_i = free_blocks_n - 2; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                                    {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                        if( !buf )
                                        {   W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[1] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        {   W(buf);
                                            W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[1] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                                        free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                            goto Error;
                                        W(buf);
                                        N nodeid = FUSE_ROOT_ID + 1;
                                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                        O{  N rec_pos = device->pos;
                                            if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                            {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                    goto Error;
                                                break;
                                            }
                                            E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                            O{  C c;
                                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                    goto Error;
                                                if( !c )
                                                    break;
                                            }
                                            nodeid++;
                                        }
                                    }
                                for( N free_blocks_i = free_blocks_i_start; free_blocks_i != free_blocks_i_nodeid + 1; free_blocks_i++ )
                                {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[ free_blocks_i ].end -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                    free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                if( !free_blocks_i_start )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                    Pc buf = M( free_blocks[0].begin - table_end );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[1] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[0].end -= free_blocks[0].begin - table_end;
                                    free_blocks[0].begin = table_end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                W( free_blocks );
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                goto Write_write;
                            }
                            free_blocks_i--;
                            if( free_blocks_i != free_blocks_i_nodeid )
                            {   Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                            }
                        }
                        for( ; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                        {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                            if( !buf )
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                            {   W(buf);
                                W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                            free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                goto Error;
                            W(buf);
                            N nodeid = FUSE_ROOT_ID + 1;
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N rec_pos = device->pos;
                                if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                        goto Error;
                                    break;
                                }
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                                nodeid++;
                            }
                        }
                        W( free_blocks );
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        goto Write_write;
                    }
                    if( !file_size )
                    {   struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                        if( !free_blocks )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N free_blocks_n = 0;
                        N nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( file_pos != file_pos_S_directory
                            && file_size
                            ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n ].nodeid = nodeid;
                                free_blocks[ free_blocks_n ].begin = file_pos;
                                free_blocks[ free_blocks_n ].end = file_pos + file_size;
                                free_blocks_n++;
                            }
                            nodeid++;
                        }
                        if( free_blocks_n )
                        {   qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                            N free_blocks_i;
                            for( free_blocks_i = 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                if( l <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                            if( free_blocks_i != free_blocks_n )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( l <= file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( !file_pos )
                                    break;
                                N file_size;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                    goto Error;
                                N parent_dir_inode;
                                if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                    goto Error;
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                            }
                            N table_end = device->pos;
                            if( l > free_blocks[0].begin - table_end )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            W( free_blocks );
                            if( in_buf_2->offset > file_size )
                                for( N i = file_size; i != in_buf_2->offset; i++ )
                                    if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                        goto Error;
                            E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                            if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                goto Error;
                            E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                                goto Error;
                            goto Write_write;
                        }
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        W( free_blocks );
                        N table_end = device->pos;
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, table_end + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, rec_pos );
                        if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                            goto Error;
                        goto Write_write;
                    }
                    E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                    if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                        goto Error;
Write_write:        if( in_buf_2->offset + l > file_size )
                    {   E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, in_buf_2->offset + l, device_n_size ))
                            goto Error;
                    }
Send_write:         out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_write:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_SYMLINK:
                {   buffer_read -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LINK:
                {   struct fuse_link_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_STATFS:
                {   out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_MKNOD:
                {   struct fuse_mknod_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME:
                {   struct fuse_rename_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME2:
                {   struct fuse_rename2_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags );
                    if( in_buf_2->newdir != FUSE_ROOT_ID )
                    {   N nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        N file_pos;
                        O{  if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            if( nodeid == in_buf_2->newdir )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            nodeid++;
                        }
                        if( !file_pos )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                    }
                    N nodeid = FUSE_ROOT_ID + 1;
                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                    O{  N file_pos;
                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                            goto Error;
                        if( !file_pos )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        N file_size;
                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                            goto Error;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( parent_dir_inode == in_buf->nodeid )
                        {   N i = 0;
                            Pc s = M(0);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[1] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_rename2;
                            }
                            O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                                {   W(s);
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                s[i] = c;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                break;
                            }
                            W(s);
                        }else
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        nodeid++;
                    }
                    N i = E_text_Z_s0_R_l( E_text_Z_s0_R_end( (Pc)in_buf_2 + sizeof( *in_buf_2 )));
                    N rec_pos = device->pos - 3 * device_n_size - E_text_Z_s0_R_l( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                    N file_size;
                    if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                        goto Error;
                    N parent_dir_inode;
                    if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                        goto Error;
                    N j = 0;
                    Pc s = M(0);
                    if( !s )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_rename2;
                    }
                    O{  if( !E_mem_Q_blk_I_append( &s, 1 ))
                        {   W(s);
                            out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        C c;
                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                            goto Error;
                        s[j] = c;
                        j++;
                        if( !c )
                            break;
                    }
                    W(s);
                    if( i > j )
                    {   struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                        if( !free_blocks )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        N free_blocks_n = 0;
                        nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( file_pos != file_pos_S_directory
                            && file_size
                            ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                free_blocks[ free_blocks_n ].nodeid = nodeid;
                                free_blocks[ free_blocks_n ].begin = file_pos;
                                free_blocks[ free_blocks_n ].end = file_pos + file_size;
                                free_blocks_n++;
                            }
                            nodeid++;
                        }
                        if( free_blocks_n )
                        {   qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                            N req_free_space = i - j;
                            N free_blocks_i = 0;
                            if( req_free_space > free_blocks[ free_blocks_i ].begin - device->pos )
                            {   req_free_space -= free_blocks[0].begin - device->pos;
                                for( free_blocks_i++; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                {   if( req_free_space < free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                        break;
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                }
                            }
                            if( free_blocks_i == free_blocks_n )
                            {   struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                                if( req_free_space > file->l - free_blocks[ free_blocks_n - 1 ].end )
                                {   W( free_blocks );
                                    out_buf.error = -ENOSPC;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                                free_blocks_i--;
                            }
                            for( ; free_blocks_i; free_blocks_i-- )
                            {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[1] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_rename2;
                                }
                                free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                                free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                            }
                        }
                        W( free_blocks );
                    }
                    if( i != j )
                    {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            E_mem_Q_file_P_pos( device_file_id, device->pos + 2 * device_n_size );
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        N buf_size = device->pos - ( rec_pos + 3 *device_n_size + j );
                        Pc buf = M( buf_size );
                        if( !buf )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 *device_n_size + j );
                        if( E_mem_Q_file_R_s( device_file_id, buf, buf_size ))
                        {   W(buf);
                            out_buf.error = -ENOMEM;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 *device_n_size + i );
                        if( E_mem_Q_file_P_s( device_file_id, buf, buf_size ))
                        {   E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 *device_n_size + j );
                            if( E_mem_Q_file_P_s( device_file_id, buf, buf_size ))
                                goto Error;
                            W(buf);
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[1] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_rename2;
                        }
                        W(buf);
                    }
                    if( parent_dir_inode != in_buf_2->newdir )
                    {   E_mem_Q_file_P_pos( device_file_id, rec_pos + 2 * device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, in_buf_2->newdir, device_n_size ))
                            goto Error;
                    }else
                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                    if( E_mem_Q_file_P_s( device_file_id, E_text_Z_s0_R_end( (Pc)in_buf_2 + sizeof( *in_buf_2 )), i ))
                        goto Error;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_rename2:        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
            }
            G_(); Gd( buffer_read );
            if( !buffer_read )
                break;
        }
    }
End:E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    if( E_mem_Q_file_W( device_file_id ))
    {   E_base_W();
        return 1;
    }
    E_base_W();
    return 0;
Error:
    E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    E_mem_Q_file_W( device_file_id );
    E_base_W();
    return 1;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
