/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  C+
*  ¦/C+¦  filesystem
*   ---   mount
*         main
* ©overcq                on ‟Gentoo Linux 17.0” “x86_64”             2019‒3‒10 b
*******************************************************************************/
#define Z_inode_flags_1_S_directory             0x1000
#define Z_inode_flags_1_S_persistent            0x4000
#define Z_inode_flags_1_S_empty                 0x8000
#define Q_filesystem_S_top_of_boot_record_data  439
#define Q_filesystem_S_size_of_cluster          4096
#define Q_filesystem_S_buffer_size              ( 128 * 1024 )
#define Q_filesystem_S_cache_timeout            1000
#define S_max_read_buffer_size                  ( Q_filesystem_S_buffer_size + 4096 )
//==============================================================================
struct E_main_Z_file_handle
{ N inode;
};
struct E_mem_Q_tab_Z *file_handles;
//------------------------------------------------------------------------------
struct E_main_Z_sort_free_blocks_range
{ N nodeid;
  N begin, end;
};
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N device_n_size;
N Q_filesystem_S_inode_diff;
N Q_filesystem_S_table_of_files_offset;
//==============================================================================
N
E_main_Q_filesystem_R_inode( N filesystem_inode
){  if( filesystem_inode == FUSE_ROOT_ID )
        return filesystem_inode;
    return filesystem_inode + Q_filesystem_S_inode_diff;
}
N
E_main_Q_filesystem_P_inode( N kernel_inode
){  if( kernel_inode == FUSE_ROOT_ID )
        return kernel_inode;
    return kernel_inode - Q_filesystem_S_inode_diff;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
int
E_main_I_sort_free_blocks_cmp(
  const void *a
, const void *b
){  struct E_main_Z_sort_free_blocks_range *a_ = a, *b_ = b;
    return a_->begin == b_->begin ? 0 : ( a_->begin > b_->begin ? 1 : -1 );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
S32
E_main_Q_filesystem_I_move_data( N device_file_id
, N dst
, N src
, N l
){  J_assert( dst != src );
    J_assert(l);
    N buf_l = J_min( l, Q_filesystem_S_buffer_size );
    Pc buf = M( buf_l );
    if( !buf )
        return -ENOMEM;
    if( dst < src )
    {   while(l)
        {   if( l < buf_l )
                buf_l = l;
            if( E_mem_Q_file_P_pos( device_file_id, src ))
                return 1;
            if( E_mem_Q_file_R_s( device_file_id, buf, buf_l ))
                return 1;
            if( E_mem_Q_file_P_pos( device_file_id, dst ))
                return 1;
            if( E_mem_Q_file_P_s( device_file_id, buf, buf_l ))
                return 1;
            src += buf_l;
            dst += buf_l;
            l -= buf_l;
        }
    }else
    {   src = src + l - buf_l;
        dst = dst + l - buf_l;
        while(l)
        {   if( l < buf_l )
                buf_l = l;
            if( E_mem_Q_file_P_pos( device_file_id, src ))
                return 1;
            if( E_mem_Q_file_R_s( device_file_id, buf, buf_l ))
                return 1;
            if( E_mem_Q_file_P_pos( device_file_id, dst ))
                return 1;
            if( E_mem_Q_file_P_s( device_file_id, buf, buf_l ))
                return 1;
            src -= buf_l;
            dst -= buf_l;
            l -= buf_l;
        }
    }
    W(buf);
    return 0;
}
//------------------------------------------------------------------------------
S32
E_main_Q_filesystem_R_allocated_blocks( N device_file_id
, struct E_main_Z_sort_free_blocks_range **free_blocks
, N *free_blocks_n
){  Mt_( *free_blocks, 0 );
    if( !*free_blocks )
        return -ENOMEM;
    *free_blocks_n = 0;
    N inode = FUSE_ROOT_ID;
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
    {   W( *free_blocks );
        return 1;
    }
    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
    O{  if( device->pos == device->l )
            break;
        inode++;
        N parent_dir_inode;
        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
        {   W( *free_blocks );
            return 1;
        }
        N file_size_in_last_cluster;
        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
        {   W( *free_blocks );
            return 1;
        }
        N16 flags_1 = file_size_in_last_cluster & 0xf000;
        N file_pos_in_the_only_cluster;
        N file_pos_cluster;
        N file_size_clusters;
        if( !( flags_1 & Z_inode_flags_1_S_directory ))
        {   file_size_in_last_cluster &= 0xfff;
            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
            {   W( *free_blocks );
                return 1;
            }
            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
            {   W( *free_blocks );
                return 1;
            }
            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
            {   W( *free_blocks );
                return 1;
            }
        }
        O{  C c;
            if( E_mem_Q_file_R_c( device_file_id, &c ))
            {   W( *free_blocks );
                return 1;
            }
            if( !c )
                break;
        }
        if( flags_1 & Z_inode_flags_1_S_empty )
            continue;
        if( !( flags_1 & Z_inode_flags_1_S_directory )
        && file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster
        ){  if( !E_mem_Q_blk_I_append( free_blocks, 1 ))
            {   W( *free_blocks );
                return -ENOMEM;
            }
            (*free_blocks)[ *free_blocks_n ].nodeid = inode;
            (*free_blocks)[ *free_blocks_n ].begin = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
            (*free_blocks)[ *free_blocks_n ].end = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_size_clusters * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster + file_size_in_last_cluster; // “file_size_clusters” albo “file_pos_in_the_only_cluster” jest 0.
            (*free_blocks_n)++;
        }
    }
    qsort( &(*free_blocks)[0], *free_blocks_n, sizeof( (*free_blocks)[0] ), &E_main_I_sort_free_blocks_cmp );
    return 0;
}
S32
E_main_Q_filesystem_I_allocate( N device_file_id
, struct E_main_Z_sort_free_blocks_range **free_blocks
, N *free_blocks_n
, N file_size
, N *file_size_in_last_cluster
, N *file_pos_in_the_only_cluster
, N *file_pos_cluster
, N *file_size_clusters
){  // Wyszukanie wolnego bloku.
    if( file_size >= Q_filesystem_S_size_of_cluster )
    {   for_n( free_blocks_i, *free_blocks_n )
        {   N begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
            if( begin > (*free_blocks)[ free_blocks_i ].end )
                continue;
            if( (*free_blocks)[ free_blocks_i ].end - begin >= file_size )
            {   *file_size_in_last_cluster = file_size % Q_filesystem_S_size_of_cluster;
                *file_pos_in_the_only_cluster = 0;
                *file_pos_cluster = begin / Q_filesystem_S_size_of_cluster;
                *file_size_clusters = file_size / Q_filesystem_S_size_of_cluster;
                return 0;
            }
        }
    }else
    {   for_n( free_blocks_i, *free_blocks_n )
        {   N end = J_min( (*free_blocks)[ free_blocks_i ].end, E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster ));
            if( end - (*free_blocks)[ free_blocks_i ].begin >= file_size )
            {   *file_size_in_last_cluster = file_size;
                *file_pos_in_the_only_cluster = (*free_blocks)[ free_blocks_i ].begin % Q_filesystem_S_size_of_cluster;
                *file_pos_cluster = (*free_blocks)[ free_blocks_i ].begin / Q_filesystem_S_size_of_cluster;
                *file_size_clusters = 0;
                return 0;
            }
            N begin = J_max( (*free_blocks)[ free_blocks_i ].begin, E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ));
            if( (*free_blocks)[ free_blocks_i ].end - begin >= file_size )
            {   *file_size_in_last_cluster = file_size;
                *file_pos_in_the_only_cluster = begin % Q_filesystem_S_size_of_cluster;
                *file_pos_cluster = begin / Q_filesystem_S_size_of_cluster;
                *file_size_clusters = 0;
                return 0;
            }
            begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
            end = E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster );
            if( end > begin )
            {   *file_size_in_last_cluster = file_size;
                *file_pos_in_the_only_cluster = begin % Q_filesystem_S_size_of_cluster;
                *file_pos_cluster = begin / Q_filesystem_S_size_of_cluster;
                *file_size_clusters = 0;
                return 0;
            }
        }
    }
    // Proste upchanie bloków mniejszych niż rozmiar klastra.
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
        return 1;
    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
    O{  if( device->pos == device->l )
            break;
        N parent_dir_inode;
        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
            return 1;
        N file_size_in_last_cluster;
        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
            return 1;
        N16 flags_1 = file_size_in_last_cluster & 0xf000;
        N rec_pos = device->pos;
        N file_pos_in_the_only_cluster;
        N file_pos_cluster;
        if( !( flags_1 & Z_inode_flags_1_S_directory ))
        {   if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                return 1;
            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                return 1;
            N file_size_clusters;
            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                return 1;
        }
        N i = 0;
        O{  C c;
            if( E_mem_Q_file_R_c( device_file_id, &c ))
                return 1;
            i++;
            if( !c )
                break;
        }
        if(( flags_1 & ( Z_inode_flags_1_S_directory | Z_inode_flags_1_S_persistent | Z_inode_flags_1_S_empty ))
        || file_size_clusters
        )
            continue;
        N file_bound = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
        N file_free_block_size = file_size;
        N file_free_block_i_begin = ~0;
        N file_free_block_i_end = ~0;
        if( file_pos_in_the_only_cluster )
        {   for_n( free_blocks_i, *free_blocks_n )
            {   if( (*free_blocks)[ free_blocks_i ].end == file_bound )
                {   file_free_block_size += (*free_blocks)[ free_blocks_i ].end - J_max( E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ), (*free_blocks)[ free_blocks_i ].begin );
                    file_free_block_i_begin = free_blocks_i;
                    break;
                }
                if( (*free_blocks)[ free_blocks_i ].end > file_bound )
                    break;
            }
            if( file_pos_in_the_only_cluster + file_size != Q_filesystem_S_size_of_cluster )
            {   file_bound += file_size;
                if( free_blocks_i != *free_blocks_n )
                {   if( ++free_blocks_i != *free_blocks_n
                    && (*free_blocks)[ free_blocks_i ].begin == file_bound
                    )
                    {   file_free_block_size += J_min( E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster ), (*free_blocks)[ free_blocks_i ].end ) - (*free_blocks)[ free_blocks_i ].begin;
                        file_free_block_i_end = free_blocks_i;
                    }
                }else
                {   for_n( free_blocks_i, *free_blocks_n )
                    {   if( (*free_blocks)[ free_blocks_i ].begin == file_bound )
                        {   file_free_block_size += J_min( E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster ), (*free_blocks)[ free_blocks_i ].end ) - (*free_blocks)[ free_blocks_i ].begin;
                            file_free_block_i_end = free_blocks_i;
                            break;
                        }
                        if( (*free_blocks)[ free_blocks_i ].begin > file_bound )
                            break;
                    }
                }
            }
        }else if( file_pos_in_the_only_cluster + file_size != Q_filesystem_S_size_of_cluster )
        {   file_bound += file_size;
            for_n( free_blocks_i, *free_blocks_n )
            {   if( (*free_blocks)[ free_blocks_i ].begin == file_bound )
                {   file_free_block_size += J_min( E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster ), (*free_blocks)[ free_blocks_i ].end ) - (*free_blocks)[ free_blocks_i ].begin;
                    file_free_block_i_end = free_blocks_i;
                    break;
                }
                if( (*free_blocks)[ free_blocks_i ].begin > file_bound )
                    break;
            }
        }
        if( file_free_block_size == file_size ) // Plik jest w dopasowanym bloku (otoczony innymi plikami lub na granicy klastra).
            continue;
        N smallest_free_block_i = ~0;
        N smallest_free_block_case;
        for_n( free_blocks_i, *free_blocks_n )
        {   N free_block_size = J_min( (*free_blocks)[ free_blocks_i ].end, E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster )) - (*free_blocks)[ free_blocks_i ].begin;
            if( free_block_size >= file_size
            && free_block_size < file_free_block_size
            )
            {   smallest_free_block_case = 0;
                file_free_block_size = free_block_size;
                smallest_free_block_i = free_blocks_i;
                if( free_block_size == file_size )
                    break;
            }
            free_block_size = (*free_blocks)[ free_blocks_i ].end - J_max( (*free_blocks)[ free_blocks_i ].begin, E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ));
            if( free_block_size >= file_size
            && free_block_size < file_free_block_size
            )
            {   smallest_free_block_case = 1;
                file_free_block_size = free_block_size;
                smallest_free_block_i = free_blocks_i;
                if( free_block_size == file_size )
                    break;
            }
            if( E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ) > E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster ))
            {   free_block_size = E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ) - E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
                if( free_block_size >= file_size
                && free_block_size < file_free_block_size
                )
                {   smallest_free_block_case = 2;
                    file_free_block_size = free_block_size;
                    smallest_free_block_i = free_blocks_i;
                    if( free_block_size == file_size )
                        break;
                }
            }
        }
        if( ~smallest_free_block_i )
        {   N file_begin;
            switch( smallest_free_block_case )
            { case 0:
                    file_begin = (*free_blocks)[ smallest_free_block_i ].begin;
                    break;
              case 1:
                    file_begin = (*free_blocks)[ smallest_free_block_i ].end - file_size;
                    break;
              case 2:
                    file_begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ smallest_free_block_i ].begin, Q_filesystem_S_size_of_cluster );
                    break;
            }
            S32 ret = E_main_Q_filesystem_I_move_data( device_file_id, file_begin, file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster, file_size );
            if(ret)
                return ret;
            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                return 1;
            if( E_mem_Q_file_P_16( device_file_id, file_begin % Q_filesystem_S_size_of_cluster )
            || E_mem_Q_file_P_N( device_file_id, file_begin / Q_filesystem_S_size_of_cluster, device_n_size )
            )
                return 1;
            if( ~file_free_block_i_begin
            && ~file_free_block_i_end
            )
            {   (*free_blocks)[ file_free_block_i_begin ].end = (*free_blocks)[ file_free_block_i_end ].end;
                if( !E_mem_Q_blk_I_remove( &free_blocks, file_free_block_i_end, 1 ))
                    return -ENOMEM;
            }else if( ~file_free_block_i_begin )
                (*free_blocks)[ file_free_block_i_begin ].end += file_size;
            else
                (*free_blocks)[ file_free_block_i_end ].begin -= file_size;
            if( (*free_blocks)[ smallest_free_block_i ].end - (*free_blocks)[ smallest_free_block_i ].begin == file_size )
            {   if( !E_mem_Q_blk_I_remove( &free_blocks, smallest_free_block_i, 1 ))
                    return -ENOMEM;
            }else if( (*free_blocks)[ smallest_free_block_i ].begin != file_begin
            && (*free_blocks)[ smallest_free_block_i ].end != file_begin + file_size
            )
            {   if( !E_mem_Q_blk_I_insert( &free_blocks, smallest_free_block_i + 1, 1 ))
                    return -ENOMEM;
                (*free_blocks)[ smallest_free_block_i + 1 ].begin = file_begin + file_size;
                (*free_blocks)[ smallest_free_block_i + 1 ].end = (*free_blocks)[ smallest_free_block_i ].end;
                (*free_blocks)[ smallest_free_block_i ].end = file_begin;
            }else if( (*free_blocks)[ smallest_free_block_i ].begin != file_begin )
                (*free_blocks)[ smallest_free_block_i ].end = file_begin;
            else //if(*free_blocks)[ smallest_free_block_i ].end != file_begin + file_size
                (*free_blocks)[ smallest_free_block_i ].begin = file_begin + file_size;
            if( E_mem_Q_file_P_pos( device_file_id, device->pos + device_n_size + i ))
                return 1;
        }else if( ~file_free_block_i_begin )
        {   N file_begin = J_max( E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ file_free_block_i_begin ].end, Q_filesystem_S_size_of_cluster ), (*free_blocks)[ file_free_block_i_begin ].begin );
            S32 ret = E_main_Q_filesystem_I_move_data( device_file_id, file_begin, file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster, file_size );
            if(ret)
                return ret;
            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                return 1;
            if( E_mem_Q_file_P_16( device_file_id, file_begin % Q_filesystem_S_size_of_cluster )
            || E_mem_Q_file_P_N( device_file_id, file_begin / Q_filesystem_S_size_of_cluster, device_n_size )
            )
                return 1;
            if( ~file_free_block_i_end )
                (*free_blocks)[ file_free_block_i_end ].begin -= (*free_blocks)[ file_free_block_i_begin ].end - (*free_blocks)[ file_free_block_i_begin ].begin;
            if( (*free_blocks)[ file_free_block_i_begin ].begin == file_begin )
            {   if( !E_mem_Q_blk_I_remove( &free_blocks, file_free_block_i_begin, 1 ))
                    return -ENOMEM;
            }else
                (*free_blocks)[ file_free_block_i_end ].end = file_begin;
            if( E_mem_Q_file_P_pos( device_file_id, device->pos + device_n_size + i ))
                return 1;
        }
    }
    // Sprawdzenie, czy może starczyć wolnego miejsca.
    if( file_size >= Q_filesystem_S_size_of_cluster )
    {   N available_size = 0;
        N available_size_end_part = ~0;
        N available_size_end_part_i = ~0;
        for_n( free_blocks_i, *free_blocks_n )
        {   N begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
            N end = E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster );
            N available_size_end_part_ = (*free_blocks)[ free_blocks_i ].end - end;
            if( available_size_end_part_ >= file_size % Q_filesystem_S_size_of_cluster
            && available_size_end_part_ < available_size_end_part
            )
            {   available_size_end_part = available_size_end_part_;
                available_size_end_part_i = free_blocks_i;
            }
            if( begin > end )
                continue;
            available_size += end - begin;
        }
        if( !~available_size_end_part_i )
            available_size_end_part = 0;
        if( available_size + available_size_end_part < file_size ) // Poprzesuwanie pozostałych bloków nie wystarczy.
            return -ENOSPC;
        if( available_size >= file_size ) // Wystarczy poprzesuwać pełne klastry.
        {   struct E_main_Z_sort_free_blocks_range *allocated_blocks;
            N allocated_blocks_n;
            S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &allocated_blocks, &allocated_blocks_n );
            if(error)
                return error;
            N last_free_begin = 0;
            for_n( allocated_blocks_i, allocated_blocks_n )
            {   N allocated_begin = E_simple_Z_n_I_align_down_to_v2( allocated_blocks[ allocated_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
                if( last_free_begin != allocated_begin )
                {   if( last_free_begin > allocated_begin )
                        last_free_begin -= Q_filesystem_S_size_of_cluster;
                    N rec_pos;
                    N inode = FUSE_ROOT_ID;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                    {   W( *free_blocks );
                        return 1;
                    }
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                        {   W( *free_blocks );
                            return 1;
                        }
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                        {   W( *free_blocks );
                            return 1;
                        }
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        N file_pos_in_the_only_cluster;
                        N file_pos_cluster;
                        N file_size_clusters;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                            {   W( *free_blocks );
                                return 1;
                            }
                            rec_pos = device->pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                            {   W( *free_blocks );
                                return 1;
                            }
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                            {   W( *free_blocks );
                                return 1;
                            }
                        }
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                            {   W( *free_blocks );
                                return 1;
                            }
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( inode == allocated_blocks[ allocated_blocks_i ].nodeid )
                        {   if( !( flags_1 & Z_inode_flags_1_S_persistent ))
                            {   error = E_main_Q_filesystem_I_move_data( device_file_id, last_free_begin + ( allocated_blocks[ allocated_blocks_i ].begin - allocated_begin ), allocated_blocks[ allocated_blocks_i ].begin, file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster );
                                if(error)
                                {   W( allocated_blocks );
                                    return error;
                                }
                                if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                {   W( *free_blocks );
                                    return 1;
                                }
                                if( E_mem_Q_file_P_N( device_file_id, last_free_begin / Q_filesystem_S_size_of_cluster, device_n_size ))
                                {   W( *free_blocks );
                                    return 1;
                                }
                            }
                            break;
                        }
                    }
                }
                last_free_begin = E_simple_Z_n_I_align_up_to_v2( allocated_blocks[ allocated_blocks_i ].end, Q_filesystem_S_size_of_cluster );
            }
            W( allocated_blocks );
            if( !E_mem_Q_blk_I_remove( free_blocks, 0, *free_blocks_n ))
                return -ENOMEM;
            struct E_main_Z_sort_free_blocks_range *free_blocks_;
            N free_blocks_n_;
            error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks_, &free_blocks_n_ );
            if(error)
                return error;
            W( *free_blocks );
            *free_blocks = free_blocks_;
            *free_blocks_n = free_blocks_n_;
            // Przeliczenie na ‘free blocks’.
            N free_blocks_i = free_blocks_n_ - 1;
            if( free_blocks_[ free_blocks_i ].end != Q_filesystem_S_table_of_files_offset )
            {   if( !E_mem_Q_blk_I_append( &free_blocks_, 1 ))
                {   W( free_blocks_ );
                    return -ENOMEM;
                }
                free_blocks_n_++;
                *free_blocks_n = free_blocks_n_;
                free_blocks_[ free_blocks_n_ - 1 ].end = Q_filesystem_S_table_of_files_offset;
                free_blocks_[ free_blocks_n_ - 1 ].begin = free_blocks_[ free_blocks_i ].end;
            }
            for( ; free_blocks_i; free_blocks_i-- )
            {   if( free_blocks_[ free_blocks_i - 1 ].end != free_blocks_[ free_blocks_i ].begin )
                {   free_blocks_[ free_blocks_i ].end = free_blocks_[ free_blocks_i ].begin;
                    free_blocks_[ free_blocks_i ].begin = free_blocks_[ free_blocks_i - 1 ].end;
                }else
                {   if( !E_mem_Q_blk_I_remove( &free_blocks_, free_blocks_i, 1 ))
                    {   W( free_blocks_ );
                        return -ENOMEM;
                    }
                    free_blocks_n_--;
                    *free_blocks_n = free_blocks_n_;
                }
            }
            if( free_blocks_[0].begin )
            {   free_blocks_[0].end = free_blocks_[0].begin;
                free_blocks_[0].begin = 0;
            }else
            {   if( !E_mem_Q_blk_I_remove( &free_blocks_, 0, 1 ))
                {   W( free_blocks_ );
                    return -ENOMEM;
                }
                free_blocks_n_--;
                *free_blocks_n = free_blocks_n_;
            }
            for_n_( free_blocks_i, free_blocks_n_ )
            {   N begin = E_simple_Z_n_I_align_up_to_v2( free_blocks_[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
                N end = E_simple_Z_n_I_align_down_to_v2( free_blocks_[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster );
                if( begin > end )
                    continue;
                if( end - begin >= file_size )
                {   W( free_blocks_ );
                    *file_size_in_last_cluster = file_size % Q_filesystem_S_size_of_cluster;
                    *file_pos_in_the_only_cluster = 0;
                    *file_pos_cluster = begin / Q_filesystem_S_size_of_cluster;
                    *file_size_clusters = file_size / Q_filesystem_S_size_of_cluster;
                    return 0;
                }
            }
            return -ENOSPC; // Niemożliwość przeniesienia któregoś pliku przedzieliła wolny blok pamięci dyskowej.
        }
        // Trzeba poprzesuwać uwzględniając wolny fragment na początku zajętego klastra.
        
        return -ENOSPC; // TODO Poprzesuwać pliki zamiast błędu.
    }else
    {   N file_free_block_size = ~0;
        N smallest_free_block_i = ~0;
        N smallest_free_block_case;
        for_n( free_blocks_i, *free_blocks_n )
        {   N free_block_size = J_min( (*free_blocks)[ free_blocks_i ].end, E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster )) - (*free_blocks)[ free_blocks_i ].begin; // Na początku wolnego bloku.
            if( free_block_size >= file_size
            && free_block_size < file_free_block_size
            )
            {   smallest_free_block_case = 0;
                file_free_block_size = free_block_size;
                smallest_free_block_i = free_blocks_i;
                if( free_block_size == file_size )
                    break;
            }
            free_block_size = (*free_blocks)[ free_blocks_i ].end - J_max( (*free_blocks)[ free_blocks_i ].begin, E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster )); // Na końcu wolnego bloku.
            if( free_block_size >= file_size
            && free_block_size < file_free_block_size
            )
            {   smallest_free_block_case = 1;
                file_free_block_size = free_block_size;
                smallest_free_block_i = free_blocks_i;
                if( free_block_size == file_size )
                    break;
            }
            if( E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ) > E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster )) // W środku wolnego bloku.
            {   free_block_size = E_simple_Z_n_I_align_down_to_v2( (*free_blocks)[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster ) - E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
                if( free_block_size >= file_size
                && free_block_size < file_free_block_size
                )
                {   smallest_free_block_case = 2;
                    file_free_block_size = free_block_size;
                    smallest_free_block_i = free_blocks_i;
                    if( free_block_size == file_size )
                        break;
                }
            }
        }
        if( !~smallest_free_block_i )
            return -ENOSPC;
        N file_begin;
        switch( smallest_free_block_case )
        { case 0:
                file_begin = (*free_blocks)[ smallest_free_block_i ].begin;
                break;
          case 1:
                file_begin = (*free_blocks)[ smallest_free_block_i ].end - file_size;
                break;
          case 2:
                file_begin = E_simple_Z_n_I_align_up_to_v2( (*free_blocks)[ smallest_free_block_i ].begin, Q_filesystem_S_size_of_cluster );
                break;
        }
        *file_size_in_last_cluster = file_size;
        *file_pos_in_the_only_cluster = file_begin % Q_filesystem_S_size_of_cluster;
        *file_pos_cluster = file_begin / Q_filesystem_S_size_of_cluster;
        *file_size_clusters = 0;
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int
main(
  int argc
, char *argv[]
){  E_base_M( argc, argv );
    Pc device = 0;
    Pc directory = 0;
    B option = no;
    for( int i = 1; i != argc; i++ )
    {   if( option )
        {   option = no;
            continue;
        }
        if( *argv[i] == '-' )
        {   if( E_text_Z_s0_T_s0_eq( argv[i] + 1, "o" ))
            {   option = yes;
                continue;
            }
            E_base_W();
            return 1;
        }
        if(directory)
        {   E_base_W();
            return 1;
        }
        if(device)
            directory = argv[i];
        else
            device = argv[i];
    }
    if( !device
    || !directory
    || option
    ){  E_base_W();
        return 1;
    }
    I device_file_id;
    if( !~( device_file_id = E_mem_Q_file_M( device, no )))
    {   E_base_W();
        return 1;
    }
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data ))
    {   E_base_W();
        return 1;
    }
    N filesystem_version;
    if( E_mem_Q_file_R_N( device_file_id, &filesystem_version, 1 )
    || filesystem_version != 1
    ){  E_base_W();
        return 1;
    }
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 ))
    {   E_base_W();
        return 1;
    }
    N cluster_address_size_power_bit;
    if( E_mem_Q_file_R_N( device_file_id, &cluster_address_size_power_bit, 1 )
    || !cluster_address_size_power_bit
    || cluster_address_size_power_bit > 6
    ){  E_base_W();
        return 1;
    }
    device_n_size = ( 1 << cluster_address_size_power_bit ) / 8;
    Q_filesystem_S_inode_diff = E_simple_Z_n_I_mod_i2( ~0, device_n_size * 8 ) - FUSE_ROOT_ID;
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 - 2 - device_n_size ))
    {   E_base_W();
        return 1;
    }
    if( E_mem_Q_file_R_N( device_file_id, &Q_filesystem_S_table_of_files_offset, device_n_size ))
    {   E_base_W();
        return 1;
    }
    N table_of_files_pos_in_cluster;
    if( E_mem_Q_file_R_16( device_file_id, &table_of_files_pos_in_cluster ))
    {   E_base_W();
        return 1;
    }
    Q_filesystem_S_table_of_files_offset *= Q_filesystem_S_size_of_cluster;
    Q_filesystem_S_table_of_files_offset += table_of_files_pos_in_cluster;
    struct E_mem_Q_file_Z *device_ = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
    {   E_base_W();
        return 1;
    }
    O{  if( device_->pos == device_->l )
            break;
        if( !Q_filesystem_S_inode_diff ) // Za duża tablica listy plików.
        {   E_base_W();
            return 1;
        }
        N parent_dir_inode;
        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
        {   E_base_W();
            return 1;
        }
        N file_size_in_last_cluster;
        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
        {   E_base_W();
            return 1;
        }
        N16 flags_1 = file_size_in_last_cluster & 0xf000;
        if( !( flags_1 & Z_inode_flags_1_S_directory ))
        {   N file_pos_in_the_only_cluster;
            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
            {   E_base_W();
                return 1;
            }
            N file_pos_cluster;
            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
            {   E_base_W();
                return 1;
            }
            N file_size_clusters;
            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
            {   E_base_W();
                return 1;
            }
        }
        O{  C c;
            if( E_mem_Q_file_R_c( device_file_id, &c ))
            {   E_base_W();
                return 1;
            }
            if( !c )
                break;
        }
        Q_filesystem_S_inode_diff--;
    }
    int fuse_fd;
    VO1( fuse_fd = open( "/dev/fuse", O_RDWR ))
    {   E_base_W();
        return 1;
    }
        #if defined( __gnu_linux__ )
    cap_t cap;
    Vp( cap = cap_get_proc() )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    cap_value_t cap_list[1] = { CAP_SYS_ADMIN };
    V1( cap_set_flag( cap, CAP_EFFECTIVE, 1, &cap_list[0], CAP_CLEAR ))
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=%u,allow_other", fuse_fd, 040000, getuid(), getgid(), Q_filesystem_S_size_of_cluster );
    V1( mount( device, directory, "fuseblk", 0, s_2 ))
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
    V1( cap_set_proc(cap) )
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    V1( cap_free(cap) )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
        #else
    N l = 128;
    Pc s_2 = M(l);
    if( !s_2 )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    snprintf( s_2, l, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=%u,allow_other", fuse_fd, 040000, getuid(), getgid(), Q_filesystem_S_size_of_cluster );
    V1( mount( device, directory, 0, s_2 ))
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
        #endif
    N read_buffer_size, read_count;
    P read_buffer = M( read_buffer_size = S_max_read_buffer_size );
    if( !read_buffer )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N inode_generation = 0;
    file_handles = E_mem_Q_tab_M( sizeof( struct E_main_Z_file_handle ), 0 );
    O{  int error;
        VO1e( read_count = read( fuse_fd, read_buffer, read_buffer_size ), error )
        {   if( error == ENODEV )
                goto End;
            goto Error;
        }
        struct fuse_in_header *in_buf = read_buffer;
        O{  if( read_count < sizeof( *in_buf ))
                goto Error;
            read_count -= sizeof( *in_buf );
            struct fuse_out_header out_buf;
            out_buf.len = sizeof( out_buf );
            out_buf.error = 0;
            out_buf.unique = in_buf->unique;
            G_(); Gh( in_buf->unique ); Gd( in_buf->opcode );
            switch( in_buf->opcode )
            { default:
                    goto Error;
              case FUSE_INTERRUPT:
                {   struct fuse_interrupt_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FORGET:
                {   struct fuse_forget_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_BATCH_FORGET:
                {   struct fuse_batch_forget_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( read_count < in_buf_2->count * sizeof( struct fuse_forget_one ))
                        goto Error;
                    read_count -= in_buf_2->count * sizeof( struct fuse_forget_one );
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ) + in_buf_2->count * sizeof( struct fuse_forget_one ));
                    break;
                }
              case FUSE_INIT:
                {   struct fuse_init_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->major ); Gd( in_buf_2->minor );
                    struct fuse_init_out out_buf_2;
                    out_buf.len += sizeof( out_buf_2 );
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    if( in_buf_2->major > 7 )
                    {   out_buf_2.major = 7;
                        out_buf_2.minor = 0;
                    }else if( in_buf_2->major == 7 )
                    {   out_buf_2.major = in_buf_2->major;
                        out_buf_2.minor = 33;
                    }else
                    {   V();
                    }
                    G_(); Gd( out_buf_2.major ); Gd( out_buf_2.minor );
                    if( in_buf_2->major > 7
                    || ( in_buf_2->major == 7 && in_buf_2->minor >= 5
                    ))
                        out_buf_2.max_write = Q_filesystem_S_buffer_size;
                    out_buf_2.flags = FUSE_BIG_WRITES;
                    if( in_buf_2->major > 7
                    || ( in_buf_2->major == 7 && in_buf_2->minor >= 28
                    ))
                    {   out_buf_2.flags |= FUSE_MAX_PAGES;
                        out_buf_2.max_pages = S_max_read_buffer_size / 4096;
                    }
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_DESTROY:
                    goto End;
              case FUSE_FLUSH:
                {   struct fuse_flush_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_FSYNC:
                {   struct fuse_fsync_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_file_I_save( device_file_id );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_ACCESS:
                {   struct fuse_access_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    if( nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        N16 flags_1;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                        if( inode != nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                            out_buf.error = -ENOENT;
                    }
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_LOOKUP:
                {   //TODO "." i ".."
                    read_count -= in_buf->len - sizeof( *in_buf );
                    if( in_buf->len - sizeof( *in_buf ) < 2 )
                        goto Error;
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.generation = ++inode_generation;
                    out_buf_2.entry_valid = out_buf_2.attr_valid = Q_filesystem_S_cache_timeout;
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    N inode = FUSE_ROOT_ID;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        N file_size_clusters;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N inode_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            if( E_mem_Q_file_P_pos( device_file_id, inode_pos ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                out_buf_2.nodeid = out_buf_2.attr.ino = E_main_Q_filesystem_R_inode(inode);
                                out_buf_2.attr.nlink = 1;
                                if( flags_1 & Z_inode_flags_1_S_directory )
                                {   out_buf_2.attr.mode = S_IFDIR | 0777;
                                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                                        goto Error;
                                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                                    O{  if( device->pos == device->l )
                                            break;
                                        N i = 0;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        N file_size_in_last_cluster;
                                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                            goto Error;
                                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                                        {   N file_pos_in_the_only_cluster;
                                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                                goto Error;
                                            N file_pos_cluster;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                                goto Error;
                                            N file_size_clusters;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                                goto Error;
                                        }
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            i++;
                                            if( !c )
                                                break;
                                        }
                                        if( parent_dir_inode == nodeid
                                        && !( flags_1 & Z_inode_flags_1_S_empty )
                                        )
                                        {   out_buf_2.attr.size += i + 3 * device_n_size + 2 * 2;
                                            out_buf_2.attr.nlink++;
                                        }
                                    }
                                }else
                                {   out_buf_2.attr.size = file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster;
                                    out_buf_2.attr.mode = S_IFREG | 0666;
                                }
                                out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( out_buf_2.attr.size, Q_filesystem_S_size_of_cluster ) / Q_filesystem_S_size_of_cluster;
                                out_buf.len += sizeof( out_buf_2 );
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                , { &out_buf_2, sizeof( out_buf_2 ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_lookup;
                            }
                            W(s);
                        }
                    }
                    out_buf.error = -ENOENT;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_lookup:         in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_GETATTR:
                {   struct fuse_getattr_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = Q_filesystem_S_cache_timeout;
                    if( in_buf_2->getattr_flags & FUSE_GETATTR_FH )
                    {   if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                        struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                        out_buf_2.attr.ino = file_handle->inode;
                    }else
                    {   out_buf_2.attr.ino = in_buf->nodeid;
                    }
                    N nodeid = E_main_Q_filesystem_P_inode( out_buf_2.attr.ino );
                    N file_size_in_last_cluster;
                    N file_size_clusters;
                    N16 flags_1;
                    if( out_buf_2.attr.ino != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                        if( inode != nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                            break;
                        }
                    }else
                        flags_1 |= Z_inode_flags_1_S_directory;
                    if( flags_1 & Z_inode_flags_1_S_directory )
                    {   out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 2;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_1 & Z_inode_flags_1_S_empty )
                            )
                            {   out_buf_2.attr.size += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   out_buf_2.attr.size = file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster;
                        out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf_2.attr.blocks = E_simple_Z_n_I_align_up_to_v2( out_buf_2.attr.size, Q_filesystem_S_size_of_cluster ) / Q_filesystem_S_size_of_cluster;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_GETXATTR:
                {   struct fuse_getxattr_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_SETXATTR:
                {   struct fuse_setxattr_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LISTXATTR:
                {   read_count -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_SETATTR:
                {   struct fuse_setattr_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    N nodeid;
                    if( in_buf_2->valid & FATTR_FH )
                    {   if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_setattr;
                        }
                        struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                        nodeid = E_main_Q_filesystem_P_inode( file_handle->inode );
                    }else
                        nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    N rec_pos;
                    N file_size_in_last_cluster;
                    N16 flags_1;
                    N file_size_clusters;
                    if( nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            rec_pos = device->pos;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                        if( inode != nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {  out_buf.error = -ENOENT;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_setattr;
                        }
                    }else
                        flags_1 |= Z_inode_flags_1_S_directory;
                    struct fuse_attr_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = Q_filesystem_S_cache_timeout;
                    if( nodeid == FUSE_ROOT_ID
                    || flags_1 & Z_inode_flags_1_S_directory
                    ){  out_buf_2.attr.mode = S_IFDIR | 0777;
                        out_buf_2.attr.nlink = 1;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( parent_dir_inode == out_buf_2.attr.ino
                            && !( flags_1 & Z_inode_flags_1_S_empty )
                            )
                            {   out_buf_2.attr.size += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                out_buf_2.attr.nlink++;
                            }
                        }
                    }else
                    {   N file_size = file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster;
                        if( in_buf_2->valid & FATTR_SIZE
                        && in_buf_2->size != file_size
                        )
                        {   if( flags_1 & Z_inode_flags_1_S_persistent )
                            {   out_buf.error = -EPERM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_setattr;
                            }
                            if( in_buf_2->size < file_size )
                            {   if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_P_16( device_file_id, flags_1 | ( in_buf_2->size % Q_filesystem_S_size_of_cluster )))
                                    goto Error;
                                if( in_buf_2->size )
                                {   if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 + 2 + device_n_size ))
                                        goto Error;
                                }else
                                {   if( E_mem_Q_file_P_16( device_file_id, 0 ))
                                        goto Error;
                                    if( E_mem_Q_file_P_N( device_file_id, 0, device_n_size ))
                                        goto Error;
                                    
                                }
                                if( E_mem_Q_file_P_N( device_file_id, in_buf_2->size / Q_filesystem_S_size_of_cluster, device_n_size ))
                                    goto Error;
                            }else // TODO Przydzielić miejsce i wypełnić dodaną zawartość zerami zamiast błędu.
                            {   out_buf.error = -ENOSYS;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_setattr;
                            }
                        }
                        out_buf_2.attr.mode = S_IFREG | 0666;
                        out_buf_2.attr.nlink = 1;
                    }
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_setattr:        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_OPEN:
              case FUSE_OPENDIR:
                {   struct fuse_open_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->open_flags );
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    if( nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        N16 flags_1;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                        if( inode != nodeid
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_open;
                        }
                    }
                    if( !~E_mem_Q_tab_R_n( file_handles ))
                    {   out_buf.error = -EMFILE;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_open;
                    }
                    struct fuse_open_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_2.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_open;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_2.fh );
                    file_handle->inode = E_main_Q_filesystem_R_inode( nodeid );
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_open:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_READ:
              case FUSE_READDIR:
                {   struct fuse_read_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    N nodeid = E_main_Q_filesystem_P_inode( file_handle->inode );
                    N parent_dir_inode;
                    N file_size_in_last_cluster;
                    N16 flags_1;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    if( nodeid != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        O{  inode++;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   file_size_in_last_cluster &= 0xfff;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( inode == nodeid )
                                break;
                        }
                    }else
                        flags_1 |= Z_inode_flags_1_S_directory;
                    N len;
                    P out_buf_2;
                    if( flags_1 & Z_inode_flags_1_S_directory )
                    {   out_buf_2 = M( len = 0 );
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        N node_offset = 0;
                        N node_size = in_buf_2->size;
                        N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            N inode_pos = device->pos;
                            N i = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                i++;
                                if( !c )
                                    break;
                            }
                            if( flags_1 & Z_inode_flags_1_S_empty )
                                continue;
                            if( parent_dir_inode == nodeid )
                            {   Pc s = M(i);
                                if( !s )
                                {   out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                if( E_mem_Q_file_P_pos( device_file_id, inode_pos ))
                                    goto Error;
                                if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                    goto Error;
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_offset >= in_buf_2->offset )
                                {   if( node_size < size )
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOBUFS;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    node_size -= size;
                                    len += size;
                                    if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                    {   W(s);
                                        W( out_buf_2 );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_read;
                                    }
                                    struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                    *d = ( struct fuse_dirent )
                                    { inode
                                    , node_offset + size
                                    , i - 1
                                    , ( flags_1 & Z_inode_flags_1_S_directory ? S_IFDIR : S_IFREG ) >> 12
                                    };
                                    E_text_Z_s_P_s0_copy_0( d->name, s );
                                    E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                }
                                W(s);
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                            if( inode == nodeid
                            && node_offset >= in_buf_2->offset
                            ){  N i = 2;
                                N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                                if( node_size < size )
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOBUFS;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                node_size -= size;
                                len += size;
                                if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                                {   W( out_buf_2 );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_read;
                                }
                                struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                                *d = ( struct fuse_dirent )
                                { inode
                                , node_offset + size
                                , i - 1
                                , S_IFDIR >> 12
                                };
                                E_text_Z_s_P_s0_copy_0( d->name, "." );
                                E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                                node_offset += size;
                                if( !node_size )
                                    break;
                            }
                        }
                        if( nodeid == FUSE_ROOT_ID
                        && node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 2;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            node_size -= size;
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { FUSE_ROOT_ID
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, "." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                            node_offset += size;
                        }
                        if( node_size
                        && node_offset >= in_buf_2->offset
                        ){  N i = 3;
                            N size = E_simple_Z_n_I_align_up_to_v2( sizeof( struct fuse_dirent ) + i, 8 );
                            if( node_size < size )
                            {   W( out_buf_2 );
                                out_buf.error = -ENOBUFS;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            len += size;
                            if( !E_mem_Q_blk_I_append( &out_buf_2, size ))
                            {   W( out_buf_2 );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_read;
                            }
                            struct fuse_dirent *d = (P)( (Pc)out_buf_2 + len - size );
                            *d = ( struct fuse_dirent )
                            { parent_dir_inode
                            , node_offset + size
                            , i - 1
                            , S_IFDIR >> 12
                            };
                            E_text_Z_s_P_s0_copy_0( d->name, ".." );
                            E_mem_Q_blk_P_fill_c( d->name + i, size - ( offsetof( struct fuse_dirent, name ) + i ), 0 );
                        }
                    }else
                    {   N file_size = file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster;
                        if( in_buf_2->offset >= file_size )
                            len = 0;
                        else if( in_buf_2->offset + in_buf_2->size >= file_size )
                            len = file_size - in_buf_2->offset;
                        else
                            len = in_buf_2->size;
                        out_buf_2 = M(len);
                        if( !out_buf_2 )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_read;
                        }
                        if(len)
                        {   if( E_mem_Q_file_P_pos( device_file_id, file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster + in_buf_2->offset ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, out_buf_2, len ))
                                goto Error;
                        }
                    }
                    out_buf.len += len;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { out_buf_2, len }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    W( out_buf_2 );
End_read:           in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_RELEASE:
              case FUSE_RELEASEDIR:
                {   struct fuse_release_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->release_flags ); Gh( in_buf_2->lock_owner );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                        out_buf.error = -ENOENT;
                    else
                    {   E_mem_Q_tab_I_remove( file_handles, in_buf_2->fh );
                        if( in_buf_2->flags & FUSE_RELEASE_FLUSH )
                            E_mem_Q_file_I_save( device_file_id );
                    }
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_CREATE:
                {   struct fuse_create_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    if( in_buf->len - ( sizeof( *in_buf ) + sizeof( *in_buf_2 )) < 2 )
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags ); Gh( in_buf_2->mode );
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    N inode = FUSE_ROOT_ID;
                    N inode_empty = ~0;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N rec_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                        {   inode_empty = inode;
                            continue;
                        }
                        if( parent_dir_inode == nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            W(s);
                        }
                    }
                    if( !~E_mem_Q_tab_R_n( file_handles ))
                    {   out_buf.error = -EMFILE;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    struct E_main_Z_sort_free_blocks_range *free_blocks;
                    N free_blocks_n;
                    S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                    if( error == 1 )
                        goto Error;
                    if(error)
                    {   out_buf.error = error;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    // Przydzielenie miejsca na wpis w tablicy plików.
                    N rec_pos;
                    if( !~inode_empty )
                    {   if( !Q_filesystem_S_inode_diff )
                        {   W( free_blocks );
                            out_buf.error = -ENFILE;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N req_free_space = device_n_size + 2 * 2 + 2 * device_n_size + i;
                        if( Q_filesystem_S_table_of_files_offset < req_free_space )
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        if( free_blocks_n
                        && Q_filesystem_S_table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                        ) // TODO Scalenie plików od ostatniego zamiast błędu.
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N rec_pos = device->pos;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( flags_1 & Z_inode_flags_1_S_empty )
                                continue;
                            if( parent_dir_inode != FUSE_ROOT_ID )
                            {   N rec_pos_ = device->pos;
                                if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                    goto Error;
                                if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode + 1, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_P_pos( device_file_id, rec_pos_ ))
                                    goto Error;
                            }
                        }
                        Q_filesystem_S_inode_diff--;
                        Q_filesystem_S_table_of_files_offset -= req_free_space;
                        rec_pos = Q_filesystem_S_table_of_files_offset;
                        inode_empty = FUSE_ROOT_ID + 1;
                    }else
                    {   N i_ = i;
                        N i_old;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        O{  rec_pos = device->pos;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                            }
                            i_old = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                i_old++;
                                if( !c )
                                    break;
                            }
                            if( inode == inode_empty )
                            {   if( flags_1 & Z_inode_flags_1_S_directory )
                                    i_ += 2 + 2 * device_n_size;
                                break;
                            }
                        }
                        if( i_ > i_old )
                        {   N req_free_space = i_ - i_old;
                            if( Q_filesystem_S_table_of_files_offset < req_free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            if( free_blocks_n
                            && Q_filesystem_S_table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, Q_filesystem_S_table_of_files_offset - req_free_space, Q_filesystem_S_table_of_files_offset, rec_pos - Q_filesystem_S_table_of_files_offset );
                            if( error == 1 )
                            {   W( free_blocks );
                                goto Error;
                            }
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            Q_filesystem_S_table_of_files_offset -= req_free_space;
                            rec_pos -= req_free_space;
                        }else if( i_ < i_old )
                        {   N avail_free_space = i_old - i_;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, Q_filesystem_S_table_of_files_offset + avail_free_space, Q_filesystem_S_table_of_files_offset, rec_pos - Q_filesystem_S_table_of_files_offset );
                            if( error == 1 )
                            {   W( free_blocks );
                                goto Error;
                            }
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_create;
                            }
                            Q_filesystem_S_table_of_files_offset += avail_free_space;
                            rec_pos += avail_free_space;
                        }
                    }
                    W( free_blocks );
                    // Wpisanie do tablicy plików.
                    if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                        goto Error;
                    if( E_mem_Q_file_P_N( device_file_id, nodeid + ( rec_pos == Q_filesystem_S_table_of_files_offset && nodeid != FUSE_ROOT_ID ? 1 : 0 ), device_n_size )
                    || E_mem_Q_file_P_16( device_file_id, 0 )
                    || E_mem_Q_file_P_16( device_file_id, 0 )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_N( device_file_id, 0, device_n_size )
                    || E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    )
                        goto Error;
                    if( rec_pos == Q_filesystem_S_table_of_files_offset )
                    {   if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 - 2 - device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, Q_filesystem_S_table_of_files_offset / Q_filesystem_S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, Q_filesystem_S_table_of_files_offset % Q_filesystem_S_size_of_cluster ))
                            goto Error;
                    }
                    struct fuse_open_out out_buf_3;
                    E_mem_Q_blk_P_fill_c( &out_buf_3, sizeof( out_buf_3 ), 0 );
                    out_buf_3.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_3.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_create;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, out_buf_3.fh );
                    file_handle->inode = E_main_Q_filesystem_R_inode( inode_empty );
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = out_buf_2.attr.ino = E_main_Q_filesystem_R_inode( inode_empty );
                    out_buf_2.generation = ++inode_generation;
                    out_buf_2.entry_valid = out_buf_2.attr_valid = Q_filesystem_S_cache_timeout;
                    out_buf_2.attr.mode = S_IFREG | 0666;
                    out_buf_2.attr.nlink = 1;
                    out_buf.len += sizeof( out_buf_2 ) + sizeof( out_buf_3 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    , { &out_buf_3, sizeof( out_buf_3 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_create:         in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_MKDIR:
                {   struct fuse_mkdir_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    if( in_buf->len - ( sizeof( *in_buf ) + sizeof( *in_buf_2 )) < 2 )
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->mode );
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    N inode = FUSE_ROOT_ID;
                    N inode_empty = ~0;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N rec_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                        {   inode_empty = inode;
                            continue;
                        }
                        if( parent_dir_inode == nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                out_buf.error = -EEXIST;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            W(s);
                        }
                    }
                    N i = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    struct E_main_Z_sort_free_blocks_range *free_blocks;
                    N free_blocks_n;
                    S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                    if( error == 1 )
                        goto Error;
                    if(error)
                    {   out_buf.error = error;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_mkdir;
                    }
                    // Przydzielenie miejsca na wpis w tablicy plików.
                    N rec_pos;
                    if( !~inode_empty )
                    {   if( !Q_filesystem_S_inode_diff )
                        {   W( free_blocks );
                            out_buf.error = -ENFILE;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_mkdir;
                        }
                        N req_free_space = device_n_size + 2 + i;
                        if( Q_filesystem_S_table_of_files_offset < req_free_space )
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_mkdir;
                        }
                        if( free_blocks_n
                        && Q_filesystem_S_table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                        ) // TODO Scalenie plików od ostatniego zamiast błędu.
                        {   W( free_blocks );
                            out_buf.error = -ENOSPC;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_mkdir;
                        }
                        N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N rec_pos = device->pos;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( flags_1 & Z_inode_flags_1_S_empty )
                                continue;
                            if( parent_dir_inode != FUSE_ROOT_ID )
                            {   N rec_pos_ = device->pos;
                                if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                    goto Error;
                                if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode + 1, device_n_size ))
                                    goto Error;
                                if( E_mem_Q_file_P_pos( device_file_id, rec_pos_ ))
                                    goto Error;
                            }
                        }
                        Q_filesystem_S_inode_diff--;
                        Q_filesystem_S_table_of_files_offset -= req_free_space;
                        rec_pos = Q_filesystem_S_table_of_files_offset;
                        inode_empty = FUSE_ROOT_ID + 1;
                    }else
                    {   N i_ = i;
                        N i_old;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        O{  rec_pos = device->pos;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            N16 flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                            }
                            i_old = 0;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                {   W( free_blocks );
                                    goto Error;
                                }
                                i_old++;
                                if( !c )
                                    break;
                            }
                            if( inode == inode_empty )
                            {   if( !( flags_1 & Z_inode_flags_1_S_directory ))
                                    i_old += 2 + 2 * device_n_size;
                                break;
                            }
                        }
                        if( i_ > i_old )
                        {   N req_free_space = i_ - i_old;
                            if( Q_filesystem_S_table_of_files_offset < req_free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            if( free_blocks_n
                            && Q_filesystem_S_table_of_files_offset - req_free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, Q_filesystem_S_table_of_files_offset - req_free_space, Q_filesystem_S_table_of_files_offset, rec_pos - Q_filesystem_S_table_of_files_offset );
                            if( error == 1 )
                            {   W( free_blocks );
                                goto Error;
                            }
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            Q_filesystem_S_table_of_files_offset -= req_free_space;
                            rec_pos -= req_free_space;
                        }else if( i_ < i_old )
                        {   N avail_free_space = i_old - i_;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, Q_filesystem_S_table_of_files_offset + avail_free_space, Q_filesystem_S_table_of_files_offset, rec_pos - Q_filesystem_S_table_of_files_offset );
                            if( error == 1 )
                            {   W( free_blocks );
                                goto Error;
                            }
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_mkdir;
                            }
                            Q_filesystem_S_table_of_files_offset += avail_free_space;
                            rec_pos += avail_free_space;
                        }
                    }
                    W( free_blocks );
                    // Wpisanie do tablicy plików.
                    if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                        goto Error;
                    if( E_mem_Q_file_P_N( device_file_id, nodeid + ( rec_pos == Q_filesystem_S_table_of_files_offset && nodeid != FUSE_ROOT_ID ? 1 : 0 ), device_n_size )
                    || E_mem_Q_file_P_16( device_file_id, Z_inode_flags_1_S_directory )
                    || E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), i )
                    )
                        goto Error;
                    if( rec_pos == Q_filesystem_S_table_of_files_offset )
                    {   if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 - 2 - device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, Q_filesystem_S_table_of_files_offset / Q_filesystem_S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, Q_filesystem_S_table_of_files_offset % Q_filesystem_S_size_of_cluster ))
                            goto Error;
                    }
                    struct fuse_entry_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.nodeid = out_buf_2.attr.ino = E_main_Q_filesystem_R_inode( inode_empty );
                    out_buf_2.generation = ++inode_generation;
                    out_buf_2.entry_valid = out_buf_2.attr_valid = Q_filesystem_S_cache_timeout;
                    out_buf_2.attr.mode = S_IFDIR | 0777;
                    out_buf_2.attr.nlink = 2;
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_mkdir:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_UNLINK:
              case FUSE_RMDIR:
                {   read_count -= in_buf->len - sizeof( *in_buf );
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                        {   out_buf.error = -ENOENT;
                            break;
                        }
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   N file_pos_in_the_only_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            N file_pos_cluster;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            N file_size_clusters;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        N rec_pos = device->pos;
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == nodeid )
                        {   Pc s = M(i);
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                goto Write_unlink;
                            }
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, s, i ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf + sizeof( *in_buf ), s ))
                            {   W(s);
                                if( flags_1 & Z_inode_flags_1_S_persistent )
                                {   out_buf.error = -EPERM;
                                    goto Write_unlink;
                                }
                                rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                                if( rec_pos != Q_filesystem_S_table_of_files_offset )
                                {   if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                        goto Error;
                                    if( E_mem_Q_file_P_16( device_file_id, file_size_in_last_cluster | Z_inode_flags_1_S_empty ))
                                        goto Error;
                                }else
                                {   Q_filesystem_S_table_of_files_offset += device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size ) + i;
                                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 - 2 - device_n_size ))
                                        goto Error;
                                    if( E_mem_Q_file_P_N( device_file_id, Q_filesystem_S_table_of_files_offset / Q_filesystem_S_size_of_cluster, device_n_size ))
                                        goto Error;
                                    if( E_mem_Q_file_P_16( device_file_id, Q_filesystem_S_table_of_files_offset % Q_filesystem_S_size_of_cluster ))
                                        goto Error;
                                    N inode = FUSE_ROOT_ID;
                                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                                        goto Error;
                                    O{  if( device->pos == device->l )
                                            break;
                                        inode++;
                                        N rec_pos = device->pos;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        N file_size_in_last_cluster;
                                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                            goto Error;
                                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                                        {   N file_pos_in_the_only_cluster;
                                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                                goto Error;
                                            N file_pos_cluster;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                                goto Error;
                                            N file_size_clusters;
                                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                                goto Error;
                                        }
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        if( flags_1 & Z_inode_flags_1_S_empty )
                                            continue;
                                        if( parent_dir_inode != FUSE_ROOT_ID )
                                        {   N rec_pos_ = device->pos;
                                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                                goto Error;
                                            if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode - 1, device_n_size ))
                                                goto Error;
                                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos_ ))
                                                goto Error;
                                        }
                                    }
                                    Q_filesystem_S_inode_diff++;
                                }
                                for_each( id, file_handles, E_mem_Q_tab )
                                {   struct E_main_Z_file_handle *fh = E_mem_Q_tab_R( file_handles, id );
                                    if( fh->inode == nodeid )
                                    {   if( !~E_mem_Q_tab_I_remove( file_handles, id ))
                                            goto Error;
                                        break;
                                    }
                                }
                                break;
                            }
                            W(s);
                        }
                    }
Write_unlink:       ;struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    break;
                }
              case FUSE_WRITE:
                {   struct fuse_write_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->offset ); Gh( in_buf_2->size ); Gh( in_buf_2->flags ); Gh( in_buf_2->write_flags );
                    struct fuse_write_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    if( !E_mem_Q_tab_T( file_handles, in_buf_2->fh ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    out_buf_2.size = in_buf_2->size;
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    N nodeid = E_main_Q_filesystem_P_inode( file_handle->inode );
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    N inode = FUSE_ROOT_ID;
                    N16 flags_1;
                    N file_size_in_last_cluster;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    N rec_pos;
                    O{  inode++;
                        rec_pos = device->pos;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            if( !c )
                                break;
                        }
                        if( inode == nodeid )
                            break;
                    }
                    if( flags_1 & Z_inode_flags_1_S_persistent )
                    {   out_buf.error = -EPERM;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_write;
                    }
                    N l = in_buf->len - sizeof( *in_buf ) - sizeof( *in_buf_2 );
                    N file_pos = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
                    N file_size = file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster;
                    if( !l && in_buf_2->offset <= file_size )
                        goto Send_write;
                    N req_free_space = 0;
                    if( file_size
                    && in_buf_2->offset + l > file_size // Zapis poza końcem pliku, więc trzeba wyszukać wolny blok.
                    ){  struct E_main_Z_sort_free_blocks_range *free_blocks;
                        N free_blocks_n;
                        S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   out_buf.error = error;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        N free_blocks_i;
                        for_n_( free_blocks_i, free_blocks_n )
                            if( free_blocks[ free_blocks_i ].nodeid == inode )
                                break;
                        req_free_space = in_buf_2->offset + l - file_size;
                        if(( free_blocks_i + 1 != free_blocks_n && file_pos + file_size + req_free_space <= free_blocks[ free_blocks_i + 1 ].begin ) // Mieści się przed zawartością następnego pliku.
                        || ( free_blocks_i + 1 == free_blocks_n && file_pos + file_size + req_free_space <= Q_filesystem_S_table_of_files_offset ) // Mieści się przed listą opisów plików.
                        )
                        {   W( free_blocks );
                            if( in_buf_2->offset > file_size )
                            {   if( E_mem_Q_file_P_pos( device_file_id, file_pos + file_size ))
                                    goto Error;
                                E_mem_Q_file_P_c_n( device_file_id, 0, in_buf_2->offset - file_size );
                            }else
                                if( E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset ))
                                    goto Error;
                            if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                goto Error;
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size ))
                                goto Error;
                            file_size += req_free_space;
                            if( E_mem_Q_file_P_16( device_file_id, flags_1 | ( file_size % Q_filesystem_S_size_of_cluster )))
                                goto Error;
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 * 2 + device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, file_size / Q_filesystem_S_size_of_cluster, device_n_size ))
                                goto Error;
                            goto Send_write;
                        }
                        // Przeliczenie na ‘free blocks’.
                        N free_blocks_i_file = free_blocks_i;
                        free_blocks_i = free_blocks_n - 1;
                        if( free_blocks_i != free_blocks_i_file
                        && free_blocks[ free_blocks_i ].end != Q_filesystem_S_table_of_files_offset
                        )
                        {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n++;
                            free_blocks[ free_blocks_n - 1 ].end = Q_filesystem_S_table_of_files_offset;
                            free_blocks[ free_blocks_n - 1 ].begin = free_blocks[ free_blocks_i ].end;
                        }else if( free_blocks_i == free_blocks_i_file
                        && free_blocks_i
                        )
                        {   free_blocks[ free_blocks_i ].end = Q_filesystem_S_table_of_files_offset;
                            free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                            free_blocks_i--;
                        }
                        for( ; free_blocks_i; free_blocks_i-- )
                        {   if( free_blocks[ free_blocks_i - 1 ].end != free_blocks[ free_blocks_i ].begin )
                            {   if( free_blocks_i != free_blocks_i_file )
                                    free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i ].begin;
                                else
                                {   free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].end;
                                    if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i + 1, 1 ))
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                }
                                free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                            }else
                            {   if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks_n--;
                            }
                        }
                        if( free_blocks[0].begin )
                        {   free_blocks[0].end = free_blocks[0].begin;
                            free_blocks[0].begin = 0;
                        }else
                        {   if( !E_mem_Q_blk_I_remove( &free_blocks, 0, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n--;
                        }
                        error = E_main_Q_filesystem_I_allocate( device_file_id, &free_blocks, &free_blocks_n, in_buf_2->offset + l, &file_size_in_last_cluster, &file_pos_in_the_only_cluster, &file_pos_cluster, &file_size_clusters );
                        if( error == 1 )
                        {   W( free_blocks );
                            goto Error;
                        }
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        W( free_blocks );
                        N file_pos_new = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
                        if( in_buf_2->offset > file_size )
                        {   if( E_mem_Q_file_P_pos( device_file_id, file_pos_new + file_size ))
                                goto Error;
                            E_mem_Q_file_P_c_n( device_file_id, 0, in_buf_2->offset - file_size );
                        }
                        if( file_pos_new != file_pos )
                        {   error = E_main_Q_filesystem_I_move_data( device_file_id, file_pos_new, file_pos, file_size );
                            if( error == 1 )
                            {   W( free_blocks );
                                goto Error;
                            }
                            if(error)
                            {   W( free_blocks );
                                out_buf.error = error;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                        }
                        if( E_mem_Q_file_P_pos( device_file_id, file_pos_new + in_buf_2->offset ))
                            goto Error;
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, flags_1 | file_size_in_last_cluster ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                        {   W( free_blocks );
                            goto Error;
                        }
                    }else if( !file_size ) // Zapis do nowego bloku, więc trzeba go wyszukać.
                    {   struct E_main_Z_sort_free_blocks_range *free_blocks;
                        N free_blocks_n;
                        S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                        if( error == 1 )
                            goto Error;
                        if(error)
                        {   out_buf.error = error;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        // Przeliczenie na ‘free blocks’.
                        N free_blocks_i = free_blocks_n - 1;
                        if( free_blocks[ free_blocks_i ].end != Q_filesystem_S_table_of_files_offset )
                        {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n++;
                            free_blocks[ free_blocks_n - 1 ].end = Q_filesystem_S_table_of_files_offset;
                            free_blocks[ free_blocks_n - 1 ].begin = free_blocks[ free_blocks_i ].end;
                        }
                        for( ; free_blocks_i; free_blocks_i-- )
                        {   if( free_blocks[ free_blocks_i - 1 ].end != free_blocks[ free_blocks_i ].begin )
                            {   free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i ].begin;
                                free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                            }else
                            {   if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks_n--;
                            }
                        }
                        if( free_blocks[0].begin )
                        {   free_blocks[0].end = free_blocks[0].begin;
                            free_blocks[0].begin = 0;
                        }else
                        {   if( !E_mem_Q_blk_I_remove( &free_blocks, 0, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks_n--;
                        }
                        error = E_main_Q_filesystem_I_allocate( device_file_id, &free_blocks, &free_blocks_n, in_buf_2->offset + l, &file_size_in_last_cluster, &file_pos_in_the_only_cluster, &file_pos_cluster, &file_size_clusters );
                        if( error == 1 )
                        {   W( free_blocks );
                            goto Error;
                        }
                        if(error)
                        {   W( free_blocks );
                            out_buf.error = error;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_write;
                        }
                        W( free_blocks );
                        file_pos = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
                        if( in_buf_2->offset )
                        {   if( E_mem_Q_file_P_pos( device_file_id, file_pos ))
                                goto Error;
                            E_mem_Q_file_P_c_n( device_file_id, 0, in_buf_2->offset );
                        }else
                            if( E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset ))
                                goto Error;
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, flags_1 | file_size_in_last_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                            goto Error;
                    }else
                    {   if( E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset ))
                            goto Error;
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                    }
/*
                        N free_blocks_i_nodeid = free_blocks_i;
                        if( free_blocks_i != free_blocks_n )
                            for( free_blocks_i++; free_blocks_i != free_blocks_n; free_blocks_i++ )
                            {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                                req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                            }
                        if( free_blocks_i == free_blocks_n )
                        {   struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( req_free_space > file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   N req_free_space = in_buf_2->offset + l - file_size;
                                for( N free_blocks_i = free_blocks_i_nodeid + 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                req_free_space -= file->l - free_blocks[ free_blocks_n - 1 ].end;
                                for( free_blocks_i = free_blocks_i_nodeid; free_blocks_i; free_blocks_i-- )
                                {   if( req_free_space <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                        break;
                                    req_free_space -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                }
                                if( !free_blocks_i )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                	if( req_free_space > free_blocks[0].begin - table_end )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOSPC;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                }
                                N free_blocks_i_start = free_blocks_i;
                                Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                                if( free_blocks_n > 1 )
                                    for( N free_blocks_i = free_blocks_n - 2; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                                    {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                        if( !buf )
                                        {   W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        {   W(buf);
                                            W( free_blocks );
                                            out_buf.error = -ENOMEM;
                                            struct iovec bufs[] =
                                            { { &out_buf, sizeof( out_buf ) }
                                            };
                                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                                goto Error;
                                            goto End_write;
                                        }
                                        free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                                        free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                                        E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                        if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                            goto Error;
                                        W(buf);
                                        N nodeid = FUSE_ROOT_ID + 1;
                                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                        O{  N rec_pos = device->pos;
                                            if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                            {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                    goto Error;
                                                break;
                                            }
                                            E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                            O{  C c;
                                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                    goto Error;
                                                if( !c )
                                                    break;
                                            }
                                            nodeid++;
                                        }
                                    }
                                for( N free_blocks_i = free_blocks_i_start; free_blocks_i != free_blocks_i_nodeid + 1; free_blocks_i++ )
                                {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[ free_blocks_i ].end -= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end;
                                    free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                if( !free_blocks_i_start )
                                {   E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N file_pos;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                            goto Error;
                                        if( !file_pos )
                                            break;
                                        N file_size;
                                        if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                            goto Error;
                                        N parent_dir_inode;
                                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                            goto Error;
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                    }
                                    N table_end = device->pos;
                                    Pc buf = M( free_blocks[0].begin - table_end );
                                    if( !buf )
                                    {   W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                    {   W(buf);
                                        W( free_blocks );
                                        out_buf.error = -ENOMEM;
                                        struct iovec bufs[] =
                                        { { &out_buf, sizeof( out_buf ) }
                                        };
                                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                            goto Error;
                                        goto End_write;
                                    }
                                    free_blocks[0].end -= free_blocks[0].begin - table_end;
                                    free_blocks[0].begin = table_end;
                                    E_mem_Q_file_P_pos( device_file_id, free_blocks[0].begin );
                                    if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[0].end - free_blocks[0].begin ))
                                        goto Error;
                                    W(buf);
                                    N nodeid = FUSE_ROOT_ID + 1;
                                    E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                    O{  N rec_pos = device->pos;
                                        if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                        {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                                goto Error;
                                            break;
                                        }
                                        E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                        O{  C c;
                                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                                goto Error;
                                            if( !c )
                                                break;
                                        }
                                        nodeid++;
                                    }
                                }
                                W( free_blocks );
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                goto Write_write;
                            }
                            free_blocks_i--;
                            if( free_blocks_i != free_blocks_i_nodeid )
                            {   Pc buf = M( free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin );
                                if( !buf )
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                {   W(buf);
                                    W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n - 1 ].begin += file->l - free_blocks[ free_blocks_n - 1 ].end;
                                free_blocks[ free_blocks_n - 1 ].end = file->l;
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].begin );
                                if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_n - 1 ].end - free_blocks[ free_blocks_n - 1 ].begin ))
                                    goto Error;
                                W(buf);
                                N nodeid = FUSE_ROOT_ID + 1;
                                E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                                O{  N rec_pos = device->pos;
                                    if( nodeid == free_blocks[ free_blocks_n - 1 ].nodeid )
                                    {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].begin, device_n_size ))
                                            goto Error;
                                        break;
                                    }
                                    E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                    O{  C c;
                                        if( E_mem_Q_file_R_c( device_file_id, &c ))
                                            goto Error;
                                        if( !c )
                                            break;
                                    }
                                    nodeid++;
                                }
                            }
                        }
                        for( ; free_blocks_i != free_blocks_i_nodeid; free_blocks_i-- )
                        {   Pc buf = M( free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin );
                            if( !buf )
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_R_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                            {   W(buf);
                                W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            free_blocks[ free_blocks_i ].begin += free_blocks[ free_blocks_i + 1 ].begin - free_blocks[ free_blocks_i ].end;
                            free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i + 1 ].begin;
                            E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i ].begin );
                            if( E_mem_Q_file_P_s( device_file_id, buf, free_blocks[ free_blocks_i ].end - free_blocks[ free_blocks_i ].begin ))
                                goto Error;
                            W(buf);
                            N nodeid = FUSE_ROOT_ID + 1;
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N rec_pos = device->pos;
                                if( nodeid == free_blocks[ free_blocks_i ].nodeid )
                                {   if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i ].begin, device_n_size ))
                                        goto Error;
                                    break;
                                }
                                E_mem_Q_file_P_pos( device_file_id, rec_pos + 3 * device_n_size );
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                                nodeid++;
                            }
                        }
                        W( free_blocks );
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, file_pos + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        goto Write_write;
                    }
                    if( !file_size )
                    {   struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                        if( !free_blocks )
                        {   out_buf.error = -ENOMEM;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_create;
                        }
                        N free_blocks_n = 0;
                        N nodeid = FUSE_ROOT_ID + 1;
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                            if( file_pos != file_pos_S_directory
                            && file_size
                            ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                                {   W( free_blocks );
                                    out_buf.error = -ENOMEM;
                                    struct iovec bufs[] =
                                    { { &out_buf, sizeof( out_buf ) }
                                    };
                                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                        goto Error;
                                    goto End_write;
                                }
                                free_blocks[ free_blocks_n ].nodeid = nodeid;
                                free_blocks[ free_blocks_n ].begin = file_pos;
                                free_blocks[ free_blocks_n ].end = file_pos + file_size;
                                free_blocks_n++;
                            }
                            nodeid++;
                        }
                        if( free_blocks_n )
                        {   qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                            N free_blocks_i;
                            for( free_blocks_i = 1; free_blocks_i != free_blocks_n; free_blocks_i++ )
                                if( l <= free_blocks[ free_blocks_i ].begin - free_blocks[ free_blocks_i - 1 ].end )
                                    break;
                            if( free_blocks_i != free_blocks_n )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_i - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_i - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            struct E_mem_Q_file_Z *file = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                            if( l <= file->l - free_blocks[ free_blocks_n - 1 ].end )
                            {   if( in_buf_2->offset > file_size )
                                {   E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + file_size );
                                    for( N i = file_size; i != in_buf_2->offset; i++ )
                                        if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                            goto Error;
                                }
                                E_mem_Q_file_P_pos( device_file_id, free_blocks[ free_blocks_n - 1 ].end + in_buf_2->offset );
                                if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                    goto Error;
                                E_mem_Q_file_P_pos( device_file_id, rec_pos );
                                if( E_mem_Q_file_P_N( device_file_id, free_blocks[ free_blocks_n - 1 ].end, device_n_size ))
                                    goto Error;
                                W( free_blocks );
                                goto Write_write;
                            }
                            E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                            O{  N file_pos;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                    goto Error;
                                if( !file_pos )
                                    break;
                                N file_size;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                    goto Error;
                                N parent_dir_inode;
                                if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                    goto Error;
                                O{  C c;
                                    if( E_mem_Q_file_R_c( device_file_id, &c ))
                                        goto Error;
                                    if( !c )
                                        break;
                                }
                            }
                            N table_end = device->pos;
                            if( l > free_blocks[0].begin - table_end )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_write;
                            }
                            W( free_blocks );
                            if( in_buf_2->offset > file_size )
                                for( N i = file_size; i != in_buf_2->offset; i++ )
                                    if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                        goto Error;
                            E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                            if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                                goto Error;
                            E_mem_Q_file_P_pos( device_file_id, rec_pos );
                            if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                                goto Error;
                            goto Write_write;
                        }
                        E_mem_Q_file_P_pos( device_file_id, S_inode_table_offset );
                        O{  N file_pos;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
                                goto Error;
                            if( !file_pos )
                                break;
                            N file_size;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size, device_n_size ))
                                goto Error;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        W( free_blocks );
                        N table_end = device->pos;
                        if( in_buf_2->offset > file_size )
                        {   E_mem_Q_file_P_pos( device_file_id, table_end + file_size );
                            for( N i = file_size; i != in_buf_2->offset; i++ )
                                if( E_mem_Q_file_P_c( device_file_id, 0 ))
                                    goto Error;
                        }
                        E_mem_Q_file_P_pos( device_file_id, table_end + in_buf_2->offset );
                        if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                            goto Error;
                        E_mem_Q_file_P_pos( device_file_id, rec_pos );
                        if( E_mem_Q_file_P_N( device_file_id, table_end, device_n_size ))
                            goto Error;
                        goto Write_write;
                    }
                    E_mem_Q_file_P_pos( device_file_id, file_pos + in_buf_2->offset );
                    if( E_mem_Q_file_P_s( device_file_id, (Pc)in_buf_2 + sizeof( *in_buf_2 ), l ))
                        goto Error;
Write_write:        if( in_buf_2->offset + l > file_size )
                    {   E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size );
                        if( E_mem_Q_file_P_N( device_file_id, in_buf_2->offset + l, device_n_size ))
                            goto Error;
                    }
*/
Send_write:         out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_write:          in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_SYMLINK:
                {   read_count -= in_buf->len - sizeof( *in_buf );
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_LINK:
                {   struct fuse_link_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_STATFS:
                {   struct fuse_statfs_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    struct E_main_Z_sort_free_blocks_range *Mt_( free_blocks, 0 );
                    if( !free_blocks )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        goto End_statfs;
                    }
                    N free_blocks_n = 0;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    O{  if( device->pos == device->l )
                            break;
                        N parent_dir_inode;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        N file_size_in_last_cluster;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                        {   W( free_blocks );
                            goto Error;
                        }
                        N16 flags_1 = file_size_in_last_cluster & 0xf000;
                        N file_pos_in_the_only_cluster;
                        N file_pos_cluster;
                        N file_size_clusters;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   file_size_in_last_cluster &= 0xfff;
                            if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                            {   W( free_blocks );
                                goto Error;
                            }
                        }
                        N i = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                            {   W( free_blocks );
                                goto Error;
                            }
                            i++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        out_buf_2.st.files++;
                        if( !( flags_1 & Z_inode_flags_1_S_directory )
                        && file_size_clusters * Q_filesystem_S_size_of_cluster + file_size_in_last_cluster
                        ){  if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_statfs;
                            }
                            free_blocks[ free_blocks_n ].begin = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster;
                            free_blocks[ free_blocks_n ].end = file_pos_cluster * Q_filesystem_S_size_of_cluster + file_size_clusters * Q_filesystem_S_size_of_cluster + file_pos_in_the_only_cluster + file_size_in_last_cluster; // “file_size_clusters” albo “file_pos_in_the_only_cluster” jest 0.
                            free_blocks_n++;
                        }
                    }
                    qsort( &free_blocks[0], free_blocks_n, sizeof( free_blocks[0] ), &E_main_I_sort_free_blocks_cmp );
                    // Przeliczenie na ‘free blocks’.
                    N free_blocks_i = free_blocks_n - 1;
                    if( free_blocks[ free_blocks_i ].end != Q_filesystem_S_table_of_files_offset )
                    {   if( !E_mem_Q_blk_I_append( &free_blocks, 1 ))
                        {   W( free_blocks );
                            out_buf.error = -ENOMEM;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_statfs;
                        }
                        free_blocks_n++;
                        free_blocks[ free_blocks_n - 1 ].end = Q_filesystem_S_table_of_files_offset;
                        free_blocks[ free_blocks_n - 1 ].begin = free_blocks[ free_blocks_i ].end;
                    }
                    for( ; free_blocks_i; free_blocks_i-- )
                    {   if( free_blocks[ free_blocks_i - 1 ].end != free_blocks[ free_blocks_i ].begin )
                        {   free_blocks[ free_blocks_i ].end = free_blocks[ free_blocks_i ].begin;
                            free_blocks[ free_blocks_i ].begin = free_blocks[ free_blocks_i - 1 ].end;
                        }else
                        {   if( !E_mem_Q_blk_I_remove( &free_blocks, free_blocks_i, 1 ))
                            {   W( free_blocks );
                                out_buf.error = -ENOMEM;
                                struct iovec bufs[] =
                                { { &out_buf, sizeof( out_buf ) }
                                };
                                VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                    goto Error;
                                goto End_statfs;
                            }
                            free_blocks_n--;
                        }
                    }
                    if( free_blocks[0].begin )
                    {   free_blocks[0].end = free_blocks[0].begin;
                        free_blocks[0].begin = 0;
                    }else
                    {   if( !E_mem_Q_blk_I_remove( &free_blocks, 0, 1 ))
                        {   W( free_blocks );
                            out_buf.error = -ENOMEM;
                            struct iovec bufs[] =
                            { { &out_buf, sizeof( out_buf ) }
                            };
                            VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                                goto Error;
                            goto End_statfs;
                        }
                        free_blocks_n--;
                    }
                    for_n_( free_blocks_i, free_blocks_n )
                    {   N begin = E_simple_Z_n_I_align_up_to_v2( free_blocks[ free_blocks_i ].begin, Q_filesystem_S_size_of_cluster );
                        N end = E_simple_Z_n_I_align_down_to_v2( free_blocks[ free_blocks_i ].end, Q_filesystem_S_size_of_cluster );
                        if( begin < end )
                            out_buf_2.st.bfree += ( end - begin ) / Q_filesystem_S_size_of_cluster;
                    }
                    W( free_blocks );
                    out_buf_2.st.bavail = out_buf_2.st.bfree;
                    out_buf_2.st.blocks = Q_filesystem_S_table_of_files_offset / Q_filesystem_S_size_of_cluster;
                    out_buf_2.st.ffree = ~0;
                    out_buf_2.st.bsize = Q_filesystem_S_size_of_cluster;
                    out_buf_2.st.namelen = J_min( (N32)~0, device->l );
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
End_statfs:         in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_MKNOD:
                {   struct fuse_mknod_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME:
                {   struct fuse_rename_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_RENAME2:
                {   struct fuse_rename2_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    if( in_buf->len - ( sizeof( *in_buf ) + sizeof( *in_buf_2 )) < 4 )
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gh( in_buf_2->flags );
                    N16 flags_1;
                    struct E_mem_Q_file_Z *device = E_mem_Q_tab_R( E_base_S->E_mem_Q_file_S, device_file_id );
                    if( in_buf_2->newdir != FUSE_ROOT_ID )
                    {   N inode = FUSE_ROOT_ID;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                            goto Error;
                        O{  if( device->pos == device->l )
                                break;
                            inode++;
                            N parent_dir_inode;
                            if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                                goto Error;
                            N file_size_in_last_cluster;
                            if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                                goto Error;
                            flags_1 = file_size_in_last_cluster & 0xf000;
                            if( !( flags_1 & Z_inode_flags_1_S_directory ))
                            {   N file_pos_in_the_only_cluster;
                                if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                    goto Error;
                                N file_pos_cluster;
                                if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                    goto Error;
                                N file_size_clusters;
                                if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                    goto Error;
                            }
                            O{  C c;
                                if( E_mem_Q_file_R_c( device_file_id, &c ))
                                    goto Error;
                                if( !c )
                                    break;
                            }
                        }
                        if( inode != in_buf_2->newdir
                        || flags_1 & Z_inode_flags_1_S_empty
                        )
                        {   out_buf.error = -ENOENT;
                            goto Write_rename2;
                        }
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   out_buf.error = -ENOTDIR;
                            goto Write_rename2;
                        }
                    }
                    N nodeid = E_main_Q_filesystem_P_inode( in_buf->nodeid );
                    N inode = FUSE_ROOT_ID;
                    N parent_dir_inode;
                    N file_size_in_last_cluster;
                    N file_pos_in_the_only_cluster;
                    N file_pos_cluster;
                    N file_size_clusters;
                    N i_old;
                    N rec_pos;
                    if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                        goto Error;
                    O{  if( device->pos == device->l )
                            break;
                        inode++;
                        if( E_mem_Q_file_R_N( device_file_id, &parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_R_16( device_file_id, &file_size_in_last_cluster ))
                            goto Error;
                        flags_1 = file_size_in_last_cluster & 0xf000;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   if( E_mem_Q_file_R_16( device_file_id, &file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_R_N( device_file_id, &file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        rec_pos = device->pos;
                        i_old = 0;
                        O{  C c;
                            if( E_mem_Q_file_R_c( device_file_id, &c ))
                                goto Error;
                            i_old++;
                            if( !c )
                                break;
                        }
                        if( flags_1 & Z_inode_flags_1_S_empty )
                            continue;
                        if( parent_dir_inode == nodeid )
                        {   Pc s = M( i_old );
                            if( !s )
                            {   out_buf.error = -ENOMEM;
                                goto Write_rename2;
                            }
                            if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                goto Error;
                            if( E_mem_Q_file_R_s( device_file_id, s, i_old ))
                                goto Error;
                            if( E_text_Z_s0_T_s0_eq( (Pc)in_buf_2 + sizeof( *in_buf_2 ), s ))
                            {   W(s);
                                break;
                            }
                            W(s);
                        }
                    }
                    if( device->pos == device->l )
                    {   out_buf.error = -ENOENT;
                        goto Write_rename2;
                    }
                    if( flags_1 & Z_inode_flags_1_S_persistent )
                    {   out_buf.error = -EPERM;
                        goto Write_rename2;
                    }
                    Pc s = E_text_Z_s0_R_0_end( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    N i = E_text_Z_s0_R_0_l(s);
                    if( i != i_old )
                    {   N free_space;
                        if( i > i_old )
                        {   free_space = i - i_old;
                            struct E_main_Z_sort_free_blocks_range *free_blocks;
                            N free_blocks_n;
                            S32 error = E_main_Q_filesystem_R_allocated_blocks( device_file_id, &free_blocks, &free_blocks_n );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   out_buf.error = error;
                                goto Write_rename2;
                            }
                            if( Q_filesystem_S_table_of_files_offset < free_space )
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                goto Write_rename2;
                            }
                            if( free_blocks_n
                            && Q_filesystem_S_table_of_files_offset - free_space < free_blocks[ free_blocks_n - 1 ].end
                            ) // TODO Scalenie plików od ostatniego zamiast błędu.
                            {   W( free_blocks );
                                out_buf.error = -ENOSPC;
                                goto Write_rename2;
                            }
                            W( free_blocks );
                        }else
                            free_space = i_old - i;
                        rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                        if( rec_pos != Q_filesystem_S_table_of_files_offset )
                        {   N dst;
                            if( i > i_old )
                                dst = Q_filesystem_S_table_of_files_offset - free_space;
                            else
                                dst = Q_filesystem_S_table_of_files_offset + free_space;
                            S32 error = E_main_Q_filesystem_I_move_data( device_file_id, dst, Q_filesystem_S_table_of_files_offset, rec_pos - Q_filesystem_S_table_of_files_offset );
                            if( error == 1 )
                                goto Error;
                            if(error)
                            {   out_buf.error = error;
                                goto Write_rename2;
                            }
                            Q_filesystem_S_table_of_files_offset = dst;
                        }else
                        {   if( i > i_old )
                                Q_filesystem_S_table_of_files_offset -= free_space;
                            else
                                Q_filesystem_S_table_of_files_offset += free_space;
                            if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_table_of_files_offset ))
                                goto Error;
                        }
                        if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, file_size_in_last_cluster ))
                            goto Error;
                        if( !( flags_1 & Z_inode_flags_1_S_directory ))
                        {   if( E_mem_Q_file_P_16( device_file_id, file_pos_in_the_only_cluster ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, file_pos_cluster, device_n_size ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, file_size_clusters, device_n_size ))
                                goto Error;
                        }
                        if( E_mem_Q_file_P_s( device_file_id, s, i ))
                            goto Error;
                        if( E_mem_Q_file_P_pos( device_file_id, Q_filesystem_S_top_of_boot_record_data - 1 - 2 - device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_N( device_file_id, Q_filesystem_S_table_of_files_offset / Q_filesystem_S_size_of_cluster, device_n_size ))
                            goto Error;
                        if( E_mem_Q_file_P_16( device_file_id, Q_filesystem_S_table_of_files_offset % Q_filesystem_S_size_of_cluster ))
                            goto Error;
                    }else
                    {   rec_pos -= device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size );
                        if( parent_dir_inode != in_buf_2->newdir )
                        {   if( E_mem_Q_file_P_pos( device_file_id, rec_pos ))
                                goto Error;
                            if( E_mem_Q_file_P_N( device_file_id, parent_dir_inode, device_n_size ))
                                goto Error;
                        }
                        if( E_mem_Q_file_P_pos( device_file_id, rec_pos + device_n_size + 2 + ( flags_1 & Z_inode_flags_1_S_directory ? 0 : 2 + 2 * device_n_size )))
                            goto Error;
                        if( E_mem_Q_file_P_s( device_file_id, s, i ))
                            goto Error;
                    }
Write_rename2:      ;struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_IOCTL:
                {   struct fuse_ioctl_in *in_buf_2;
                    if( read_count < sizeof( *in_buf_2 ))
                        goto Error;
                    read_count -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)( (Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)( (Pc)in_buf + in_buf->len );
                    break;
                }
            }
            G_(); Gd( read_count );
            if( !read_count )
                break;
        }
    }
End:E_mem_Q_tab_W( file_handles );
    W(read_buffer);
    VO1( close( fuse_fd )){}
    if( E_mem_Q_file_W( device_file_id ))
    {   E_base_W();
        return 1;
    }
    E_base_W();
    return 0;
Error:
    E_mem_Q_tab_W( file_handles );
    W( read_buffer );
    VO1( close( fuse_fd )){}
    E_mem_Q_file_W( device_file_id );
    E_base_W();
    return 1;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
