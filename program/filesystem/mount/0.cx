/*******************************************************************************
*   ___   [obszar]
*  ¦OUX¦  [system programowania]
*  ¦Inc¦  [rodzaj składnika]
*   ---   [nazwa składnika]
*         [tytuł elementu]
* ©overcq                on ‟Gentoo Linux 17.0” “x86_64”             2019‒3‒10 b
*******************************************************************************/
#include <linux/fuse.h>
//==============================================================================
Pc device;
Pc directory;
I device_file_id;
C device_n_size;
int fuse_fd;
N fuse_major;
N fuse_minor;
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct E_main_Z_file_handle
{ N64 inode;
};
struct E_mem_Q_tab_Z *file_handles;
//==============================================================================
int
main(
  int argc
, char *argv[]
){  E_base_M( argc, argv );
    device = 0;
    for( int i = 1; i != argc; i++ )
    {   if( *argv[i] == '-' )
        {   E_base_W();
            return 1;
        }
        if(directory)
        {   E_base_W();
            return 1;
        }
        if(device)
            directory = argv[i];
        else
            device = argv[i];
    }

    if( !device )
    {   E_base_W();
        return 1;
    }
    if( !~( device_file_id = E_mem_Q_file_M(device) ))
    {   E_base_W();
        return 1;
    }
    E_mem_Q_file_P_pos( device_file_id, 3 );
    C s[3];
    if( E_mem_Q_file_R_s( device_file_id, &s[0], 3 )
    || !E_text_Z_s_T_eq( &s[0], &s[0] + 3, "OUX" )
    ){  E_base_W();
        return 1;
    }
    if( E_mem_Q_file_R_c( device_file_id, &device_n_size )
    || ( device_n_size != 2
      && device_n_size != 4
      && device_n_size != 8
      )
    ){  E_base_W();
        return 1;
    }
    VO1( fuse_fd = open( "/dev/fuse", O_RDWR ))
    {   E_base_W();
        return 1;
    }
    cap_t cap;
    Vp( cap = cap_get_proc() )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    cap_value_t cap_list[1] = { CAP_SYS_ADMIN };
    V1( cap_set_flag( cap, CAP_EFFECTIVE, 1, &cap_list[0], CAP_CLEAR ))
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    Pc s_2 = M(128);
    snprintf( s_2, 128, "fd=%i,rootmode=%o,user_id=%u,group_id=%u,blksize=4096", fuse_fd, 040000, getuid(), getgid() );
    V1( mount( device, directory, "fuseblk", 0, s_2 ))
    {   V1( cap_set_proc(cap) ){}
        V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    W( s_2 );
    V1( cap_set_proc(cap) )
    {   V1( cap_free(cap) ){}
        VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    V1( cap_free(cap) )
    {   VO1( close( fuse_fd )){}
        E_base_W();
        return 1;
    }
    N buffer_size, buffer_read;
    P buffer = M( buffer_size = 4096 );
    file_handles = E_mem_Q_tab_M( sizeof( struct E_main_Z_file_handle ), 0 );
    O{  VO1( buffer_read = read( fuse_fd, buffer, buffer_size )){}
        struct fuse_in_header *in_buf = buffer;
        O{  if( buffer_read < sizeof( *in_buf ))
                goto Error;
            buffer_read -= sizeof( *in_buf );
            struct fuse_out_header out_buf;
            out_buf.len = sizeof( out_buf );
            out_buf.error = 0;
            out_buf.unique = in_buf->unique;
            G_(); Gd( in_buf->opcode );
            switch( in_buf->opcode )
            { case FUSE_INIT:
                {   struct fuse_init_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    G_(); Gd( in_buf_2->major ); Gd( in_buf_2->minor );
                    if( in_buf_2->major > 7 )
                    {   fuse_major = 7;
                        fuse_minor = 0;
                    }else
                    {   fuse_major = in_buf_2->major;
                        if( in_buf_2->major == 7 )
                            fuse_minor = in_buf_2->major > 26 ? 26 : in_buf_2->minor;
                        else
                            fuse_minor = in_buf_2->minor;
                    }
                    G_(); Gd( fuse_major ); Gd( fuse_minor );
                    struct fuse_init_out out_buf_2;
                    out_buf.len += sizeof( out_buf_2 );
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.major = fuse_major;
                    out_buf_2.minor = fuse_minor;
                    if( fuse_major > 7
                    || ( fuse_major == 7 && fuse_minor >= 5
                    ))
                        out_buf_2.max_write = in_buf_2->max_readahead;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_DESTROY:
                    break;
              case FUSE_FORGET:
                    goto End;
              case FUSE_GETATTR:
                {   struct fuse_getattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    struct fuse_attr_out out_buf_2;
                    out_buf.len += sizeof( out_buf_2 );
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.attr_valid = 1;
                    if( in_buf_2->getattr_flags & FUSE_GETATTR_FH )
                    {   G_();
                    }else
                    {   out_buf_2.attr.ino = in_buf->nodeid;
                    }
                    out_buf_2.attr.mode = 040777;
                    out_buf_2.attr.size = 4096;
                    out_buf_2.attr.blocks = 8;
                    out_buf_2.attr.nlink = 1;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_GETXATTR:
                {   struct fuse_getxattr_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= in_buf->len - sizeof( *in_buf );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    out_buf.error = -ENOSYS;
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)((Pc)in_buf + in_buf->len );
                    break;
                }
              case FUSE_OPEN:
              case FUSE_OPENDIR:
                {   struct fuse_open_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    struct fuse_open_out out_buf_2;
                    E_mem_Q_blk_P_fill_c( &out_buf_2, sizeof( out_buf_2 ), 0 );
                    out_buf_2.fh = E_mem_Q_tab_I_add( file_handles );
                    if( !~out_buf_2.fh )
                    {   out_buf.error = -ENOMEM;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    out_buf.len += sizeof( out_buf_2 );
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, sizeof( out_buf_2 ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_READ:
              case FUSE_READDIR:
                {   struct fuse_read_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf_2->fh >= E_mem_Q_tab_R_n( file_handles ))
                    {   out_buf.error = -ENOENT;
                        struct iovec bufs[1] =
                        { { &out_buf, sizeof( out_buf ) }
                        };
                        VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                            goto Error;
                        in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                        break;
                    }
                    struct E_main_Z_file_handle *file_handle = E_mem_Q_tab_R( file_handles, in_buf_2->fh );
                    
                    N len = 0;
                    P out_buf_2 = M(len);
                    out_buf.len += len;
                    struct iovec bufs[2] =
                    { { &out_buf, sizeof( out_buf ) }
                    , { &out_buf_2, len }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    W( out_buf_2 );
                    in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              case FUSE_RELEASE:
              case FUSE_RELEASEDIR:
                {   struct fuse_release_in *in_buf_2;
                    if( buffer_read < sizeof( *in_buf_2 ))
                        goto Error;
                    buffer_read -= sizeof( *in_buf_2 );
                    in_buf_2 = (P)((Pc)in_buf + sizeof( *in_buf ));
                    if( in_buf_2->fh >= E_mem_Q_tab_R_n( file_handles ))
                        out_buf.error = -ENOENT;
                    else
                        E_mem_Q_tab_I_rem( file_handles, in_buf_2->fh );
                    struct iovec bufs[1] =
                    { { &out_buf, sizeof( out_buf ) }
                    };
                    VO1( writev( fuse_fd, &bufs[0], sizeof(bufs) / sizeof( bufs[0] )))
                        goto Error;
                    in_buf = (P)((Pc)in_buf_2 + sizeof( *in_buf_2 ));
                    break;
                }
              default:
                    break;
            }
            G_(); Gd( buffer_read );
            if( !buffer_read )
                break;
        }
    }
End:        
   
    //N file_pos;
    //if( E_mem_Q_file_R_N( device_file_id, &file_pos, device_n_size ))
    //{   VO1( close( fuse_fd )){}
        //E_mem_Q_file_W( device_file_id );
        //E_base_W();
        //return 1;
    //}
    
    E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    if( E_mem_Q_file_W( device_file_id ))
    {   E_base_W();
        return 1;
    }
    E_base_W();
    return 0;
Error:
    E_mem_Q_tab_W( file_handles );
    W(buffer);
    VO1( close( fuse_fd )){}
    E_mem_Q_file_W( device_file_id );
    E_base_W();
    return 1;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
