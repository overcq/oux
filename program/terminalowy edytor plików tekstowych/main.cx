/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  aplikacje terminalowe
*   ---   podstawowy edytor tekstu
*         entry and raw labels
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒7‒25 *
*******************************************************************************/
int E_main_I_getch_S_ret;
wint_t E_main_I_getch_S_c;
I E_main_S_file;
//==============================================================================
N
E_main_Q_file_R_c( void
){  return E_mem_Q_file_R_c(E_main_S_file);
}
int
main(
  int argc
, Pc *argv
){  if( argc != 2 )
        V();
    E_flow_M( argc, argv );
    initscr();
    start_color();
    init_pair( 1, COLOR_WHITE, COLOR_BLACK );
    attr_set( A_NORMAL, 1, 0 );
    noecho();
    cbreak();
    nonl();
    intrflush( stdscr, FALSE );
    idlok( stdscr, TRUE );
    idcok( stdscr, TRUE );
    scrollok( stdscr, TRUE );
    leaveok( stdscr, FALSE );
    immedok( stdscr, FALSE );
    keypad( stdscr, TRUE );
    notimeout( stdscr, TRUE );
    nodelay( stdscr, FALSE );
    E_lines_M();
    if( !~( E_main_S_file = E_mem_Q_file_M( argv[1] )))
    {   endwin(); G_(); V();
    }
    int y = 0, x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    N u_i = 0;
    O{  U u = E_text_Z_getter_Z_c_R_u( &E_main_Q_file_R_c );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (S32)u == E_mem_Q_file_S_eof )
            break;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if( u == '\n' )
        {   E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].l = u_i + 1 - E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].start;
            E_lines_Q_lines_I_append();
            E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ] = ( struct E_lines_Q_lines_Z ){ u_i + 1, ~0 };
            if( y == y_ - 1 )
                break;
            y++;
            x = 0;
            goto Cont;
        }
        move( y, x );
        cchar_t cc;
        wchar_t s[2] = { u, '\0' };
        setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        if( x == x_ - 1 )
        {   E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].l = u_i + 1 - E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].start;
            E_lines_Q_lines_I_append();
            E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ] = ( struct E_lines_Q_lines_Z ){ u_i + 1, ~0 };
            if( y == y_ - 1 )
                break;
            y++;
            x = 0;
        }else
            x++;
Cont:   u_i++;
    }
    D_M( main, getch );
    X_M( main, none );
    X_B( main, none, 0 ){}
    X_W( main, none );
    D_W( main, getch );
    E_lines_W();
    endwin();
    E_flow_W();
    return 0;
}
bool
E_main_I_sigsuspend( sigset_t *sigset
){  sigset_t old_sigset;
    _sigprocmask( SIG_SETMASK, sigset, &old_sigset ); //NDFN dopóki jest tak zrobione, że odblokowanie “sygnałów” jest wcześniej niż zablokowanie na “read”, to mogą występować przypadki zablokowania oczekującego na “read” mimo “sygnału” (ustawiającego “wake”) obsłużonego i danych czekających na przetworzenie w ‹zadaniach›, a gdy nie jest ustawione “E_flow_Q_system_unblock_report_S_setitimer_I”, to oczywiście– nieodblokowania po ustawionym czasie —do czasu ‹systemowego raportu odblokowującego› lub nietrafienia któregoś interpretowanego (ustawiającego “wake”) “sygnału” w obszar programu pomiędzy tym “sigprocmask” a “read” w “E_flow_Q_system_unblock_report_S_sigsuspend_I”.
    E_main_I_getch_S_ret = get_wch( &E_main_I_getch_S_c );
    _sigprocmask( SIG_SETMASK, &old_sigset, 0 );
    return E_main_I_getch_S_ret != ERR; ///naciśnięto klawisz.
}
void
E_main_I_setitimer( Z_clock_time *tv
){
#ifndef E_flow_drv_C_clock_monotonic
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999 ) / 1000 );
#else
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999999 ) / 1000000 );
#endif
}
D( main, getch )
{   Xh1_M( &E_main_I_sigsuspend, &E_main_I_setitimer );
    I_D
    {   Xh1_B()
        {   E_mem_Q_file_W(E_main_S_file);
            break;
        }
        switch( E_main_I_getch_S_ret )
        { case KEY_CODE_YES:
                switch( E_main_I_getch_S_c )
                { case KEY_DC:
                        delch();
                        break;
                  case KEY_BACKSPACE:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                        {   move( y, x - 1 );
                            delch();
                        }else
                        {   int y_, x_;
                            getmaxyx( stdscr, y_, x_ );
                            if(y)
                                move( y - 1, x_ - 1 );
                            else
                                if( E_main_Q_file_I_paint_first_line() )
                                    move( y, x_ - 1 );
                        }
                        break;
                    }
                  case 343: ///‛Enter’ na klawiaturze numerycznej.
                        E_main_I_getch_S_c = '\r';
                        goto Enter;
                  case KEY_RIGHT:
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( x < x_ - 1 )
                            move( y, x + 1 );
                        else
                        {   if( y < y_ - 1 )
                                move( y + 1, 0 );
                            else
                                if( E_main_Q_file_I_paint_last_line() )
                                    move( y, 0 );
                        }
                        break;
                    }
                  case KEY_LEFT:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                            move( y, x - 1 );
                        else
                        {   int y_, x_;
                            getmaxyx( stdscr, y_, x_ );
                            if(y)
                                move( y - 1, x_ - 1 );
                            else
                                if( E_main_Q_file_I_paint_first_line() )
                                    move( y, x_ - 1 );
                        }
                        break;
                    }
                  case KEY_DOWN:
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( y < y_ - 1 )
                            move( y + 1, x );
                        else
                            E_main_Q_file_I_paint_last_line();
                        break;
                    }
                  case KEY_UP:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( y > 0 )
                            move( y - 1, x );
                        else
                            E_main_Q_file_I_paint_first_line();
                        break;
                    }
                  case KEY_HOME:
                  case 348: //na klawiaturze numerycznej.
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                            move( y, 0 );
                        break;
                    }
                  case KEY_END:
                  case 351: //na klawiaturze numerycznej.
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( x < x_ - 1 )
                            move( y, x_ - 1 );
                        break;
                    }
                  case KEY_NPAGE:
                  case 352: //na klawiaturze numerycznej.
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( y < y_ - 1 )
                            move( y_ - 1, x );
                        else
                        {   N l = E_main_Q_file_I_paint_prev_window();
                            if(l)
                                scrl(l);
                        }
                        break;
                    }
                  case KEY_PPAGE:
                  case 349: //na klawiaturze numerycznej.
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( y > 0 )
                            move( 0, x );
                        else
                        {   N l = E_main_Q_file_I_paint_next_window();
                            if(l)
                                scrl( -l );
                        }
                        break;
                    }
                  case KEY_BREAK:
                        U_F( E_base_S->E_flow_S_signal, exit );
                        break;
                  case KEY_RESIZE:
                        
                        break;
                  default:
                        beep();
                        endwin(); G_(); Gd( E_main_I_getch_S_c ); V();
                        break;
                }
                break;
          case OK:
            {   if( !( E_main_I_getch_S_c == '\r'
                || E_main_I_getch_S_c == ' '
                || iswgraph( E_main_I_getch_S_c )
                ))
                {   beep();
                    break;
                }
Enter:;         int x, y, x_, y_;
                getyx( stdscr, y, x );
                int x_begin = x, y_begin = y;
                getmaxyx( stdscr, y_, x_ );
                if( E_main_I_getch_S_c == '\r' )
                {   E_mem_Q_file_P_pos( E_main_S_file, E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].start + x );
                    //E_mem_Q_file_P_insert_c( E_main_S_file, '\n' );
                    for( ; x != x_; x++ )
                    {   move( y, x );
                        cchar_t cc;
                        wchar_t s[2] = L" ";
                        setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
                        ins_wch( &cc );
                    }
                    if( E_lines_Q_lines_S_first_on_screen + y + 1 != E_lines_Q_lines_S_l )
                    {   N u_i = E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y + 1 ].start;
                        if( y == y_ - 1 )
                        {   scrl(1);
                            E_lines_Q_lines_S_first_on_screen++;
                            y_begin--;
                            y--;
                        }
                        O{  U u = E_text_Z_getter_Z_c_R_u( &E_main_Q_file_R_c );
                            if( !~u )
                            {   endwin(); G_(); V();
                            }
                            if( (S32)u == E_mem_Q_file_S_eof )
                            {   E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l++;
                                break;
                            }
                            if( !( u == '\n'
                            || u == ' '
                            || iswgraph(u)
                            ))
                            {   endwin(); G_(); V();
                            }
                            if( u == '\n' )
                            {   E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l++;
                                break;
                            }
                            move( y_ - 1, x );
                            cchar_t cc;
                            wchar_t s[2] = { u, '\0' };
                            setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
                            ins_wch( &cc );
                            if( x == x_ - 1 )
                            {   if( y == y_ - 1 )
                                    break;
                                y++;
                                x = 0;
                            }else
                                x++;
                            u_i++;
                        }
                    }
                    if( y_begin != y_ - 1 )
                        move( y_begin + 1, 0 );
                    else
                        move( y_begin, 0 );
                }else
                {   cchar_t cc;
                    wchar_t s[2] = { E_main_I_getch_S_c, '\0' };
                    setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
                    ins_wch( &cc );
                    E_mem_Q_file_P_pos( E_main_S_file, E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].start + x );
                    //E_mem_Q_file_P_insert_c( E_main_S_file, E_main_I_getch_S_c );
                    if( ~E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l
                    && E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l == x_
                    ){  N u_i = E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y + 1 ].start;
                        if( x == x_ - 1
                        && y == y_ - 1
                        ){  scrl(1);
                            E_lines_Q_lines_S_first_on_screen++;
                            y_begin--;
                            y--;
                        }
                        O{  U u = E_text_Z_getter_Z_c_R_u( &E_main_Q_file_R_c );
                            if( !~u )
                            {   endwin(); G_(); V();
                            }
                            if( (S32)u == E_mem_Q_file_S_eof )
                            {   E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l++;
                                break;
                            }
                            if( !( u == '\n'
                            || u == ' '
                            || iswgraph(u)
                            ))
                            {   endwin(); G_(); V();
                            }
                            if( u == '\n' )
                            {   E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y ].l++;
                                break;
                            }
                            move( y_ - 1, x );
                            cchar_t cc;
                            wchar_t s[2] = { u, '\0' };
                            setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
                            ins_wch( &cc );
                            if( x == x_ - 1 )
                            {   if( y == y_ - 1 )
                                    break;
                                y++;
                                x = 0;
                            }else
                                x++;
                            u_i++;
                        }
                    }
                    if( x_begin != x_ - 1 )
                        move( y_begin, x_begin + 1 );
                    else
                    {   if( y_begin != y_ - 1 )
                            move( y_begin + 1, 0 );
                        else
                        {   move( y_begin, 0 );
                            scrl(1);
                        }
                    }
                }
                break;
            }
          default:
            //NDFN error.
            break;
        }
    }
    Xh1_W();
}
//==============================================================================
N
E_main_Q_file_I_paint_prev_window( void
){  
}
N
E_main_Q_file_I_paint_next_window( void
){
}
B
E_main_Q_file_I_paint_first_line( void
){  if( !E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen ].start )
        return no;
    E_lines_Q_lines_I_pop();
    N u_i = E_lines_Q_lines_S[ --E_lines_Q_lines_S_first_on_screen ].start;
    E_mem_Q_file_P_pos( E_main_S_file, u_i );
    int x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    scrl( -1 );
    x = 0;
    O{  U u = E_text_Z_getter_Z_c_R_u( &E_main_Q_file_R_c );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (S32)u == E_mem_Q_file_S_eof )
            return no;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if( u == '\n' )
            break;
        move( 0, x );
        cchar_t cc;
        wchar_t s[2] = { u, '\0' };
        setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        if( x == x_ - 1 )
            break;
        x++;
    }
    return yes;
}
B
E_main_Q_file_I_paint_last_line( void
){  int x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    if( E_lines_Q_lines_S_first_on_screen + y_ - 1 >= E_lines_Q_lines_S_l )
        return no;
    N u_i = E_lines_Q_lines_S[ E_lines_Q_lines_S_first_on_screen + y_ ].start;
    E_lines_Q_lines_S_first_on_screen++;
    E_mem_Q_file_P_pos( E_main_S_file, u_i );
    B start = yes;
    O{  U u = E_text_Z_getter_Z_c_R_u( &E_main_Q_file_R_c );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (S32)u == E_mem_Q_file_S_eof )
            return no;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if(start)
        {   scrl(1);
            start = no;
        }
        if( u == '\n' )
        {   E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].l = u_i + 1 - E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].start;
            E_lines_Q_lines_I_append();
            E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ] = ( struct E_lines_Q_lines_Z ){ u_i + 1, ~0 };
            break;
        }
        move( y_ - 1, x );
        cchar_t cc;
        wchar_t s[2] = { u, '\0' };
        setcchar( &cc, s, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        if( x == x_ - 1 )
        {   E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].l = u_i + 1 - E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ].start;
            E_lines_Q_lines_I_append();
            E_lines_Q_lines_S[ E_lines_Q_lines_S_l - 1 ] = ( struct E_lines_Q_lines_Z ){ u_i + 1, ~0 };
            break;
        }
        x++;
        u_i++;
    }
    return yes;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
