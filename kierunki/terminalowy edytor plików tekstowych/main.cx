/*******************************************************************************
*   ___   workplace
*  ¦OUX¦  ‟Coux”
*  ¦Inc¦  aplikacje terminalowe
*   ---   podstawowy edytor tekstu
*         entry and raw labels
* ©overcq                on ‟Gentoo Linux 13.0” “x86_64”             2015‒7‒25 *
*******************************************************************************/
//zarządzanie liniami
//==============================================================================
Pn E_main_S_line;
N E_main_S_line_n = 1;
N E_main_S_line_i = 0;
N E_main_S_first_line_wrap_i = 0;
N E_main_S_last_line_u_i;
int E_main_I_getch_S_ret;
wint_t E_main_I_getch_S_c;
I file;
//==============================================================================
N
getter( void
){  return E_mem_Q_file_R_c(file);
}
int
main(
  int argc
, Pc *argv
){  if( argc != 2 )
        V();
    E_flow_M( argc, argv );
    initscr();
    start_color();
    init_pair( 1, COLOR_WHITE, COLOR_BLACK );
    attr_set( A_NORMAL, 1, 0 );
    noecho();
    cbreak();
    nonl();
    intrflush( stdscr, FALSE );
    idlok( stdscr, TRUE );
    idcok( stdscr, TRUE );
    scrollok( stdscr, TRUE );
    leaveok( stdscr, FALSE );
    immedok( stdscr, FALSE );
    keypad( stdscr, TRUE );
    notimeout( stdscr, TRUE );
    nodelay( stdscr, FALSE );
    if( !~( file = E_mem_Q_file_M( argv[1] )))
    {   endwin(); G_(); V();
    }
    int y = 0, x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    N u_i = 0;
    Mt_( E_main_S_line, 1 );
    *E_main_S_line = 0;
    O{  U u = E_text_Z_getter_Z_c_R_u( &getter );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (N)u == E_mem_Q_file_S_eof )
            break;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if( u == '\n' )
        {   E_mem_Q_blk_I_append( &E_main_S_line, 1 );
            E_main_S_line[ E_main_S_line_n++ ] = u_i;
            if( y == y_ - 1 )
                break;
            y++;
            x = 0;
        }else if( x == x_ )
        {   if( y == y_ - 1 )
                break;
            y++;
            x = 0;
        }else
            x++;
        cchar_t cc;
        setcchar( &cc, ( wchar_t * )&u, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        move( y, x );
        u_i++;
    }
    E_main_S_last_line_u_i = u_i + 1;
    D_M( main, getch );
    X_M( main, none );
    X_B( main, none, 0 ){}
    X_W( main, none );
    D_W( main, getch );
    endwin();
    E_flow_W();
    return 0;
}
bool
E_main_I_sigsuspend( sigset_t *sigset
){  sigset_t old_sigset;
    _sigprocmask( SIG_SETMASK, sigset, &old_sigset ); //NDFN dopóki jest tak zrobione, że odblokowanie “sygnałów” jest wcześniej niż zablokowanie na “read”, to mogą występować przypadki zablokowania oczekującego na “read” mimo “sygnału” (ustawiającego “wake”) obsłużonego i danych czekających na przetworzenie w ‹zadaniach›, a gdy nie jest ustawione “E_flow_Q_system_unblock_report_S_setitimer_I”, to oczywiście– nieodblokowania po ustawionym czasie —do czasu ‹systemowego raportu odblokowującego› lub nietrafienia któregoś interpretowanego (ustawiającego “wake”) “sygnału” w obszar programu pomiędzy tym “sigprocmask” a “read” w “E_flow_Q_system_unblock_report_S_sigsuspend_I”.
    E_main_I_getch_S_ret = get_wch( &E_main_I_getch_S_c );
    _sigprocmask( SIG_SETMASK, &old_sigset, 0 );
    return E_main_I_getch_S_ret != ERR; ///naciśnięto klawisz.
}
void
E_main_I_setitimer( Z_clock_time *tv
){
#ifndef E_flow_drv_C_clock_monotonic
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999 ) / 1000 );
#else
    timeout( tv->tv_sec * 1000 + ( tv->Z_clock_time_minor_field + 999999 ) / 1000000 );
#endif
}
D( main, getch )
{   Xh1_M( &E_main_I_sigsuspend, &E_main_I_setitimer );
    I_D
    {   Xh1_B()
        {   E_mem_Q_file_W(file);
            break;
        }
        switch( E_main_I_getch_S_ret )
        { case KEY_CODE_YES:
                switch( E_main_I_getch_S_c )
                { case KEY_DC:
                        delch();
                        break;
                  case KEY_BACKSPACE:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                        {   move( y, x - 1 );
                            delch();
                        }else
                        {   int y_, x_;
                            getmaxyx( stdscr, y_, x_ );
                            if(y)
                                move( y - 1, x_ - 1 );
                            else
                                if( E_main_Q_file_I_paint_first_line() )
                                    move( y, x_ - 1 );
                        }
                        break;
                    }
                  case 343: ///‛Enter’ na klawiaturze numerycznej.
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( y < y_ - 1 )
                            move( y + 1, 0 );
                        else
                        {   move( y, 0 );
                            scrl(1);
                            //E_main_Q_file_I_paint_line();
                        }
                        break;
                    }
                  case KEY_RIGHT:
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( x < x_ - 1 )
                            move( y, x + 1 );
                        else
                        {   if( y < y_ - 1 )
                                move( y + 1, 0 );
                            else
                                if( E_main_Q_file_I_paint_last_line() )
                                    move( y, 0 );
                        }
                        break;
                    }
                  case KEY_LEFT:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                            move( y, x - 1 );
                        else
                        {   int y_, x_;
                            getmaxyx( stdscr, y_, x_ );
                            if(y)
                                move( y - 1, x_ - 1 );
                            else
                                if( E_main_Q_file_I_paint_first_line() )
                                    move( y, x_ - 1 );
                        }
                        break;
                    }
                  case KEY_DOWN:
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( y < y_ - 1 )
                            move( y + 1, x );
                        else
                            E_main_Q_file_I_paint_last_line();
                        break;
                    }
                  case KEY_UP:
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( y > 0 )
                            move( y - 1, x );
                        else
                            E_main_Q_file_I_paint_first_line();
                        break;
                    }
                  case KEY_HOME:
                  case 348: //na klawiaturze numerycznej.
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( x > 0 )
                            move( y, 0 );
                        break;
                    }
                  case KEY_END:
                  case 351: //na klawiaturze numerycznej.
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( x < x_ - 1 )
                            move( y, x_ - 1 );
                        break;
                    }
                  case KEY_NPAGE:
                  case 352: //na klawiaturze numerycznej.
                    {   int y, x, y_, x_;
                        getyx( stdscr, y, x );
                        getmaxyx( stdscr, y_, x_ );
                        if( y < y_ - 1 )
                            move( y_ - 1, x );
                        else
                            E_main_Q_file_I_paint_window();
                        break;
                    }
                  case KEY_PPAGE:
                  case 349: //na klawiaturze numerycznej.
                    {   int y, x;
                        getyx( stdscr, y, x );
                        if( y > 0 )
                            move( 0, x );
                        else
                            E_main_Q_file_I_paint_window();
                        break;
                    }
                  case KEY_BREAK:
                        U_F( E_base_S->E_flow_S_signal, exit );
                        break;
                  case KEY_RESIZE:
                        
                        break;
                  default:
                        beep();
                        endwin(); G_(); Gd( E_main_I_getch_S_c ); V();
                        break;
                }
                break;
          case OK:
            {   if( !( E_main_I_getch_S_c == '\r'
                || E_main_I_getch_S_c == ' '
                || iswgraph( E_main_I_getch_S_c )
                ))
                {   beep();
                    break;
                }
                int y, x, y_, x_;
                getyx( stdscr, y, x );
                getmaxyx( stdscr, y_, x_ );
                if( E_main_I_getch_S_c == '\r' )
                    if( y < y_ - 1 )
                        move( y + 1, 0 );
                    else
                    {   move( y, 0 );
                        scrl(1);
                        //E_main_Q_file_I_paint_line();
                    }
                else //NDFN zawijanie linii.
                {   cchar_t cc;
                    setcchar( &cc, ( wchar_t * )&E_main_I_getch_S_c, A_NORMAL, COLOR_PAIR(0), 0 );
                    ins_wch( &cc );
                    if( x < x_ - 1 )
                        move( y, x + 1 );
                    else
                    {   if( y < y_ - 1 )
                            move( y + 1, 0 );
                        else
                        {   move( y, 0 );
                            scrl(1);
                            E_main_Q_file_I_paint_line();
                        }
                    }
                }
                break;
            }
          default:
            //NDFN error.
            break;
        }
    }
    Xh1_W();
}
//==============================================================================
void
E_main_Q_file_I_paint_window( void
){
}
void
E_main_Q_file_I_paint_line( void
){
}
B
E_main_Q_file_I_paint_first_line( void
){  if( !E_main_S_line_i
    && !E_main_S_first_line_wrap_i
    )
        return no;
    N u_i = E_main_S_line[ E_main_S_line_i ], wrap_u_i = u_i;
    N line_wrap_i = 0;
    E_mem_Q_file_P_pos( file, u_i );
    int x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    O{  U u = E_text_Z_getter_Z_c_R_u( &getter );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (N)u == E_mem_Q_file_S_eof )
            return no;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if( u == '\n' )
            break;
        if( x == x_ )
        {   if( E_main_S_first_line_wrap_i
            && line_wrap_i == E_main_S_first_line_wrap_i - 1
            )
            {   E_main_S_first_line_wrap_i--;
                break;
            }
            x = 0;
            wrap_u_i = u_i + 1;
            line_wrap_i++;
        }else
            x++;
        u_i++;
    }
    scrl( -1 );
    E_mem_Q_file_P_pos( file, wrap_u_i );
    x = 0;
    O{  U u = E_text_Z_getter_Z_c_R_u( &getter );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (N)u == E_mem_Q_file_S_eof )
            return no;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if( u == '\n' )
            break;
        if( u == '\n'
        || x == x_
        )
            break;
        x++;
        cchar_t cc;
        setcchar( &cc, ( wchar_t * )&u, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        move( 0, x );
    }
    return yes;
}
B
E_main_Q_file_I_paint_last_line( void
){  N u_i = E_main_S_last_line_u_i;
    E_mem_Q_file_P_pos( file, u_i );
    int x = 0, y_, x_;
    getmaxyx( stdscr, y_, x_ );
    B start = yes;
    O{  U u = E_text_Z_getter_Z_c_R_u( &getter );
        if( !~u )
        {   endwin(); G_(); V();
        }
        if( (N)u == E_mem_Q_file_S_eof )
            return no;
        if( !( u == '\n'
        || u == ' '
        || iswgraph(u)
        ))
        {   endwin(); G_(); V();
        }
        if(start)
        {   E_main_S_line_i++; //NDFN ma być obliczanie zawiniętej linii.
            scrl(1);
            start = no;
        }
        E_main_S_last_line_u_i++;
        if( u == '\n'
        || x == x_
        )
            break;
        x++;
        cchar_t cc;
        setcchar( &cc, ( wchar_t * )&u, A_NORMAL, COLOR_PAIR(0), 0 );
        ins_wch( &cc );
        move( y_ - 1, x );
    }
    return yes;
}
//==============================================================================
void
E_flow_Q_process_call_I_func( void *data
){
}
/******************************************************************************/
